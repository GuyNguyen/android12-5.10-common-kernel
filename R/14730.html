<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>worker</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.6.4' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/12.html#L330'>worker</a>            330 async.c        	struct worker *worker = current_wq_worker();</span>
<span class='curline'><a href='../S/12.html#L332'>worker</a>            332 async.c        	return worker &amp;&amp; worker-&gt;current_func == async_run_entry_fn;</span>
<span class='curline'><a href='../S/435.html#L669'>worker</a>            669 kthread.c      void __kthread_init_worker(struct kthread_worker *worker,</span>
<span class='curline'><a href='../S/435.html#L673'>worker</a>            673 kthread.c      	memset(worker, 0, sizeof(struct kthread_worker));</span>
<span class='curline'><a href='../S/435.html#L674'>worker</a>            674 kthread.c      	raw_spin_lock_init(&amp;worker-&gt;lock);</span>
<span class='curline'><a href='../S/435.html#L675'>worker</a>            675 kthread.c      	lockdep_set_class_and_name(&amp;worker-&gt;lock, key, name);</span>
<span class='curline'><a href='../S/435.html#L676'>worker</a>            676 kthread.c      	INIT_LIST_HEAD(&amp;worker-&gt;work_list);</span>
<span class='curline'><a href='../S/435.html#L677'>worker</a>            677 kthread.c      	INIT_LIST_HEAD(&amp;worker-&gt;delayed_work_list);</span>
<span class='curline'><a href='../S/435.html#L698'>worker</a>            698 kthread.c      	struct kthread_worker *worker = worker_ptr;</span>
<span class='curline'><a href='../S/435.html#L705'>worker</a>            705 kthread.c      	WARN_ON(worker-&gt;task &amp;&amp; worker-&gt;task != current);</span>
<span class='curline'><a href='../S/435.html#L706'>worker</a>            706 kthread.c      	worker-&gt;task = current;</span>
<span class='curline'><a href='../S/435.html#L708'>worker</a>            708 kthread.c      	if (worker-&gt;flags &amp; KTW_FREEZABLE)</span>
<span class='curline'><a href='../S/435.html#L716'>worker</a>            716 kthread.c      		raw_spin_lock_irq(&amp;worker-&gt;lock);</span>
<span class='curline'><a href='../S/435.html#L717'>worker</a>            717 kthread.c      		worker-&gt;task = NULL;</span>
<span class='curline'><a href='../S/435.html#L718'>worker</a>            718 kthread.c      		raw_spin_unlock_irq(&amp;worker-&gt;lock);</span>
<span class='curline'><a href='../S/435.html#L723'>worker</a>            723 kthread.c      	raw_spin_lock_irq(&amp;worker-&gt;lock);</span>
<span class='curline'><a href='../S/435.html#L724'>worker</a>            724 kthread.c      	if (!list_empty(&amp;worker-&gt;work_list)) {</span>
<span class='curline'><a href='../S/435.html#L725'>worker</a>            725 kthread.c      		work = list_first_entry(&amp;worker-&gt;work_list,</span>
<span class='curline'><a href='../S/435.html#L729'>worker</a>            729 kthread.c      	worker-&gt;current_work = work;</span>
<span class='curline'><a href='../S/435.html#L730'>worker</a>            730 kthread.c      	raw_spin_unlock_irq(&amp;worker-&gt;lock);</span>
<span class='curline'><a href='../S/435.html#L748'>worker</a>            748 kthread.c      	struct kthread_worker *worker;</span>
<span class='curline'><a href='../S/435.html#L752'>worker</a>            752 kthread.c      	worker = kzalloc(sizeof(*worker), GFP_KERNEL);</span>
<span class='curline'><a href='../S/435.html#L753'>worker</a>            753 kthread.c      	if (!worker)</span>
<span class='curline'><a href='../S/435.html#L756'>worker</a>            756 kthread.c      	kthread_init_worker(worker);</span>
<span class='curline'><a href='../S/435.html#L761'>worker</a>            761 kthread.c      	task = __kthread_create_on_node(kthread_worker_fn, worker,</span>
<span class='curline'><a href='../S/435.html#L769'>worker</a>            769 kthread.c      	worker-&gt;flags = flags;</span>
<span class='curline'><a href='../S/435.html#L770'>worker</a>            770 kthread.c      	worker-&gt;task = task;</span>
<span class='curline'><a href='../S/435.html#L772'>worker</a>            772 kthread.c      	return worker;</span>
<span class='curline'><a href='../S/435.html#L775'>worker</a>            775 kthread.c      	kfree(worker);</span>
<span class='curline'><a href='../S/435.html#L791'>worker</a>            791 kthread.c      	struct kthread_worker *worker;</span>
<span class='curline'><a href='../S/435.html#L795'>worker</a>            795 kthread.c      	worker = __kthread_create_worker(-1, flags, namefmt, args);</span>
<span class='curline'><a href='../S/435.html#L798'>worker</a>            798 kthread.c      	return worker;</span>
<span class='curline'><a href='../S/435.html#L823'>worker</a>            823 kthread.c      	struct kthread_worker *worker;</span>
<span class='curline'><a href='../S/435.html#L827'>worker</a>            827 kthread.c      	worker = __kthread_create_worker(cpu, flags, namefmt, args);</span>
<span class='curline'><a href='../S/435.html#L830'>worker</a>            830 kthread.c      	return worker;</span>
<span class='curline'><a href='../S/435.html#L839'>worker</a>            839 kthread.c      static inline bool queuing_blocked(struct kthread_worker *worker,</span>
<span class='curline'><a href='../S/435.html#L842'>worker</a>            842 kthread.c      	lockdep_assert_held(&amp;worker-&gt;lock);</span>
<span class='curline'><a href='../S/435.html#L847'>worker</a>            847 kthread.c      static void kthread_insert_work_sanity_check(struct kthread_worker *worker,</span>
<span class='curline'><a href='../S/435.html#L850'>worker</a>            850 kthread.c      	lockdep_assert_held(&amp;worker-&gt;lock);</span>
<span class='curline'><a href='../S/435.html#L853'>worker</a>            853 kthread.c      	WARN_ON_ONCE(work-&gt;worker &amp;&amp; work-&gt;worker != worker);</span>
<span class='curline'><a href='../S/435.html#L857'>worker</a>            857 kthread.c      static void kthread_insert_work(struct kthread_worker *worker,</span>
<span class='curline'><a href='../S/435.html#L861'>worker</a>            861 kthread.c      	kthread_insert_work_sanity_check(worker, work);</span>
<span class='curline'><a href='../S/435.html#L864'>worker</a>            864 kthread.c      	work-&gt;worker = worker;</span>
<span class='curline'><a href='../S/435.html#L865'>worker</a>            865 kthread.c      	if (!worker-&gt;current_work &amp;&amp; likely(worker-&gt;task))</span>
<span class='curline'><a href='../S/435.html#L866'>worker</a>            866 kthread.c      		wake_up_process(worker-&gt;task);</span>
<span class='curline'><a href='../S/435.html#L881'>worker</a>            881 kthread.c      bool kthread_queue_work(struct kthread_worker *worker,</span>
<span class='curline'><a href='../S/435.html#L887'>worker</a>            887 kthread.c      	raw_spin_lock_irqsave(&amp;worker-&gt;lock, flags);</span>
<span class='curline'><a href='../S/435.html#L888'>worker</a>            888 kthread.c      	if (!queuing_blocked(worker, work)) {</span>
<span class='curline'><a href='../S/435.html#L889'>worker</a>            889 kthread.c      		kthread_insert_work(worker, work, &amp;worker-&gt;work_list);</span>
<span class='curline'><a href='../S/435.html#L892'>worker</a>            892 kthread.c      	raw_spin_unlock_irqrestore(&amp;worker-&gt;lock, flags);</span>
<span class='curline'><a href='../S/435.html#L909'>worker</a>            909 kthread.c      	struct kthread_worker *worker = work-&gt;worker;</span>
<span class='curline'><a href='../S/435.html#L916'>worker</a>            916 kthread.c      	if (WARN_ON_ONCE(!worker))</span>
<span class='curline'><a href='../S/435.html#L919'>worker</a>            919 kthread.c      	raw_spin_lock_irqsave(&amp;worker-&gt;lock, flags);</span>
<span class='curline'><a href='../S/435.html#L921'>worker</a>            921 kthread.c      	WARN_ON_ONCE(work-&gt;worker != worker);</span>
<span class='curline'><a href='../S/435.html#L927'>worker</a>            927 kthread.c      		kthread_insert_work(worker, work, &amp;worker-&gt;work_list);</span>
<span class='curline'><a href='../S/435.html#L929'>worker</a>            929 kthread.c      	raw_spin_unlock_irqrestore(&amp;worker-&gt;lock, flags);</span>
<span class='curline'><a href='../S/435.html#L933'>worker</a>            933 kthread.c      static void __kthread_queue_delayed_work(struct kthread_worker *worker,</span>
<span class='curline'><a href='../S/435.html#L955'>worker</a>            955 kthread.c      		kthread_insert_work(worker, work, &amp;worker-&gt;work_list);</span>
<span class='curline'><a href='../S/435.html#L960'>worker</a>            960 kthread.c      	kthread_insert_work_sanity_check(worker, work);</span>
<span class='curline'><a href='../S/435.html#L962'>worker</a>            962 kthread.c      	list_add(&amp;work-&gt;node, &amp;worker-&gt;delayed_work_list);</span>
<span class='curline'><a href='../S/435.html#L963'>worker</a>            963 kthread.c      	work-&gt;worker = worker;</span>
<span class='curline'><a href='../S/435.html#L983'>worker</a>            983 kthread.c      bool kthread_queue_delayed_work(struct kthread_worker *worker,</span>
<span class='curline'><a href='../S/435.html#L991'>worker</a>            991 kthread.c      	raw_spin_lock_irqsave(&amp;worker-&gt;lock, flags);</span>
<span class='curline'><a href='../S/435.html#L993'>worker</a>            993 kthread.c      	if (!queuing_blocked(worker, work)) {</span>
<span class='curline'><a href='../S/435.html#L994'>worker</a>            994 kthread.c      		__kthread_queue_delayed_work(worker, dwork, delay);</span>
<span class='curline'><a href='../S/435.html#L998'>worker</a>            998 kthread.c      	raw_spin_unlock_irqrestore(&amp;worker-&gt;lock, flags);</span>
<span class='curline'><a href='../S/435.html#L1027'>worker</a>           1027 kthread.c      	struct kthread_worker *worker;</span>
<span class='curline'><a href='../S/435.html#L1030'>worker</a>           1030 kthread.c      	worker = work-&gt;worker;</span>
<span class='curline'><a href='../S/435.html#L1031'>worker</a>           1031 kthread.c      	if (!worker)</span>
<span class='curline'><a href='../S/435.html#L1034'>worker</a>           1034 kthread.c      	raw_spin_lock_irq(&amp;worker-&gt;lock);</span>
<span class='curline'><a href='../S/435.html#L1036'>worker</a>           1036 kthread.c      	WARN_ON_ONCE(work-&gt;worker != worker);</span>
<span class='curline'><a href='../S/435.html#L1039'>worker</a>           1039 kthread.c      		kthread_insert_work(worker, &amp;fwork.work, work-&gt;node.next);</span>
<span class='curline'><a href='../S/435.html#L1040'>worker</a>           1040 kthread.c      	else if (worker-&gt;current_work == work)</span>
<span class='curline'><a href='../S/435.html#L1041'>worker</a>           1041 kthread.c      		kthread_insert_work(worker, &amp;fwork.work,</span>
<span class='curline'><a href='../S/435.html#L1042'>worker</a>           1042 kthread.c      				    worker-&gt;work_list.next);</span>
<span class='curline'><a href='../S/435.html#L1046'>worker</a>           1046 kthread.c      	raw_spin_unlock_irq(&amp;worker-&gt;lock);</span>
<span class='curline'><a href='../S/435.html#L1070'>worker</a>           1070 kthread.c      		struct kthread_worker *worker = work-&gt;worker;</span>
<span class='curline'><a href='../S/435.html#L1079'>worker</a>           1079 kthread.c      		raw_spin_unlock_irqrestore(&amp;worker-&gt;lock, *flags);</span>
<span class='curline'><a href='../S/435.html#L1081'>worker</a>           1081 kthread.c      		raw_spin_lock_irqsave(&amp;worker-&gt;lock, *flags);</span>
<span class='curline'><a href='../S/435.html#L1120'>worker</a>           1120 kthread.c      bool kthread_mod_delayed_work(struct kthread_worker *worker,</span>
<span class='curline'><a href='../S/435.html#L1128'>worker</a>           1128 kthread.c      	raw_spin_lock_irqsave(&amp;worker-&gt;lock, flags);</span>
<span class='curline'><a href='../S/435.html#L1131'>worker</a>           1131 kthread.c      	if (!work-&gt;worker)</span>
<span class='curline'><a href='../S/435.html#L1135'>worker</a>           1135 kthread.c      	WARN_ON_ONCE(work-&gt;worker != worker);</span>
<span class='curline'><a href='../S/435.html#L1156'>worker</a>           1156 kthread.c      	__kthread_queue_delayed_work(worker, dwork, delay);</span>
<span class='curline'><a href='../S/435.html#L1158'>worker</a>           1158 kthread.c      	raw_spin_unlock_irqrestore(&amp;worker-&gt;lock, flags);</span>
<span class='curline'><a href='../S/435.html#L1165'>worker</a>           1165 kthread.c      	struct kthread_worker *worker = work-&gt;worker;</span>
<span class='curline'><a href='../S/435.html#L1169'>worker</a>           1169 kthread.c      	if (!worker)</span>
<span class='curline'><a href='../S/435.html#L1172'>worker</a>           1172 kthread.c      	raw_spin_lock_irqsave(&amp;worker-&gt;lock, flags);</span>
<span class='curline'><a href='../S/435.html#L1174'>worker</a>           1174 kthread.c      	WARN_ON_ONCE(work-&gt;worker != worker);</span>
<span class='curline'><a href='../S/435.html#L1178'>worker</a>           1178 kthread.c      	if (worker-&gt;current_work != work)</span>
<span class='curline'><a href='../S/435.html#L1186'>worker</a>           1186 kthread.c      	raw_spin_unlock_irqrestore(&amp;worker-&gt;lock, flags);</span>
<span class='curline'><a href='../S/435.html#L1188'>worker</a>           1188 kthread.c      	raw_spin_lock_irqsave(&amp;worker-&gt;lock, flags);</span>
<span class='curline'><a href='../S/435.html#L1192'>worker</a>           1192 kthread.c      	raw_spin_unlock_irqrestore(&amp;worker-&gt;lock, flags);</span>
<span class='curline'><a href='../S/435.html#L1241'>worker</a>           1241 kthread.c      void kthread_flush_worker(struct kthread_worker *worker)</span>
<span class='curline'><a href='../S/435.html#L1248'>worker</a>           1248 kthread.c      	kthread_queue_work(worker, &amp;fwork.work);</span>
<span class='curline'><a href='../S/435.html#L1261'>worker</a>           1261 kthread.c      void kthread_destroy_worker(struct kthread_worker *worker)</span>
<span class='curline'><a href='../S/435.html#L1265'>worker</a>           1265 kthread.c      	task = worker-&gt;task;</span>
<span class='curline'><a href='../S/435.html#L1269'>worker</a>           1269 kthread.c      	kthread_flush_worker(worker);</span>
<span class='curline'><a href='../S/435.html#L1271'>worker</a>           1271 kthread.c      	WARN_ON(!list_empty(&amp;worker-&gt;work_list));</span>
<span class='curline'><a href='../S/435.html#L1272'>worker</a>           1272 kthread.c      	kfree(worker);</span>
<span class='curline'><a href='../S/466.html#L40'>worker</a>             40 sched/cpufreq_schedutil.c 	struct			kthread_worker worker;</span>
<span class='curline'><a href='../S/466.html#L575'>worker</a>            575 sched/cpufreq_schedutil.c 	kthread_queue_work(&amp;sg_policy-&gt;worker, &amp;sg_policy-&gt;work);</span>
<span class='curline'><a href='../S/466.html#L673'>worker</a>            673 sched/cpufreq_schedutil.c 	kthread_init_worker(&amp;sg_policy-&gt;worker);</span>
<span class='curline'><a href='../S/466.html#L674'>worker</a>            674 sched/cpufreq_schedutil.c 	thread = kthread_create(kthread_worker_fn, &amp;sg_policy-&gt;worker,</span>
<span class='curline'><a href='../S/466.html#L705'>worker</a>            705 sched/cpufreq_schedutil.c 	kthread_flush_worker(&amp;sg_policy-&gt;worker);</span>
<span class='curline'><a href='../S/365.html#L174'>worker</a>            174 workqueue.c    	struct worker		*manager;	/* L: purely informational */</span>
<span class='curline'><a href='../S/365.html#L256'>worker</a>            256 workqueue.c    	struct worker		*rescuer;	/* MD: rescue worker */</span>
<span class='curline'><a href='../S/365.html#L415'>worker</a>            415 workqueue.c    #define for_each_pool_worker(worker, pool)				\</span>
<span class='curline'><a href='../S/365.html#L416'>worker</a>            416 workqueue.c    	list_for_each_entry((worker), &amp;(pool)-&gt;workers, node)		\</span>
<span class='curline'><a href='../S/365.html#L823'>worker</a>            823 workqueue.c    static struct worker *first_idle_worker(struct worker_pool *pool)</span>
<span class='curline'><a href='../S/365.html#L828'>worker</a>            828 workqueue.c    	return list_first_entry(&amp;pool-&gt;idle_list, struct worker, entry);</span>
<span class='curline'><a href='../S/365.html#L842'>worker</a>            842 workqueue.c    	struct worker *worker = first_idle_worker(pool);</span>
<span class='curline'><a href='../S/365.html#L844'>worker</a>            844 workqueue.c    	if (likely(worker))</span>
<span class='curline'><a href='../S/365.html#L845'>worker</a>            845 workqueue.c    		wake_up_process(worker-&gt;task);</span>
<span class='curline'><a href='../S/365.html#L856'>worker</a>            856 workqueue.c    	struct worker *worker = kthread_data(task);</span>
<span class='curline'><a href='../S/365.html#L858'>worker</a>            858 workqueue.c    	if (!worker-&gt;sleeping)</span>
<span class='curline'><a href='../S/365.html#L860'>worker</a>            860 workqueue.c    	if (!(worker-&gt;flags &amp; WORKER_NOT_RUNNING))</span>
<span class='curline'><a href='../S/365.html#L861'>worker</a>            861 workqueue.c    		atomic_inc(&amp;worker-&gt;pool-&gt;nr_running);</span>
<span class='curline'><a href='../S/365.html#L862'>worker</a>            862 workqueue.c    	worker-&gt;sleeping = 0;</span>
<span class='curline'><a href='../S/365.html#L875'>worker</a>            875 workqueue.c    	struct worker *next, *worker = kthread_data(task);</span>
<span class='curline'><a href='../S/365.html#L883'>worker</a>            883 workqueue.c    	if (worker-&gt;flags &amp; WORKER_NOT_RUNNING)</span>
<span class='curline'><a href='../S/365.html#L886'>worker</a>            886 workqueue.c    	pool = worker-&gt;pool;</span>
<span class='curline'><a href='../S/365.html#L889'>worker</a>            889 workqueue.c    	if (worker-&gt;sleeping)</span>
<span class='curline'><a href='../S/365.html#L892'>worker</a>            892 workqueue.c    	worker-&gt;sleeping = 1;</span>
<span class='curline'><a href='../S/365.html#L941'>worker</a>            941 workqueue.c    	struct worker *worker = kthread_data(task);</span>
<span class='curline'><a href='../S/365.html#L943'>worker</a>            943 workqueue.c    	return worker-&gt;last_func;</span>
<span class='curline'><a href='../S/365.html#L956'>worker</a>            956 workqueue.c    static inline void worker_set_flags(struct worker *worker, unsigned int flags)</span>
<span class='curline'><a href='../S/365.html#L958'>worker</a>            958 workqueue.c    	struct worker_pool *pool = worker-&gt;pool;</span>
<span class='curline'><a href='../S/365.html#L960'>worker</a>            960 workqueue.c    	WARN_ON_ONCE(worker-&gt;task != current);</span>
<span class='curline'><a href='../S/365.html#L964'>worker</a>            964 workqueue.c    	    !(worker-&gt;flags &amp; WORKER_NOT_RUNNING)) {</span>
<span class='curline'><a href='../S/365.html#L968'>worker</a>            968 workqueue.c    	worker-&gt;flags |= flags;</span>
<span class='curline'><a href='../S/365.html#L981'>worker</a>            981 workqueue.c    static inline void worker_clr_flags(struct worker *worker, unsigned int flags)</span>
<span class='curline'><a href='../S/365.html#L983'>worker</a>            983 workqueue.c    	struct worker_pool *pool = worker-&gt;pool;</span>
<span class='curline'><a href='../S/365.html#L984'>worker</a>            984 workqueue.c    	unsigned int oflags = worker-&gt;flags;</span>
<span class='curline'><a href='../S/365.html#L986'>worker</a>            986 workqueue.c    	WARN_ON_ONCE(worker-&gt;task != current);</span>
<span class='curline'><a href='../S/365.html#L988'>worker</a>            988 workqueue.c    	worker-&gt;flags &amp;= ~flags;</span>
<span class='curline'><a href='../S/365.html#L996'>worker</a>            996 workqueue.c    		if (!(worker-&gt;flags &amp; WORKER_NOT_RUNNING))</span>
<span class='curline'><a href='../S/365.html#L1033'>worker</a>           1033 workqueue.c    static struct worker *find_worker_executing_work(struct worker_pool *pool,</span>
<span class='curline'><a href='../S/365.html#L1036'>worker</a>           1036 workqueue.c    	struct worker *worker;</span>
<span class='curline'><a href='../S/365.html#L1038'>worker</a>           1038 workqueue.c    	hash_for_each_possible(pool-&gt;busy_hash, worker, hentry,</span>
<span class='curline'><a href='../S/365.html#L1040'>worker</a>           1040 workqueue.c    		if (worker-&gt;current_work == work &amp;&amp;</span>
<span class='curline'><a href='../S/365.html#L1041'>worker</a>           1041 workqueue.c    		    worker-&gt;current_func == work-&gt;func)</span>
<span class='curline'><a href='../S/365.html#L1042'>worker</a>           1042 workqueue.c    			return worker;</span>
<span class='curline'><a href='../S/365.html#L1363'>worker</a>           1363 workqueue.c    	struct worker *worker;</span>
<span class='curline'><a href='../S/365.html#L1365'>worker</a>           1365 workqueue.c    	worker = current_wq_worker();</span>
<span class='curline'><a href='../S/365.html#L1370'>worker</a>           1370 workqueue.c    	return worker &amp;&amp; worker-&gt;current_pwq-&gt;wq == wq;</span>
<span class='curline'><a href='../S/365.html#L1448'>worker</a>           1448 workqueue.c    		struct worker *worker;</span>
<span class='curline'><a href='../S/365.html#L1452'>worker</a>           1452 workqueue.c    		worker = find_worker_executing_work(last_pool, work);</span>
<span class='curline'><a href='../S/365.html#L1454'>worker</a>           1454 workqueue.c    		if (worker &amp;&amp; worker-&gt;current_pwq-&gt;wq == wq) {</span>
<span class='curline'><a href='../S/365.html#L1455'>worker</a>           1455 workqueue.c    			pwq = worker-&gt;current_pwq;</span>
<span class='curline'><a href='../S/365.html#L1786'>worker</a>           1786 workqueue.c    static void worker_enter_idle(struct worker *worker)</span>
<span class='curline'><a href='../S/365.html#L1788'>worker</a>           1788 workqueue.c    	struct worker_pool *pool = worker-&gt;pool;</span>
<span class='curline'><a href='../S/365.html#L1790'>worker</a>           1790 workqueue.c    	if (WARN_ON_ONCE(worker-&gt;flags &amp; WORKER_IDLE) ||</span>
<span class='curline'><a href='../S/365.html#L1791'>worker</a>           1791 workqueue.c    	    WARN_ON_ONCE(!list_empty(&amp;worker-&gt;entry) &amp;&amp;</span>
<span class='curline'><a href='../S/365.html#L1792'>worker</a>           1792 workqueue.c    			 (worker-&gt;hentry.next || worker-&gt;hentry.pprev)))</span>
<span class='curline'><a href='../S/365.html#L1796'>worker</a>           1796 workqueue.c    	worker-&gt;flags |= WORKER_IDLE;</span>
<span class='curline'><a href='../S/365.html#L1798'>worker</a>           1798 workqueue.c    	worker-&gt;last_active = jiffies;</span>
<span class='curline'><a href='../S/365.html#L1801'>worker</a>           1801 workqueue.c    	list_add(&amp;worker-&gt;entry, &amp;pool-&gt;idle_list);</span>
<span class='curline'><a href='../S/365.html#L1826'>worker</a>           1826 workqueue.c    static void worker_leave_idle(struct worker *worker)</span>
<span class='curline'><a href='../S/365.html#L1828'>worker</a>           1828 workqueue.c    	struct worker_pool *pool = worker-&gt;pool;</span>
<span class='curline'><a href='../S/365.html#L1830'>worker</a>           1830 workqueue.c    	if (WARN_ON_ONCE(!(worker-&gt;flags &amp; WORKER_IDLE)))</span>
<span class='curline'><a href='../S/365.html#L1832'>worker</a>           1832 workqueue.c    	worker_clr_flags(worker, WORKER_IDLE);</span>
<span class='curline'><a href='../S/365.html#L1834'>worker</a>           1834 workqueue.c    	list_del_init(&amp;worker-&gt;entry);</span>
<span class='curline'><a href='../S/365.html#L1837'>worker</a>           1837 workqueue.c    static struct worker *alloc_worker(int node)</span>
<span class='curline'><a href='../S/365.html#L1839'>worker</a>           1839 workqueue.c    	struct worker *worker;</span>
<span class='curline'><a href='../S/365.html#L1841'>worker</a>           1841 workqueue.c    	worker = kzalloc_node(sizeof(*worker), GFP_KERNEL, node);</span>
<span class='curline'><a href='../S/365.html#L1842'>worker</a>           1842 workqueue.c    	if (worker) {</span>
<span class='curline'><a href='../S/365.html#L1843'>worker</a>           1843 workqueue.c    		INIT_LIST_HEAD(&amp;worker-&gt;entry);</span>
<span class='curline'><a href='../S/365.html#L1844'>worker</a>           1844 workqueue.c    		INIT_LIST_HEAD(&amp;worker-&gt;scheduled);</span>
<span class='curline'><a href='../S/365.html#L1845'>worker</a>           1845 workqueue.c    		INIT_LIST_HEAD(&amp;worker-&gt;node);</span>
<span class='curline'><a href='../S/365.html#L1847'>worker</a>           1847 workqueue.c    		worker-&gt;flags = WORKER_PREP;</span>
<span class='curline'><a href='../S/365.html#L1849'>worker</a>           1849 workqueue.c    	return worker;</span>
<span class='curline'><a href='../S/365.html#L1861'>worker</a>           1861 workqueue.c    static void worker_attach_to_pool(struct worker *worker,</span>
<span class='curline'><a href='../S/365.html#L1872'>worker</a>           1872 workqueue.c    		worker-&gt;flags |= WORKER_UNBOUND;</span>
<span class='curline'><a href='../S/365.html#L1874'>worker</a>           1874 workqueue.c    	if (worker-&gt;rescue_wq)</span>
<span class='curline'><a href='../S/365.html#L1875'>worker</a>           1875 workqueue.c    		set_cpus_allowed_ptr(worker-&gt;task, pool-&gt;attrs-&gt;cpumask);</span>
<span class='curline'><a href='../S/365.html#L1877'>worker</a>           1877 workqueue.c    	list_add_tail(&amp;worker-&gt;node, &amp;pool-&gt;workers);</span>
<span class='curline'><a href='../S/365.html#L1878'>worker</a>           1878 workqueue.c    	worker-&gt;pool = pool;</span>
<span class='curline'><a href='../S/365.html#L1891'>worker</a>           1891 workqueue.c    static void worker_detach_from_pool(struct worker *worker)</span>
<span class='curline'><a href='../S/365.html#L1893'>worker</a>           1893 workqueue.c    	struct worker_pool *pool = worker-&gt;pool;</span>
<span class='curline'><a href='../S/365.html#L1898'>worker</a>           1898 workqueue.c    	list_del(&amp;worker-&gt;node);</span>
<span class='curline'><a href='../S/365.html#L1899'>worker</a>           1899 workqueue.c    	worker-&gt;pool = NULL;</span>
<span class='curline'><a href='../S/365.html#L1906'>worker</a>           1906 workqueue.c    	worker-&gt;flags &amp;= ~(WORKER_UNBOUND | WORKER_REBOUND);</span>
<span class='curline'><a href='../S/365.html#L1924'>worker</a>           1924 workqueue.c    static struct worker *create_worker(struct worker_pool *pool)</span>
<span class='curline'><a href='../S/365.html#L1926'>worker</a>           1926 workqueue.c    	struct worker *worker = NULL;</span>
<span class='curline'><a href='../S/365.html#L1935'>worker</a>           1935 workqueue.c    	worker = alloc_worker(pool-&gt;node);</span>
<span class='curline'><a href='../S/365.html#L1936'>worker</a>           1936 workqueue.c    	if (!worker)</span>
<span class='curline'><a href='../S/365.html#L1939'>worker</a>           1939 workqueue.c    	worker-&gt;id = id;</span>
<span class='curline'><a href='../S/365.html#L1947'>worker</a>           1947 workqueue.c    	worker-&gt;task = kthread_create_on_node(worker_thread, worker, pool-&gt;node,</span>
<span class='curline'><a href='../S/365.html#L1949'>worker</a>           1949 workqueue.c    	if (IS_ERR(worker-&gt;task))</span>
<span class='curline'><a href='../S/365.html#L1952'>worker</a>           1952 workqueue.c    	trace_android_vh_create_worker(worker, pool-&gt;attrs);</span>
<span class='curline'><a href='../S/365.html#L1953'>worker</a>           1953 workqueue.c    	set_user_nice(worker-&gt;task, pool-&gt;attrs-&gt;nice);</span>
<span class='curline'><a href='../S/365.html#L1954'>worker</a>           1954 workqueue.c    	kthread_bind_mask(worker-&gt;task, pool-&gt;attrs-&gt;cpumask);</span>
<span class='curline'><a href='../S/365.html#L1957'>worker</a>           1957 workqueue.c    	worker_attach_to_pool(worker, pool);</span>
<span class='curline'><a href='../S/365.html#L1961'>worker</a>           1961 workqueue.c    	worker-&gt;pool-&gt;nr_workers++;</span>
<span class='curline'><a href='../S/365.html#L1962'>worker</a>           1962 workqueue.c    	worker_enter_idle(worker);</span>
<span class='curline'><a href='../S/365.html#L1963'>worker</a>           1963 workqueue.c    	wake_up_process(worker-&gt;task);</span>
<span class='curline'><a href='../S/365.html#L1966'>worker</a>           1966 workqueue.c    	return worker;</span>
<span class='curline'><a href='../S/365.html#L1971'>worker</a>           1971 workqueue.c    	kfree(worker);</span>
<span class='curline'><a href='../S/365.html#L1985'>worker</a>           1985 workqueue.c    static void destroy_worker(struct worker *worker)</span>
<span class='curline'><a href='../S/365.html#L1987'>worker</a>           1987 workqueue.c    	struct worker_pool *pool = worker-&gt;pool;</span>
<span class='curline'><a href='../S/365.html#L1992'>worker</a>           1992 workqueue.c    	if (WARN_ON(worker-&gt;current_work) ||</span>
<span class='curline'><a href='../S/365.html#L1993'>worker</a>           1993 workqueue.c    	    WARN_ON(!list_empty(&amp;worker-&gt;scheduled)) ||</span>
<span class='curline'><a href='../S/365.html#L1994'>worker</a>           1994 workqueue.c    	    WARN_ON(!(worker-&gt;flags &amp; WORKER_IDLE)))</span>
<span class='curline'><a href='../S/365.html#L2000'>worker</a>           2000 workqueue.c    	list_del_init(&amp;worker-&gt;entry);</span>
<span class='curline'><a href='../S/365.html#L2001'>worker</a>           2001 workqueue.c    	worker-&gt;flags |= WORKER_DIE;</span>
<span class='curline'><a href='../S/365.html#L2002'>worker</a>           2002 workqueue.c    	wake_up_process(worker-&gt;task);</span>
<span class='curline'><a href='../S/365.html#L2012'>worker</a>           2012 workqueue.c    		struct worker *worker;</span>
<span class='curline'><a href='../S/365.html#L2016'>worker</a>           2016 workqueue.c    		worker = list_entry(pool-&gt;idle_list.prev, struct worker, entry);</span>
<span class='curline'><a href='../S/365.html#L2017'>worker</a>           2017 workqueue.c    		expires = worker-&gt;last_active + IDLE_WORKER_TIMEOUT;</span>
<span class='curline'><a href='../S/365.html#L2024'>worker</a>           2024 workqueue.c    		destroy_worker(worker);</span>
<span class='curline'><a href='../S/365.html#L2149'>worker</a>           2149 workqueue.c    static bool manage_workers(struct worker *worker)</span>
<span class='curline'><a href='../S/365.html#L2151'>worker</a>           2151 workqueue.c    	struct worker_pool *pool = worker-&gt;pool;</span>
<span class='curline'><a href='../S/365.html#L2157'>worker</a>           2157 workqueue.c    	pool-&gt;manager = worker;</span>
<span class='curline'><a href='../S/365.html#L2181'>worker</a>           2181 workqueue.c    static void process_one_work(struct worker *worker, struct work_struct *work)</span>
<span class='curline'><a href='../S/365.html#L2186'>worker</a>           2186 workqueue.c    	struct worker_pool *pool = worker-&gt;pool;</span>
<span class='curline'><a href='../S/365.html#L2189'>worker</a>           2189 workqueue.c    	struct worker *collision;</span>
<span class='curline'><a href='../S/365.html#L2220'>worker</a>           2220 workqueue.c    	hash_add(pool-&gt;busy_hash, &amp;worker-&gt;hentry, (unsigned long)work);</span>
<span class='curline'><a href='../S/365.html#L2221'>worker</a>           2221 workqueue.c    	worker-&gt;current_work = work;</span>
<span class='curline'><a href='../S/365.html#L2222'>worker</a>           2222 workqueue.c    	worker-&gt;current_func = work-&gt;func;</span>
<span class='curline'><a href='../S/365.html#L2223'>worker</a>           2223 workqueue.c    	worker-&gt;current_pwq = pwq;</span>
<span class='curline'><a href='../S/365.html#L2230'>worker</a>           2230 workqueue.c    	strscpy(worker-&gt;desc, pwq-&gt;wq-&gt;name, WORKER_DESC_LEN);</span>
<span class='curline'><a href='../S/365.html#L2241'>worker</a>           2241 workqueue.c    		worker_set_flags(worker, WORKER_CPU_INTENSIVE);</span>
<span class='curline'><a href='../S/365.html#L2288'>worker</a>           2288 workqueue.c    	worker-&gt;current_func(work);</span>
<span class='curline'><a href='../S/365.html#L2293'>worker</a>           2293 workqueue.c    	trace_workqueue_execute_end(work, worker-&gt;current_func);</span>
<span class='curline'><a href='../S/365.html#L2301'>worker</a>           2301 workqueue.c    		       worker-&gt;current_func);</span>
<span class='curline'><a href='../S/365.html#L2320'>worker</a>           2320 workqueue.c    		worker_clr_flags(worker, WORKER_CPU_INTENSIVE);</span>
<span class='curline'><a href='../S/365.html#L2323'>worker</a>           2323 workqueue.c    	worker-&gt;last_func = worker-&gt;current_func;</span>
<span class='curline'><a href='../S/365.html#L2326'>worker</a>           2326 workqueue.c    	hash_del(&amp;worker-&gt;hentry);</span>
<span class='curline'><a href='../S/365.html#L2327'>worker</a>           2327 workqueue.c    	worker-&gt;current_work = NULL;</span>
<span class='curline'><a href='../S/365.html#L2328'>worker</a>           2328 workqueue.c    	worker-&gt;current_func = NULL;</span>
<span class='curline'><a href='../S/365.html#L2329'>worker</a>           2329 workqueue.c    	worker-&gt;current_pwq = NULL;</span>
<span class='curline'><a href='../S/365.html#L2345'>worker</a>           2345 workqueue.c    static void process_scheduled_works(struct worker *worker)</span>
<span class='curline'><a href='../S/365.html#L2347'>worker</a>           2347 workqueue.c    	while (!list_empty(&amp;worker-&gt;scheduled)) {</span>
<span class='curline'><a href='../S/365.html#L2348'>worker</a>           2348 workqueue.c    		struct work_struct *work = list_first_entry(&amp;worker-&gt;scheduled,</span>
<span class='curline'><a href='../S/365.html#L2350'>worker</a>           2350 workqueue.c    		process_one_work(worker, work);</span>
<span class='curline'><a href='../S/365.html#L2378'>worker</a>           2378 workqueue.c    	struct worker *worker = __worker;</span>
<span class='curline'><a href='../S/365.html#L2379'>worker</a>           2379 workqueue.c    	struct worker_pool *pool = worker-&gt;pool;</span>
<span class='curline'><a href='../S/365.html#L2387'>worker</a>           2387 workqueue.c    	if (unlikely(worker-&gt;flags &amp; WORKER_DIE)) {</span>
<span class='curline'><a href='../S/365.html#L2389'>worker</a>           2389 workqueue.c    		WARN_ON_ONCE(!list_empty(&amp;worker-&gt;entry));</span>
<span class='curline'><a href='../S/365.html#L2392'>worker</a>           2392 workqueue.c    		set_task_comm(worker-&gt;task, "kworker/dying");</span>
<span class='curline'><a href='../S/365.html#L2393'>worker</a>           2393 workqueue.c    		ida_simple_remove(&amp;pool-&gt;worker_ida, worker-&gt;id);</span>
<span class='curline'><a href='../S/365.html#L2394'>worker</a>           2394 workqueue.c    		worker_detach_from_pool(worker);</span>
<span class='curline'><a href='../S/365.html#L2395'>worker</a>           2395 workqueue.c    		kfree(worker);</span>
<span class='curline'><a href='../S/365.html#L2399'>worker</a>           2399 workqueue.c    	worker_leave_idle(worker);</span>
<span class='curline'><a href='../S/365.html#L2406'>worker</a>           2406 workqueue.c    	if (unlikely(!may_start_working(pool)) &amp;&amp; manage_workers(worker))</span>
<span class='curline'><a href='../S/365.html#L2414'>worker</a>           2414 workqueue.c    	WARN_ON_ONCE(!list_empty(&amp;worker-&gt;scheduled));</span>
<span class='curline'><a href='../S/365.html#L2423'>worker</a>           2423 workqueue.c    	worker_clr_flags(worker, WORKER_PREP | WORKER_REBOUND);</span>
<span class='curline'><a href='../S/365.html#L2434'>worker</a>           2434 workqueue.c    			process_one_work(worker, work);</span>
<span class='curline'><a href='../S/365.html#L2435'>worker</a>           2435 workqueue.c    			if (unlikely(!list_empty(&amp;worker-&gt;scheduled)))</span>
<span class='curline'><a href='../S/365.html#L2436'>worker</a>           2436 workqueue.c    				process_scheduled_works(worker);</span>
<span class='curline'><a href='../S/365.html#L2438'>worker</a>           2438 workqueue.c    			move_linked_works(work, &amp;worker-&gt;scheduled, NULL);</span>
<span class='curline'><a href='../S/365.html#L2439'>worker</a>           2439 workqueue.c    			process_scheduled_works(worker);</span>
<span class='curline'><a href='../S/365.html#L2443'>worker</a>           2443 workqueue.c    	worker_set_flags(worker, WORKER_PREP);</span>
<span class='curline'><a href='../S/365.html#L2452'>worker</a>           2452 workqueue.c    	worker_enter_idle(worker);</span>
<span class='curline'><a href='../S/365.html#L2482'>worker</a>           2482 workqueue.c    	struct worker *rescuer = __rescuer;</span>
<span class='curline'><a href='../S/365.html#L2616'>worker</a>           2616 workqueue.c    	struct worker *worker;</span>
<span class='curline'><a href='../S/365.html#L2621'>worker</a>           2621 workqueue.c    	worker = current_wq_worker();</span>
<span class='curline'><a href='../S/365.html#L2626'>worker</a>           2626 workqueue.c    	WARN_ONCE(worker &amp;&amp; ((worker-&gt;current_pwq-&gt;wq-&gt;flags &amp;</span>
<span class='curline'><a href='../S/365.html#L2629'>worker</a>           2629 workqueue.c    		  worker-&gt;current_pwq-&gt;wq-&gt;name, worker-&gt;current_func,</span>
<span class='curline'><a href='../S/365.html#L2671'>worker</a>           2671 workqueue.c    			      struct work_struct *target, struct worker *worker)</span>
<span class='curline'><a href='../S/365.html#L2693'>worker</a>           2693 workqueue.c    	if (worker)</span>
<span class='curline'><a href='../S/365.html#L2694'>worker</a>           2694 workqueue.c    		head = worker-&gt;scheduled.next;</span>
<span class='curline'><a href='../S/365.html#L2996'>worker</a>           2996 workqueue.c    	struct worker *worker = NULL;</span>
<span class='curline'><a href='../S/365.html#L3016'>worker</a>           3016 workqueue.c    		worker = find_worker_executing_work(pool, work);</span>
<span class='curline'><a href='../S/365.html#L3017'>worker</a>           3017 workqueue.c    		if (!worker)</span>
<span class='curline'><a href='../S/365.html#L3019'>worker</a>           3019 workqueue.c    		pwq = worker-&gt;current_pwq;</span>
<span class='curline'><a href='../S/365.html#L3024'>worker</a>           3024 workqueue.c    	insert_wq_barrier(pwq, barr, work, worker);</span>
<span class='curline'><a href='../S/365.html#L3552'>worker</a>           3552 workqueue.c    	struct worker *worker;</span>
<span class='curline'><a href='../S/365.html#L3580'>worker</a>           3580 workqueue.c    	while ((worker = first_idle_worker(pool)))</span>
<span class='curline'><a href='../S/365.html#L3581'>worker</a>           3581 workqueue.c    		destroy_worker(worker);</span>
<span class='curline'><a href='../S/365.html#L4238'>worker</a>           4238 workqueue.c    	struct worker *rescuer;</span>
<span class='curline'><a href='../S/365.html#L4399'>worker</a>           4399 workqueue.c    		struct worker *rescuer = wq-&gt;rescuer;</span>
<span class='curline'><a href='../S/365.html#L4512'>worker</a>           4512 workqueue.c    	struct worker *worker = current_wq_worker();</span>
<span class='curline'><a href='../S/365.html#L4514'>worker</a>           4514 workqueue.c    	return worker ? worker-&gt;current_work : NULL;</span>
<span class='curline'><a href='../S/365.html#L4528'>worker</a>           4528 workqueue.c    	struct worker *worker = current_wq_worker();</span>
<span class='curline'><a href='../S/365.html#L4530'>worker</a>           4530 workqueue.c    	return worker &amp;&amp; worker-&gt;rescue_wq;</span>
<span class='curline'><a href='../S/365.html#L4621'>worker</a>           4621 workqueue.c    	struct worker *worker = current_wq_worker();</span>
<span class='curline'><a href='../S/365.html#L4624'>worker</a>           4624 workqueue.c    	if (worker) {</span>
<span class='curline'><a href='../S/365.html#L4626'>worker</a>           4626 workqueue.c    		vsnprintf(worker-&gt;desc, sizeof(worker-&gt;desc), fmt, args);</span>
<span class='curline'><a href='../S/365.html#L4652'>worker</a>           4652 workqueue.c    	struct worker *worker;</span>
<span class='curline'><a href='../S/365.html#L4661'>worker</a>           4661 workqueue.c    	worker = kthread_probe_data(task);</span>
<span class='curline'><a href='../S/365.html#L4667'>worker</a>           4667 workqueue.c    	copy_from_kernel_nofault(&amp;fn, &amp;worker-&gt;current_func, sizeof(fn));</span>
<span class='curline'><a href='../S/365.html#L4668'>worker</a>           4668 workqueue.c    	copy_from_kernel_nofault(&amp;pwq, &amp;worker-&gt;current_pwq, sizeof(pwq));</span>
<span class='curline'><a href='../S/365.html#L4671'>worker</a>           4671 workqueue.c    	copy_from_kernel_nofault(desc, worker-&gt;desc, sizeof(desc) - 1);</span>
<span class='curline'><a href='../S/365.html#L4707'>worker</a>           4707 workqueue.c    	struct worker *worker;</span>
<span class='curline'><a href='../S/365.html#L4718'>worker</a>           4718 workqueue.c    	hash_for_each(pool-&gt;busy_hash, bkt, worker, hentry) {</span>
<span class='curline'><a href='../S/365.html#L4719'>worker</a>           4719 workqueue.c    		if (worker-&gt;current_pwq == pwq) {</span>
<span class='curline'><a href='../S/365.html#L4728'>worker</a>           4728 workqueue.c    		hash_for_each(pool-&gt;busy_hash, bkt, worker, hentry) {</span>
<span class='curline'><a href='../S/365.html#L4729'>worker</a>           4729 workqueue.c    			if (worker-&gt;current_pwq != pwq)</span>
<span class='curline'><a href='../S/365.html#L4733'>worker</a>           4733 workqueue.c    				task_pid_nr(worker-&gt;task),</span>
<span class='curline'><a href='../S/365.html#L4734'>worker</a>           4734 workqueue.c    				worker-&gt;rescue_wq ? "(RESCUER)" : "",</span>
<span class='curline'><a href='../S/365.html#L4735'>worker</a>           4735 workqueue.c    				worker-&gt;current_func);</span>
<span class='curline'><a href='../S/365.html#L4736'>worker</a>           4736 workqueue.c    			list_for_each_entry(work, &amp;worker-&gt;scheduled, entry)</span>
<span class='curline'><a href='../S/365.html#L4822'>worker</a>           4822 workqueue.c    		struct worker *worker;</span>
<span class='curline'><a href='../S/365.html#L4837'>worker</a>           4837 workqueue.c    		list_for_each_entry(worker, &amp;pool-&gt;idle_list, entry) {</span>
<span class='curline'><a href='../S/365.html#L4839'>worker</a>           4839 workqueue.c    				task_pid_nr(worker-&gt;task));</span>
<span class='curline'><a href='../S/365.html#L4870'>worker</a>           4870 workqueue.c    		struct worker *worker = kthread_data(task);</span>
<span class='curline'><a href='../S/365.html#L4871'>worker</a>           4871 workqueue.c    		struct worker_pool *pool = worker-&gt;pool;</span>
<span class='curline'><a href='../S/365.html#L4880'>worker</a>           4880 workqueue.c    			if (worker-&gt;desc[0] != '\0') {</span>
<span class='curline'><a href='../S/365.html#L4881'>worker</a>           4881 workqueue.c    				if (worker-&gt;current_work)</span>
<span class='curline'><a href='../S/365.html#L4883'>worker</a>           4883 workqueue.c    						  worker-&gt;desc);</span>
<span class='curline'><a href='../S/365.html#L4886'>worker</a>           4886 workqueue.c    						  worker-&gt;desc);</span>
<span class='curline'><a href='../S/365.html#L4915'>worker</a>           4915 workqueue.c    	struct worker *worker;</span>
<span class='curline'><a href='../S/365.html#L4928'>worker</a>           4928 workqueue.c    		for_each_pool_worker(worker, pool)</span>
<span class='curline'><a href='../S/365.html#L4929'>worker</a>           4929 workqueue.c    			worker-&gt;flags |= WORKER_UNBOUND;</span>
<span class='curline'><a href='../S/365.html#L4973'>worker</a>           4973 workqueue.c    	struct worker *worker;</span>
<span class='curline'><a href='../S/365.html#L4984'>worker</a>           4984 workqueue.c    	for_each_pool_worker(worker, pool)</span>
<span class='curline'><a href='../S/365.html#L4985'>worker</a>           4985 workqueue.c    		WARN_ON_ONCE(set_cpus_allowed_ptr(worker-&gt;task,</span>
<span class='curline'><a href='../S/365.html#L4992'>worker</a>           4992 workqueue.c    	for_each_pool_worker(worker, pool) {</span>
<span class='curline'><a href='../S/365.html#L4993'>worker</a>           4993 workqueue.c    		unsigned int worker_flags = worker-&gt;flags;</span>
<span class='curline'><a href='../S/365.html#L5004'>worker</a>           5004 workqueue.c    			wake_up_process(worker-&gt;task);</span>
<span class='curline'><a href='../S/365.html#L5024'>worker</a>           5024 workqueue.c    		WRITE_ONCE(worker-&gt;flags, worker_flags);</span>
<span class='curline'><a href='../S/365.html#L5043'>worker</a>           5043 workqueue.c    	struct worker *worker;</span>
<span class='curline'><a href='../S/365.html#L5054'>worker</a>           5054 workqueue.c    	for_each_pool_worker(worker, pool)</span>
<span class='curline'><a href='../S/365.html#L5055'>worker</a>           5055 workqueue.c    		WARN_ON_ONCE(set_cpus_allowed_ptr(worker-&gt;task, &amp;cpumask) &lt; 0);</span>
<span class='curline'><a href='../S/191.html#L65'>worker</a>             65 workqueue_internal.h static inline struct worker *current_wq_worker(void)</span>
</pre>
</body>
</html>
