<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>rq</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.6.4' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/212.html#L284'>rq</a>                284 livepatch/transition.c 	struct rq *rq;</span>
<span class='curline'><a href='../S/212.html#L307'>rq</a>                307 livepatch/transition.c 	rq = task_rq_lock(task, &amp;flags);</span>
<span class='curline'><a href='../S/212.html#L309'>rq</a>                309 livepatch/transition.c 	if (task_running(rq, task) &amp;&amp; task != current) {</span>
<span class='curline'><a href='../S/212.html#L326'>rq</a>                326 livepatch/transition.c 	task_rq_unlock(rq, task, &amp;flags);</span>
<span class='curline'><a href='../S/441.html#L56'>rq</a>                 56 sched/core.c   DEFINE_PER_CPU_SHARED_ALIGNED(struct rq, runqueues);</span>
<span class='curline'><a href='../S/441.html#L193'>rq</a>                193 sched/core.c   struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)</span>
<span class='curline'><a href='../S/441.html#L194'>rq</a>                194 sched/core.c   	__acquires(rq-&gt;lock)</span>
<span class='curline'><a href='../S/441.html#L196'>rq</a>                196 sched/core.c   	struct rq *rq;</span>
<span class='curline'><a href='../S/441.html#L201'>rq</a>                201 sched/core.c   		rq = task_rq(p);</span>
<span class='curline'><a href='../S/441.html#L202'>rq</a>                202 sched/core.c   		raw_spin_lock(&amp;rq-&gt;lock);</span>
<span class='curline'><a href='../S/441.html#L203'>rq</a>                203 sched/core.c   		if (likely(rq == task_rq(p) &amp;&amp; !task_on_rq_migrating(p))) {</span>
<span class='curline'><a href='../S/441.html#L204'>rq</a>                204 sched/core.c   			rq_pin_lock(rq, rf);</span>
<span class='curline'><a href='../S/441.html#L205'>rq</a>                205 sched/core.c   			return rq;</span>
<span class='curline'><a href='../S/441.html#L207'>rq</a>                207 sched/core.c   		raw_spin_unlock(&amp;rq-&gt;lock);</span>
<span class='curline'><a href='../S/441.html#L218'>rq</a>                218 sched/core.c   struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)</span>
<span class='curline'><a href='../S/441.html#L220'>rq</a>                220 sched/core.c   	__acquires(rq-&gt;lock)</span>
<span class='curline'><a href='../S/441.html#L222'>rq</a>                222 sched/core.c   	struct rq *rq;</span>
<span class='curline'><a href='../S/441.html#L226'>rq</a>                226 sched/core.c   		rq = task_rq(p);</span>
<span class='curline'><a href='../S/441.html#L227'>rq</a>                227 sched/core.c   		raw_spin_lock(&amp;rq-&gt;lock);</span>
<span class='curline'><a href='../S/441.html#L245'>rq</a>                245 sched/core.c   		if (likely(rq == task_rq(p) &amp;&amp; !task_on_rq_migrating(p))) {</span>
<span class='curline'><a href='../S/441.html#L246'>rq</a>                246 sched/core.c   			rq_pin_lock(rq, rf);</span>
<span class='curline'><a href='../S/441.html#L247'>rq</a>                247 sched/core.c   			return rq;</span>
<span class='curline'><a href='../S/441.html#L249'>rq</a>                249 sched/core.c   		raw_spin_unlock(&amp;rq-&gt;lock);</span>
<span class='curline'><a href='../S/441.html#L262'>rq</a>                262 sched/core.c   static void update_rq_clock_task(struct rq *rq, s64 delta)</span>
<span class='curline'><a href='../S/441.html#L271'>rq</a>                271 sched/core.c   	irq_delta = irq_time_read(cpu_of(rq)) - rq-&gt;prev_irq_time;</span>
<span class='curline'><a href='../S/441.html#L291'>rq</a>                291 sched/core.c   	rq-&gt;prev_irq_time += irq_delta;</span>
<span class='curline'><a href='../S/441.html#L296'>rq</a>                296 sched/core.c   		steal = paravirt_steal_clock(cpu_of(rq));</span>
<span class='curline'><a href='../S/441.html#L297'>rq</a>                297 sched/core.c   		steal -= rq-&gt;prev_steal_time_rq;</span>
<span class='curline'><a href='../S/441.html#L302'>rq</a>                302 sched/core.c   		rq-&gt;prev_steal_time_rq += steal;</span>
<span class='curline'><a href='../S/441.html#L307'>rq</a>                307 sched/core.c   	rq-&gt;clock_task += delta;</span>
<span class='curline'><a href='../S/441.html#L311'>rq</a>                311 sched/core.c   		update_irq_load_avg(rq, irq_delta + steal);</span>
<span class='curline'><a href='../S/441.html#L313'>rq</a>                313 sched/core.c   	update_rq_clock_pelt(rq, delta);</span>
<span class='curline'><a href='../S/441.html#L316'>rq</a>                316 sched/core.c   void update_rq_clock(struct rq *rq)</span>
<span class='curline'><a href='../S/441.html#L320'>rq</a>                320 sched/core.c   	lockdep_assert_held(&amp;rq-&gt;lock);</span>
<span class='curline'><a href='../S/441.html#L322'>rq</a>                322 sched/core.c   	if (rq-&gt;clock_update_flags &amp; RQCF_ACT_SKIP)</span>
<span class='curline'><a href='../S/441.html#L327'>rq</a>                327 sched/core.c   		SCHED_WARN_ON(rq-&gt;clock_update_flags &amp; RQCF_UPDATED);</span>
<span class='curline'><a href='../S/441.html#L328'>rq</a>                328 sched/core.c   	rq-&gt;clock_update_flags |= RQCF_UPDATED;</span>
<span class='curline'><a href='../S/441.html#L331'>rq</a>                331 sched/core.c   	delta = sched_clock_cpu(cpu_of(rq)) - rq-&gt;clock;</span>
<span class='curline'><a href='../S/441.html#L334'>rq</a>                334 sched/core.c   	rq-&gt;clock += delta;</span>
<span class='curline'><a href='../S/441.html#L335'>rq</a>                335 sched/core.c   	update_rq_clock_task(rq, delta);</span>
<span class='curline'><a href='../S/441.html#L340'>rq</a>                340 sched/core.c   rq_csd_init(struct rq *rq, struct __call_single_data *csd, smp_call_func_t func)</span>
<span class='curline'><a href='../S/441.html#L344'>rq</a>                344 sched/core.c   	csd-&gt;info = rq;</span>
<span class='curline'><a href='../S/441.html#L352'>rq</a>                352 sched/core.c   static void hrtick_clear(struct rq *rq)</span>
<span class='curline'><a href='../S/441.html#L354'>rq</a>                354 sched/core.c   	if (hrtimer_active(&amp;rq-&gt;hrtick_timer))</span>
<span class='curline'><a href='../S/441.html#L355'>rq</a>                355 sched/core.c   		hrtimer_cancel(&amp;rq-&gt;hrtick_timer);</span>
<span class='curline'><a href='../S/441.html#L364'>rq</a>                364 sched/core.c   	struct rq *rq = container_of(timer, struct rq, hrtick_timer);</span>
<span class='curline'><a href='../S/441.html#L367'>rq</a>                367 sched/core.c   	WARN_ON_ONCE(cpu_of(rq) != smp_processor_id());</span>
<span class='curline'><a href='../S/441.html#L369'>rq</a>                369 sched/core.c   	rq_lock(rq, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L370'>rq</a>                370 sched/core.c   	update_rq_clock(rq);</span>
<span class='curline'><a href='../S/441.html#L371'>rq</a>                371 sched/core.c   	rq-&gt;curr-&gt;sched_class-&gt;task_tick(rq, rq-&gt;curr, 1);</span>
<span class='curline'><a href='../S/441.html#L372'>rq</a>                372 sched/core.c   	rq_unlock(rq, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L379'>rq</a>                379 sched/core.c   static void __hrtick_restart(struct rq *rq)</span>
<span class='curline'><a href='../S/441.html#L381'>rq</a>                381 sched/core.c   	struct hrtimer *timer = &amp;rq-&gt;hrtick_timer;</span>
<span class='curline'><a href='../S/441.html#L382'>rq</a>                382 sched/core.c   	ktime_t time = rq-&gt;hrtick_time;</span>
<span class='curline'><a href='../S/441.html#L392'>rq</a>                392 sched/core.c   	struct rq *rq = arg;</span>
<span class='curline'><a href='../S/441.html#L395'>rq</a>                395 sched/core.c   	rq_lock(rq, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L396'>rq</a>                396 sched/core.c   	__hrtick_restart(rq);</span>
<span class='curline'><a href='../S/441.html#L397'>rq</a>                397 sched/core.c   	rq_unlock(rq, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L405'>rq</a>                405 sched/core.c   void hrtick_start(struct rq *rq, u64 delay)</span>
<span class='curline'><a href='../S/441.html#L407'>rq</a>                407 sched/core.c   	struct hrtimer *timer = &amp;rq-&gt;hrtick_timer;</span>
<span class='curline'><a href='../S/441.html#L415'>rq</a>                415 sched/core.c   	rq-&gt;hrtick_time = ktime_add_ns(timer-&gt;base-&gt;get_time(), delta);</span>
<span class='curline'><a href='../S/441.html#L417'>rq</a>                417 sched/core.c   	if (rq == this_rq())</span>
<span class='curline'><a href='../S/441.html#L418'>rq</a>                418 sched/core.c   		__hrtick_restart(rq);</span>
<span class='curline'><a href='../S/441.html#L420'>rq</a>                420 sched/core.c   		smp_call_function_single_async(cpu_of(rq), &amp;rq-&gt;hrtick_csd);</span>
<span class='curline'><a href='../S/441.html#L429'>rq</a>                429 sched/core.c   void hrtick_start(struct rq *rq, u64 delay)</span>
<span class='curline'><a href='../S/441.html#L436'>rq</a>                436 sched/core.c   	hrtimer_start(&amp;rq-&gt;hrtick_timer, ns_to_ktime(delay),</span>
<span class='curline'><a href='../S/441.html#L442'>rq</a>                442 sched/core.c   static void hrtick_rq_init(struct rq *rq)</span>
<span class='curline'><a href='../S/441.html#L445'>rq</a>                445 sched/core.c   	rq_csd_init(rq, &amp;rq-&gt;hrtick_csd, __hrtick_start);</span>
<span class='curline'><a href='../S/441.html#L447'>rq</a>                447 sched/core.c   	hrtimer_init(&amp;rq-&gt;hrtick_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_HARD);</span>
<span class='curline'><a href='../S/441.html#L448'>rq</a>                448 sched/core.c   	rq-&gt;hrtick_timer.function = hrtick;</span>
<span class='curline'><a href='../S/441.html#L451'>rq</a>                451 sched/core.c   static inline void hrtick_clear(struct rq *rq)</span>
<span class='curline'><a href='../S/441.html#L455'>rq</a>                455 sched/core.c   static inline void hrtick_rq_init(struct rq *rq)</span>
<span class='curline'><a href='../S/441.html#L626'>rq</a>                626 sched/core.c   void resched_curr(struct rq *rq)</span>
<span class='curline'><a href='../S/441.html#L628'>rq</a>                628 sched/core.c   	struct task_struct *curr = rq-&gt;curr;</span>
<span class='curline'><a href='../S/441.html#L631'>rq</a>                631 sched/core.c   	lockdep_assert_held(&amp;rq-&gt;lock);</span>
<span class='curline'><a href='../S/441.html#L636'>rq</a>                636 sched/core.c   	cpu = cpu_of(rq);</span>
<span class='curline'><a href='../S/441.html#L653'>rq</a>                653 sched/core.c   	struct rq *rq = cpu_rq(cpu);</span>
<span class='curline'><a href='../S/441.html#L656'>rq</a>                656 sched/core.c   	raw_spin_lock_irqsave(&amp;rq-&gt;lock, flags);</span>
<span class='curline'><a href='../S/441.html#L658'>rq</a>                658 sched/core.c   		resched_curr(rq);</span>
<span class='curline'><a href='../S/441.html#L659'>rq</a>                659 sched/core.c   	raw_spin_unlock_irqrestore(&amp;rq-&gt;lock, flags);</span>
<span class='curline'><a href='../S/441.html#L734'>rq</a>                734 sched/core.c   	struct rq *rq = cpu_rq(cpu);</span>
<span class='curline'><a href='../S/441.html#L739'>rq</a>                739 sched/core.c   	if (set_nr_and_not_polling(rq-&gt;idle))</span>
<span class='curline'><a href='../S/441.html#L778'>rq</a>                778 sched/core.c   	struct rq *rq = info;</span>
<span class='curline'><a href='../S/441.html#L779'>rq</a>                779 sched/core.c   	int cpu = cpu_of(rq);</span>
<span class='curline'><a href='../S/441.html#L788'>rq</a>                788 sched/core.c   	rq-&gt;idle_balance = idle_cpu(cpu);</span>
<span class='curline'><a href='../S/441.html#L789'>rq</a>                789 sched/core.c   	if (rq-&gt;idle_balance &amp;&amp; !need_resched()) {</span>
<span class='curline'><a href='../S/441.html#L790'>rq</a>                790 sched/core.c   		rq-&gt;nohz_idle_balance = flags;</span>
<span class='curline'><a href='../S/441.html#L798'>rq</a>                798 sched/core.c   bool sched_can_stop_tick(struct rq *rq)</span>
<span class='curline'><a href='../S/441.html#L803'>rq</a>                803 sched/core.c   	if (rq-&gt;dl.dl_nr_running)</span>
<span class='curline'><a href='../S/441.html#L810'>rq</a>                810 sched/core.c   	if (rq-&gt;rt.rr_nr_running) {</span>
<span class='curline'><a href='../S/441.html#L811'>rq</a>                811 sched/core.c   		if (rq-&gt;rt.rr_nr_running == 1)</span>
<span class='curline'><a href='../S/441.html#L821'>rq</a>                821 sched/core.c   	fifo_nr_running = rq-&gt;rt.rt_nr_running - rq-&gt;rt.rr_nr_running;</span>
<span class='curline'><a href='../S/441.html#L830'>rq</a>                830 sched/core.c   	if (rq-&gt;nr_running &gt; 1)</span>
<span class='curline'><a href='../S/441.html#L996'>rq</a>                996 sched/core.c   uclamp_idle_value(struct rq *rq, enum uclamp_id clamp_id,</span>
<span class='curline'><a href='../S/441.html#L1005'>rq</a>               1005 sched/core.c   		rq-&gt;uclamp_flags |= UCLAMP_FLAG_IDLE;</span>
<span class='curline'><a href='../S/441.html#L1012'>rq</a>               1012 sched/core.c   static inline void uclamp_idle_reset(struct rq *rq, enum uclamp_id clamp_id,</span>
<span class='curline'><a href='../S/441.html#L1016'>rq</a>               1016 sched/core.c   	if (!(rq-&gt;uclamp_flags &amp; UCLAMP_FLAG_IDLE))</span>
<span class='curline'><a href='../S/441.html#L1019'>rq</a>               1019 sched/core.c   	WRITE_ONCE(rq-&gt;uclamp[clamp_id].value, clamp_value);</span>
<span class='curline'><a href='../S/441.html#L1023'>rq</a>               1023 sched/core.c   unsigned int uclamp_rq_max_value(struct rq *rq, enum uclamp_id clamp_id,</span>
<span class='curline'><a href='../S/441.html#L1026'>rq</a>               1026 sched/core.c   	struct uclamp_bucket *bucket = rq-&gt;uclamp[clamp_id].bucket;</span>
<span class='curline'><a href='../S/441.html#L1040'>rq</a>               1040 sched/core.c   	return uclamp_idle_value(rq, clamp_id, clamp_value);</span>
<span class='curline'><a href='../S/441.html#L1063'>rq</a>               1063 sched/core.c   	struct rq *rq;</span>
<span class='curline'><a href='../S/441.html#L1069'>rq</a>               1069 sched/core.c   	rq = task_rq_lock(p, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L1071'>rq</a>               1071 sched/core.c   	task_rq_unlock(rq, p, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L1176'>rq</a>               1176 sched/core.c   static inline void uclamp_rq_inc_id(struct rq *rq, struct task_struct *p,</span>
<span class='curline'><a href='../S/441.html#L1179'>rq</a>               1179 sched/core.c   	struct uclamp_rq *uc_rq = &amp;rq-&gt;uclamp[clamp_id];</span>
<span class='curline'><a href='../S/441.html#L1183'>rq</a>               1183 sched/core.c   	lockdep_assert_held(&amp;rq-&gt;lock);</span>
<span class='curline'><a href='../S/441.html#L1192'>rq</a>               1192 sched/core.c   	uclamp_idle_reset(rq, clamp_id, uc_se-&gt;value);</span>
<span class='curline'><a href='../S/441.html#L1214'>rq</a>               1214 sched/core.c   static inline void uclamp_rq_dec_id(struct rq *rq, struct task_struct *p,</span>
<span class='curline'><a href='../S/441.html#L1217'>rq</a>               1217 sched/core.c   	struct uclamp_rq *uc_rq = &amp;rq-&gt;uclamp[clamp_id];</span>
<span class='curline'><a href='../S/441.html#L1223'>rq</a>               1223 sched/core.c   	lockdep_assert_held(&amp;rq-&gt;lock);</span>
<span class='curline'><a href='../S/441.html#L1275'>rq</a>               1275 sched/core.c   		bkt_clamp = uclamp_rq_max_value(rq, clamp_id, uc_se-&gt;value);</span>
<span class='curline'><a href='../S/441.html#L1280'>rq</a>               1280 sched/core.c   static inline void uclamp_rq_inc(struct rq *rq, struct task_struct *p)</span>
<span class='curline'><a href='../S/441.html#L1297'>rq</a>               1297 sched/core.c   		uclamp_rq_inc_id(rq, p, clamp_id);</span>
<span class='curline'><a href='../S/441.html#L1300'>rq</a>               1300 sched/core.c   	if (rq-&gt;uclamp_flags &amp; UCLAMP_FLAG_IDLE)</span>
<span class='curline'><a href='../S/441.html#L1301'>rq</a>               1301 sched/core.c   		rq-&gt;uclamp_flags &amp;= ~UCLAMP_FLAG_IDLE;</span>
<span class='curline'><a href='../S/441.html#L1304'>rq</a>               1304 sched/core.c   static inline void uclamp_rq_dec(struct rq *rq, struct task_struct *p)</span>
<span class='curline'><a href='../S/441.html#L1321'>rq</a>               1321 sched/core.c   		uclamp_rq_dec_id(rq, p, clamp_id);</span>
<span class='curline'><a href='../S/441.html#L1328'>rq</a>               1328 sched/core.c   	struct rq *rq;</span>
<span class='curline'><a href='../S/441.html#L1338'>rq</a>               1338 sched/core.c   	rq = task_rq_lock(p, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L1347'>rq</a>               1347 sched/core.c   		uclamp_rq_dec_id(rq, p, clamp_id);</span>
<span class='curline'><a href='../S/441.html#L1348'>rq</a>               1348 sched/core.c   		uclamp_rq_inc_id(rq, p, clamp_id);</span>
<span class='curline'><a href='../S/441.html#L1351'>rq</a>               1351 sched/core.c   	task_rq_unlock(rq, p, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L1582'>rq</a>               1582 sched/core.c   static void __init init_uclamp_rq(struct rq *rq)</span>
<span class='curline'><a href='../S/441.html#L1585'>rq</a>               1585 sched/core.c   	struct uclamp_rq *uc_rq = rq-&gt;uclamp;</span>
<span class='curline'><a href='../S/441.html#L1593'>rq</a>               1593 sched/core.c   	rq-&gt;uclamp_flags = 0;</span>
<span class='curline'><a href='../S/441.html#L1622'>rq</a>               1622 sched/core.c   static inline void uclamp_rq_inc(struct rq *rq, struct task_struct *p) { }</span>
<span class='curline'><a href='../S/441.html#L1623'>rq</a>               1623 sched/core.c   static inline void uclamp_rq_dec(struct rq *rq, struct task_struct *p) { }</span>
<span class='curline'><a href='../S/441.html#L1636'>rq</a>               1636 sched/core.c   static inline void enqueue_task(struct rq *rq, struct task_struct *p, int flags)</span>
<span class='curline'><a href='../S/441.html#L1639'>rq</a>               1639 sched/core.c   		update_rq_clock(rq);</span>
<span class='curline'><a href='../S/441.html#L1642'>rq</a>               1642 sched/core.c   		sched_info_queued(rq, p);</span>
<span class='curline'><a href='../S/441.html#L1646'>rq</a>               1646 sched/core.c   	uclamp_rq_inc(rq, p);</span>
<span class='curline'><a href='../S/441.html#L1647'>rq</a>               1647 sched/core.c   	trace_android_rvh_enqueue_task(rq, p, flags);</span>
<span class='curline'><a href='../S/441.html#L1648'>rq</a>               1648 sched/core.c   	p-&gt;sched_class-&gt;enqueue_task(rq, p, flags);</span>
<span class='curline'><a href='../S/441.html#L1649'>rq</a>               1649 sched/core.c   	trace_android_rvh_after_enqueue_task(rq, p);</span>
<span class='curline'><a href='../S/441.html#L1652'>rq</a>               1652 sched/core.c   static inline void dequeue_task(struct rq *rq, struct task_struct *p, int flags)</span>
<span class='curline'><a href='../S/441.html#L1655'>rq</a>               1655 sched/core.c   		update_rq_clock(rq);</span>
<span class='curline'><a href='../S/441.html#L1658'>rq</a>               1658 sched/core.c   		sched_info_dequeued(rq, p);</span>
<span class='curline'><a href='../S/441.html#L1662'>rq</a>               1662 sched/core.c   	uclamp_rq_dec(rq, p);</span>
<span class='curline'><a href='../S/441.html#L1663'>rq</a>               1663 sched/core.c   	trace_android_rvh_dequeue_task(rq, p, flags);</span>
<span class='curline'><a href='../S/441.html#L1664'>rq</a>               1664 sched/core.c   	p-&gt;sched_class-&gt;dequeue_task(rq, p, flags);</span>
<span class='curline'><a href='../S/441.html#L1665'>rq</a>               1665 sched/core.c   	trace_android_rvh_after_dequeue_task(rq, p);</span>
<span class='curline'><a href='../S/441.html#L1668'>rq</a>               1668 sched/core.c   void activate_task(struct rq *rq, struct task_struct *p, int flags)</span>
<span class='curline'><a href='../S/441.html#L1670'>rq</a>               1670 sched/core.c   	enqueue_task(rq, p, flags);</span>
<span class='curline'><a href='../S/441.html#L1676'>rq</a>               1676 sched/core.c   void deactivate_task(struct rq *rq, struct task_struct *p, int flags)</span>
<span class='curline'><a href='../S/441.html#L1680'>rq</a>               1680 sched/core.c   	dequeue_task(rq, p, flags);</span>
<span class='curline'><a href='../S/441.html#L1750'>rq</a>               1750 sched/core.c   static inline void check_class_changed(struct rq *rq, struct task_struct *p,</span>
<span class='curline'><a href='../S/441.html#L1756'>rq</a>               1756 sched/core.c   			prev_class-&gt;switched_from(rq, p);</span>
<span class='curline'><a href='../S/441.html#L1758'>rq</a>               1758 sched/core.c   		p-&gt;sched_class-&gt;switched_to(rq, p);</span>
<span class='curline'><a href='../S/441.html#L1760'>rq</a>               1760 sched/core.c   		p-&gt;sched_class-&gt;prio_changed(rq, p, oldprio);</span>
<span class='curline'><a href='../S/441.html#L1763'>rq</a>               1763 sched/core.c   void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)</span>
<span class='curline'><a href='../S/441.html#L1765'>rq</a>               1765 sched/core.c   	if (p-&gt;sched_class == rq-&gt;curr-&gt;sched_class)</span>
<span class='curline'><a href='../S/441.html#L1766'>rq</a>               1766 sched/core.c   		rq-&gt;curr-&gt;sched_class-&gt;check_preempt_curr(rq, p, flags);</span>
<span class='curline'><a href='../S/441.html#L1767'>rq</a>               1767 sched/core.c   	else if (p-&gt;sched_class &gt; rq-&gt;curr-&gt;sched_class)</span>
<span class='curline'><a href='../S/441.html#L1768'>rq</a>               1768 sched/core.c   		resched_curr(rq);</span>
<span class='curline'><a href='../S/441.html#L1774'>rq</a>               1774 sched/core.c   	if (task_on_rq_queued(rq-&gt;curr) &amp;&amp; test_tsk_need_resched(rq-&gt;curr))</span>
<span class='curline'><a href='../S/441.html#L1775'>rq</a>               1775 sched/core.c   		rq_clock_skip_update(rq);</span>
<span class='curline'><a href='../S/441.html#L1818'>rq</a>               1818 sched/core.c   static struct rq *move_queued_task(struct rq *rq, struct rq_flags *rf,</span>
<span class='curline'><a href='../S/441.html#L1823'>rq</a>               1823 sched/core.c   	lockdep_assert_held(&amp;rq-&gt;lock);</span>
<span class='curline'><a href='../S/441.html#L1830'>rq</a>               1830 sched/core.c   	trace_android_rvh_migrate_queued_task(rq, rf, p, new_cpu, &amp;detached);</span>
<span class='curline'><a href='../S/441.html#L1834'>rq</a>               1834 sched/core.c   	deactivate_task(rq, p, DEQUEUE_NOCLOCK);</span>
<span class='curline'><a href='../S/441.html#L1838'>rq</a>               1838 sched/core.c   	rq_unlock(rq, rf);</span>
<span class='curline'><a href='../S/441.html#L1839'>rq</a>               1839 sched/core.c   	rq = cpu_rq(new_cpu);</span>
<span class='curline'><a href='../S/441.html#L1841'>rq</a>               1841 sched/core.c   	rq_lock(rq, rf);</span>
<span class='curline'><a href='../S/441.html#L1843'>rq</a>               1843 sched/core.c   	activate_task(rq, p, 0);</span>
<span class='curline'><a href='../S/441.html#L1844'>rq</a>               1844 sched/core.c   	check_preempt_curr(rq, p, 0);</span>
<span class='curline'><a href='../S/441.html#L1846'>rq</a>               1846 sched/core.c   	return rq;</span>
<span class='curline'><a href='../S/441.html#L1863'>rq</a>               1863 sched/core.c   static struct rq *__migrate_task(struct rq *rq, struct rq_flags *rf,</span>
<span class='curline'><a href='../S/441.html#L1868'>rq</a>               1868 sched/core.c   		return rq;</span>
<span class='curline'><a href='../S/441.html#L1870'>rq</a>               1870 sched/core.c   	update_rq_clock(rq);</span>
<span class='curline'><a href='../S/441.html#L1871'>rq</a>               1871 sched/core.c   	rq = move_queued_task(rq, rf, p, dest_cpu);</span>
<span class='curline'><a href='../S/441.html#L1873'>rq</a>               1873 sched/core.c   	return rq;</span>
<span class='curline'><a href='../S/441.html#L1885'>rq</a>               1885 sched/core.c   	struct rq *rq = this_rq();</span>
<span class='curline'><a href='../S/441.html#L1901'>rq</a>               1901 sched/core.c   	rq_lock(rq, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L1907'>rq</a>               1907 sched/core.c   	if (task_rq(p) == rq) {</span>
<span class='curline'><a href='../S/441.html#L1909'>rq</a>               1909 sched/core.c   			rq = __migrate_task(rq, &amp;rf, p, arg-&gt;dest_cpu);</span>
<span class='curline'><a href='../S/441.html#L1913'>rq</a>               1913 sched/core.c   	rq_unlock(rq, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L1933'>rq</a>               1933 sched/core.c   	struct rq *rq = task_rq(p);</span>
<span class='curline'><a href='../S/441.html#L1939'>rq</a>               1939 sched/core.c   	running = task_current(rq, p);</span>
<span class='curline'><a href='../S/441.html#L1946'>rq</a>               1946 sched/core.c   		lockdep_assert_held(&amp;rq-&gt;lock);</span>
<span class='curline'><a href='../S/441.html#L1947'>rq</a>               1947 sched/core.c   		dequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);</span>
<span class='curline'><a href='../S/441.html#L1950'>rq</a>               1950 sched/core.c   		put_prev_task(rq, p);</span>
<span class='curline'><a href='../S/441.html#L1955'>rq</a>               1955 sched/core.c   		enqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);</span>
<span class='curline'><a href='../S/441.html#L1957'>rq</a>               1957 sched/core.c   		set_next_task(rq, p);</span>
<span class='curline'><a href='../S/441.html#L1966'>rq</a>               1966 sched/core.c   					 struct rq *rq,</span>
<span class='curline'><a href='../S/441.html#L1974'>rq</a>               1974 sched/core.c   	update_rq_clock(rq);</span>
<span class='curline'><a href='../S/441.html#L2025'>rq</a>               2025 sched/core.c   	if (task_running(rq, p) || p-&gt;state == TASK_WAKING) {</span>
<span class='curline'><a href='../S/441.html#L2028'>rq</a>               2028 sched/core.c   		task_rq_unlock(rq, p, rf);</span>
<span class='curline'><a href='../S/441.html#L2029'>rq</a>               2029 sched/core.c   		stop_one_cpu(cpu_of(rq), migration_cpu_stop, &amp;arg);</span>
<span class='curline'><a href='../S/441.html#L2036'>rq</a>               2036 sched/core.c   		rq = move_queued_task(rq, rf, p, dest_cpu);</span>
<span class='curline'><a href='../S/441.html#L2039'>rq</a>               2039 sched/core.c   	task_rq_unlock(rq, p, rf);</span>
<span class='curline'><a href='../S/441.html#L2057'>rq</a>               2057 sched/core.c   	struct rq *rq;</span>
<span class='curline'><a href='../S/441.html#L2059'>rq</a>               2059 sched/core.c   	rq = task_rq_lock(p, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L2060'>rq</a>               2060 sched/core.c   	return __set_cpus_allowed_ptr_locked(p, new_mask, check, rq, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L2080'>rq</a>               2080 sched/core.c   	struct rq *rq;</span>
<span class='curline'><a href='../S/441.html#L2082'>rq</a>               2082 sched/core.c   	rq = task_rq_lock(p, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L2084'>rq</a>               2084 sched/core.c   		task_rq_unlock(rq, p, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L2088'>rq</a>               2088 sched/core.c   	return __set_cpus_allowed_ptr_locked(p, new_mask, false, rq, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L2194'>rq</a>               2194 sched/core.c   		struct rq *src_rq, *dst_rq;</span>
<span class='curline'><a href='../S/441.html#L2229'>rq</a>               2229 sched/core.c   	struct rq *src_rq, *dst_rq;</span>
<span class='curline'><a href='../S/441.html#L2328'>rq</a>               2328 sched/core.c   	struct rq *rq;</span>
<span class='curline'><a href='../S/441.html#L2337'>rq</a>               2337 sched/core.c   		rq = task_rq(p);</span>
<span class='curline'><a href='../S/441.html#L2350'>rq</a>               2350 sched/core.c   		while (task_running(rq, p)) {</span>
<span class='curline'><a href='../S/441.html#L2361'>rq</a>               2361 sched/core.c   		rq = task_rq_lock(p, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L2363'>rq</a>               2363 sched/core.c   		running = task_running(rq, p);</span>
<span class='curline'><a href='../S/441.html#L2368'>rq</a>               2368 sched/core.c   		task_rq_unlock(rq, p, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L2606'>rq</a>               2606 sched/core.c   	struct rq *rq;</span>
<span class='curline'><a href='../S/441.html#L2611'>rq</a>               2611 sched/core.c   	rq = this_rq();</span>
<span class='curline'><a href='../S/441.html#L2614'>rq</a>               2614 sched/core.c   	if (cpu == rq-&gt;cpu) {</span>
<span class='curline'><a href='../S/441.html#L2615'>rq</a>               2615 sched/core.c   		__schedstat_inc(rq-&gt;ttwu_local);</span>
<span class='curline'><a href='../S/441.html#L2622'>rq</a>               2622 sched/core.c   		for_each_domain(rq-&gt;cpu, sd) {</span>
<span class='curline'><a href='../S/441.html#L2635'>rq</a>               2635 sched/core.c   	__schedstat_inc(rq-&gt;ttwu_count);</span>
<span class='curline'><a href='../S/441.html#L2645'>rq</a>               2645 sched/core.c   static void ttwu_do_wakeup(struct rq *rq, struct task_struct *p, int wake_flags,</span>
<span class='curline'><a href='../S/441.html#L2648'>rq</a>               2648 sched/core.c   	check_preempt_curr(rq, p, wake_flags);</span>
<span class='curline'><a href='../S/441.html#L2658'>rq</a>               2658 sched/core.c   		rq_unpin_lock(rq, rf);</span>
<span class='curline'><a href='../S/441.html#L2659'>rq</a>               2659 sched/core.c   		p-&gt;sched_class-&gt;task_woken(rq, p);</span>
<span class='curline'><a href='../S/441.html#L2660'>rq</a>               2660 sched/core.c   		rq_repin_lock(rq, rf);</span>
<span class='curline'><a href='../S/441.html#L2663'>rq</a>               2663 sched/core.c   	if (rq-&gt;idle_stamp) {</span>
<span class='curline'><a href='../S/441.html#L2664'>rq</a>               2664 sched/core.c   		u64 delta = rq_clock(rq) - rq-&gt;idle_stamp;</span>
<span class='curline'><a href='../S/441.html#L2665'>rq</a>               2665 sched/core.c   		u64 max = 2*rq-&gt;max_idle_balance_cost;</span>
<span class='curline'><a href='../S/441.html#L2667'>rq</a>               2667 sched/core.c   		update_avg(&amp;rq-&gt;avg_idle, delta);</span>
<span class='curline'><a href='../S/441.html#L2669'>rq</a>               2669 sched/core.c   		if (rq-&gt;avg_idle &gt; max)</span>
<span class='curline'><a href='../S/441.html#L2670'>rq</a>               2670 sched/core.c   			rq-&gt;avg_idle = max;</span>
<span class='curline'><a href='../S/441.html#L2672'>rq</a>               2672 sched/core.c   		rq-&gt;idle_stamp = 0;</span>
<span class='curline'><a href='../S/441.html#L2678'>rq</a>               2678 sched/core.c   ttwu_do_activate(struct rq *rq, struct task_struct *p, int wake_flags,</span>
<span class='curline'><a href='../S/441.html#L2686'>rq</a>               2686 sched/core.c   	lockdep_assert_held(&amp;rq-&gt;lock);</span>
<span class='curline'><a href='../S/441.html#L2689'>rq</a>               2689 sched/core.c   		rq-&gt;nr_uninterruptible--;</span>
<span class='curline'><a href='../S/441.html#L2701'>rq</a>               2701 sched/core.c   	activate_task(rq, p, en_flags);</span>
<span class='curline'><a href='../S/441.html#L2702'>rq</a>               2702 sched/core.c   	ttwu_do_wakeup(rq, p, wake_flags, rf);</span>
<span class='curline'><a href='../S/441.html#L2733'>rq</a>               2733 sched/core.c   	struct rq *rq;</span>
<span class='curline'><a href='../S/441.html#L2736'>rq</a>               2736 sched/core.c   	rq = __task_rq_lock(p, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L2739'>rq</a>               2739 sched/core.c   		update_rq_clock(rq);</span>
<span class='curline'><a href='../S/441.html#L2740'>rq</a>               2740 sched/core.c   		ttwu_do_wakeup(rq, p, wake_flags, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L2743'>rq</a>               2743 sched/core.c   	__task_rq_unlock(rq, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L2752'>rq</a>               2752 sched/core.c   	struct rq *rq = this_rq();</span>
<span class='curline'><a href='../S/441.html#L2764'>rq</a>               2764 sched/core.c   	WRITE_ONCE(rq-&gt;ttwu_pending, 0);</span>
<span class='curline'><a href='../S/441.html#L2766'>rq</a>               2766 sched/core.c   	rq_lock_irqsave(rq, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L2767'>rq</a>               2767 sched/core.c   	update_rq_clock(rq);</span>
<span class='curline'><a href='../S/441.html#L2773'>rq</a>               2773 sched/core.c   		if (WARN_ON_ONCE(task_cpu(p) != cpu_of(rq)))</span>
<span class='curline'><a href='../S/441.html#L2774'>rq</a>               2774 sched/core.c   			set_task_cpu(p, cpu_of(rq));</span>
<span class='curline'><a href='../S/441.html#L2776'>rq</a>               2776 sched/core.c   		ttwu_do_activate(rq, p, p-&gt;sched_remote_wakeup ? WF_MIGRATED : 0, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L2779'>rq</a>               2779 sched/core.c   	rq_unlock_irqrestore(rq, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L2784'>rq</a>               2784 sched/core.c   	struct rq *rq = cpu_rq(cpu);</span>
<span class='curline'><a href='../S/441.html#L2786'>rq</a>               2786 sched/core.c   	if (!set_nr_if_polling(rq-&gt;idle))</span>
<span class='curline'><a href='../S/441.html#L2800'>rq</a>               2800 sched/core.c   	struct rq *rq = cpu_rq(cpu);</span>
<span class='curline'><a href='../S/441.html#L2804'>rq</a>               2804 sched/core.c   	WRITE_ONCE(rq-&gt;ttwu_pending, 1);</span>
<span class='curline'><a href='../S/441.html#L2810'>rq</a>               2810 sched/core.c   	struct rq *rq = cpu_rq(cpu);</span>
<span class='curline'><a href='../S/441.html#L2815'>rq</a>               2815 sched/core.c   	if (!is_idle_task(rcu_dereference(rq-&gt;curr)))</span>
<span class='curline'><a href='../S/441.html#L2818'>rq</a>               2818 sched/core.c   	if (set_nr_if_polling(rq-&gt;idle)) {</span>
<span class='curline'><a href='../S/441.html#L2821'>rq</a>               2821 sched/core.c   		rq_lock_irqsave(rq, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L2822'>rq</a>               2822 sched/core.c   		if (is_idle_task(rq-&gt;curr))</span>
<span class='curline'><a href='../S/441.html#L2825'>rq</a>               2825 sched/core.c   		rq_unlock_irqrestore(rq, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L2889'>rq</a>               2889 sched/core.c   	struct rq *rq = cpu_rq(cpu);</span>
<span class='curline'><a href='../S/441.html#L2895'>rq</a>               2895 sched/core.c   	rq_lock(rq, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L2896'>rq</a>               2896 sched/core.c   	update_rq_clock(rq);</span>
<span class='curline'><a href='../S/441.html#L2897'>rq</a>               2897 sched/core.c   	ttwu_do_activate(rq, p, wake_flags, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L2898'>rq</a>               2898 sched/core.c   	rq_unlock(rq, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L3225'>rq</a>               3225 sched/core.c   	struct rq *rq;</span>
<span class='curline'><a href='../S/441.html#L3229'>rq</a>               3229 sched/core.c   		rq = __task_rq_lock(p, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L3230'>rq</a>               3230 sched/core.c   		if (task_rq(p) == rq)</span>
<span class='curline'><a href='../S/441.html#L3232'>rq</a>               3232 sched/core.c   		rq_unlock(rq, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L3555'>rq</a>               3555 sched/core.c   	struct rq *rq;</span>
<span class='curline'><a href='../S/441.html#L3574'>rq</a>               3574 sched/core.c   	rq = __task_rq_lock(p, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L3575'>rq</a>               3575 sched/core.c   	update_rq_clock(rq);</span>
<span class='curline'><a href='../S/441.html#L3579'>rq</a>               3579 sched/core.c   	activate_task(rq, p, ENQUEUE_NOCLOCK);</span>
<span class='curline'><a href='../S/441.html#L3581'>rq</a>               3581 sched/core.c   	check_preempt_curr(rq, p, WF_FORK);</span>
<span class='curline'><a href='../S/441.html#L3588'>rq</a>               3588 sched/core.c   		rq_unpin_lock(rq, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L3589'>rq</a>               3589 sched/core.c   		p-&gt;sched_class-&gt;task_woken(rq, p);</span>
<span class='curline'><a href='../S/441.html#L3590'>rq</a>               3590 sched/core.c   		rq_repin_lock(rq, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L3593'>rq</a>               3593 sched/core.c   	task_rq_unlock(rq, p, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L3715'>rq</a>               3715 sched/core.c   prepare_lock_switch(struct rq *rq, struct task_struct *next, struct rq_flags *rf)</span>
<span class='curline'><a href='../S/441.html#L3723'>rq</a>               3723 sched/core.c   	rq_unpin_lock(rq, rf);</span>
<span class='curline'><a href='../S/441.html#L3724'>rq</a>               3724 sched/core.c   	spin_release(&amp;rq-&gt;lock.dep_map, _THIS_IP_);</span>
<span class='curline'><a href='../S/441.html#L3727'>rq</a>               3727 sched/core.c   	rq-&gt;lock.owner = next;</span>
<span class='curline'><a href='../S/441.html#L3731'>rq</a>               3731 sched/core.c   static inline void finish_lock_switch(struct rq *rq)</span>
<span class='curline'><a href='../S/441.html#L3738'>rq</a>               3738 sched/core.c   	spin_acquire(&amp;rq-&gt;lock.dep_map, 0, 0, _THIS_IP_);</span>
<span class='curline'><a href='../S/441.html#L3739'>rq</a>               3739 sched/core.c   	raw_spin_unlock_irq(&amp;rq-&gt;lock);</span>
<span class='curline'><a href='../S/441.html#L3768'>rq</a>               3768 sched/core.c   prepare_task_switch(struct rq *rq, struct task_struct *prev,</span>
<span class='curline'><a href='../S/441.html#L3772'>rq</a>               3772 sched/core.c   	sched_info_switch(rq, prev, next);</span>
<span class='curline'><a href='../S/441.html#L3799'>rq</a>               3799 sched/core.c   static struct rq *finish_task_switch(struct task_struct *prev)</span>
<span class='curline'><a href='../S/441.html#L3800'>rq</a>               3800 sched/core.c   	__releases(rq-&gt;lock)</span>
<span class='curline'><a href='../S/441.html#L3802'>rq</a>               3802 sched/core.c   	struct rq *rq = this_rq();</span>
<span class='curline'><a href='../S/441.html#L3803'>rq</a>               3803 sched/core.c   	struct mm_struct *mm = rq-&gt;prev_mm;</span>
<span class='curline'><a href='../S/441.html#L3822'>rq</a>               3822 sched/core.c   	rq-&gt;prev_mm = NULL;</span>
<span class='curline'><a href='../S/441.html#L3839'>rq</a>               3839 sched/core.c   	finish_lock_switch(rq);</span>
<span class='curline'><a href='../S/441.html#L3878'>rq</a>               3878 sched/core.c   	return rq;</span>
<span class='curline'><a href='../S/441.html#L3884'>rq</a>               3884 sched/core.c   static void __balance_callback(struct rq *rq)</span>
<span class='curline'><a href='../S/441.html#L3887'>rq</a>               3887 sched/core.c   	void (*func)(struct rq *rq);</span>
<span class='curline'><a href='../S/441.html#L3890'>rq</a>               3890 sched/core.c   	raw_spin_lock_irqsave(&amp;rq-&gt;lock, flags);</span>
<span class='curline'><a href='../S/441.html#L3891'>rq</a>               3891 sched/core.c   	head = rq-&gt;balance_callback;</span>
<span class='curline'><a href='../S/441.html#L3892'>rq</a>               3892 sched/core.c   	rq-&gt;balance_callback = NULL;</span>
<span class='curline'><a href='../S/441.html#L3894'>rq</a>               3894 sched/core.c   		func = (void (*)(struct rq *))head-&gt;func;</span>
<span class='curline'><a href='../S/441.html#L3899'>rq</a>               3899 sched/core.c   		func(rq);</span>
<span class='curline'><a href='../S/441.html#L3901'>rq</a>               3901 sched/core.c   	raw_spin_unlock_irqrestore(&amp;rq-&gt;lock, flags);</span>
<span class='curline'><a href='../S/441.html#L3904'>rq</a>               3904 sched/core.c   static inline void balance_callback(struct rq *rq)</span>
<span class='curline'><a href='../S/441.html#L3906'>rq</a>               3906 sched/core.c   	if (unlikely(rq-&gt;balance_callback))</span>
<span class='curline'><a href='../S/441.html#L3907'>rq</a>               3907 sched/core.c   		__balance_callback(rq);</span>
<span class='curline'><a href='../S/441.html#L3912'>rq</a>               3912 sched/core.c   static inline void balance_callback(struct rq *rq)</span>
<span class='curline'><a href='../S/441.html#L3923'>rq</a>               3923 sched/core.c   	__releases(rq-&gt;lock)</span>
<span class='curline'><a href='../S/441.html#L3925'>rq</a>               3925 sched/core.c   	struct rq *rq;</span>
<span class='curline'><a href='../S/441.html#L3936'>rq</a>               3936 sched/core.c   	rq = finish_task_switch(prev);</span>
<span class='curline'><a href='../S/441.html#L3937'>rq</a>               3937 sched/core.c   	balance_callback(rq);</span>
<span class='curline'><a href='../S/441.html#L3949'>rq</a>               3949 sched/core.c   static __always_inline struct rq *</span>
<span class='curline'><a href='../S/441.html#L3950'>rq</a>               3950 sched/core.c   context_switch(struct rq *rq, struct task_struct *prev,</span>
<span class='curline'><a href='../S/441.html#L3953'>rq</a>               3953 sched/core.c   	prepare_task_switch(rq, prev, next);</span>
<span class='curline'><a href='../S/441.html#L3978'>rq</a>               3978 sched/core.c   		membarrier_switch_mm(rq, prev-&gt;active_mm, next-&gt;mm);</span>
<span class='curline'><a href='../S/441.html#L3991'>rq</a>               3991 sched/core.c   			rq-&gt;prev_mm = prev-&gt;active_mm;</span>
<span class='curline'><a href='../S/441.html#L3996'>rq</a>               3996 sched/core.c   	rq-&gt;clock_update_flags &amp;= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);</span>
<span class='curline'><a href='../S/441.html#L3998'>rq</a>               3998 sched/core.c   	prepare_lock_switch(rq, next, rf);</span>
<span class='curline'><a href='../S/441.html#L4171'>rq</a>               4171 sched/core.c   	struct rq *rq;</span>
<span class='curline'><a href='../S/441.html#L4190'>rq</a>               4190 sched/core.c   	rq = task_rq_lock(p, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L4196'>rq</a>               4196 sched/core.c   	if (task_current(rq, p) &amp;&amp; task_on_rq_queued(p)) {</span>
<span class='curline'><a href='../S/441.html#L4198'>rq</a>               4198 sched/core.c   		update_rq_clock(rq);</span>
<span class='curline'><a href='../S/441.html#L4199'>rq</a>               4199 sched/core.c   		p-&gt;sched_class-&gt;update_curr(rq);</span>
<span class='curline'><a href='../S/441.html#L4202'>rq</a>               4202 sched/core.c   	task_rq_unlock(rq, p, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L4214'>rq</a>               4214 sched/core.c   	struct rq *rq = cpu_rq(cpu);</span>
<span class='curline'><a href='../S/441.html#L4215'>rq</a>               4215 sched/core.c   	struct task_struct *curr = rq-&gt;curr;</span>
<span class='curline'><a href='../S/441.html#L4222'>rq</a>               4222 sched/core.c   	rq_lock(rq, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L4224'>rq</a>               4224 sched/core.c   	trace_android_rvh_tick_entry(rq);</span>
<span class='curline'><a href='../S/441.html#L4225'>rq</a>               4225 sched/core.c   	update_rq_clock(rq);</span>
<span class='curline'><a href='../S/441.html#L4226'>rq</a>               4226 sched/core.c   	thermal_pressure = arch_scale_thermal_pressure(cpu_of(rq));</span>
<span class='curline'><a href='../S/441.html#L4227'>rq</a>               4227 sched/core.c   	update_thermal_load_avg(rq_clock_thermal(rq), rq, thermal_pressure);</span>
<span class='curline'><a href='../S/441.html#L4228'>rq</a>               4228 sched/core.c   	curr-&gt;sched_class-&gt;task_tick(rq, curr, 0);</span>
<span class='curline'><a href='../S/441.html#L4229'>rq</a>               4229 sched/core.c   	calc_global_load_tick(rq);</span>
<span class='curline'><a href='../S/441.html#L4230'>rq</a>               4230 sched/core.c   	psi_task_tick(rq);</span>
<span class='curline'><a href='../S/441.html#L4232'>rq</a>               4232 sched/core.c   	rq_unlock(rq, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L4237'>rq</a>               4237 sched/core.c   	rq-&gt;idle_balance = idle_cpu(cpu);</span>
<span class='curline'><a href='../S/441.html#L4238'>rq</a>               4238 sched/core.c   	trigger_load_balance(rq);</span>
<span class='curline'><a href='../S/441.html#L4241'>rq</a>               4241 sched/core.c   	trace_android_vh_scheduler_tick(rq);</span>
<span class='curline'><a href='../S/441.html#L4286'>rq</a>               4286 sched/core.c   	struct rq *rq = cpu_rq(cpu);</span>
<span class='curline'><a href='../S/441.html#L4302'>rq</a>               4302 sched/core.c   	rq_lock_irq(rq, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L4303'>rq</a>               4303 sched/core.c   	curr = rq-&gt;curr;</span>
<span class='curline'><a href='../S/441.html#L4307'>rq</a>               4307 sched/core.c   	update_rq_clock(rq);</span>
<span class='curline'><a href='../S/441.html#L4314'>rq</a>               4314 sched/core.c   		delta = rq_clock_task(rq) - curr-&gt;se.exec_start;</span>
<span class='curline'><a href='../S/441.html#L4317'>rq</a>               4317 sched/core.c   	curr-&gt;sched_class-&gt;task_tick(rq, curr, 0);</span>
<span class='curline'><a href='../S/441.html#L4319'>rq</a>               4319 sched/core.c   	calc_load_nohz_remote(rq);</span>
<span class='curline'><a href='../S/441.html#L4321'>rq</a>               4321 sched/core.c   	rq_unlock_irq(rq, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L4537'>rq</a>               4537 sched/core.c   static void put_prev_task_balance(struct rq *rq, struct task_struct *prev,</span>
<span class='curline'><a href='../S/441.html#L4551'>rq</a>               4551 sched/core.c   		if (class-&gt;balance(rq, prev, rf))</span>
<span class='curline'><a href='../S/441.html#L4556'>rq</a>               4556 sched/core.c   	put_prev_task(rq, prev);</span>
<span class='curline'><a href='../S/441.html#L4563'>rq</a>               4563 sched/core.c   pick_next_task(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)</span>
<span class='curline'><a href='../S/441.html#L4575'>rq</a>               4575 sched/core.c   		   rq-&gt;nr_running == rq-&gt;cfs.h_nr_running)) {</span>
<span class='curline'><a href='../S/441.html#L4577'>rq</a>               4577 sched/core.c   		p = pick_next_task_fair(rq, prev, rf);</span>
<span class='curline'><a href='../S/441.html#L4583'>rq</a>               4583 sched/core.c   			put_prev_task(rq, prev);</span>
<span class='curline'><a href='../S/441.html#L4584'>rq</a>               4584 sched/core.c   			p = pick_next_task_idle(rq);</span>
<span class='curline'><a href='../S/441.html#L4591'>rq</a>               4591 sched/core.c   	put_prev_task_balance(rq, prev, rf);</span>
<span class='curline'><a href='../S/441.html#L4594'>rq</a>               4594 sched/core.c   		p = class-&gt;pick_next_task(rq);</span>
<span class='curline'><a href='../S/441.html#L4648'>rq</a>               4648 sched/core.c   	struct rq *rq;</span>
<span class='curline'><a href='../S/441.html#L4652'>rq</a>               4652 sched/core.c   	rq = cpu_rq(cpu);</span>
<span class='curline'><a href='../S/441.html#L4653'>rq</a>               4653 sched/core.c   	prev = rq-&gt;curr;</span>
<span class='curline'><a href='../S/441.html#L4658'>rq</a>               4658 sched/core.c   		hrtick_clear(rq);</span>
<span class='curline'><a href='../S/441.html#L4678'>rq</a>               4678 sched/core.c   	rq_lock(rq, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L4682'>rq</a>               4682 sched/core.c   	rq-&gt;clock_update_flags &lt;&lt;= 1;</span>
<span class='curline'><a href='../S/441.html#L4683'>rq</a>               4683 sched/core.c   	update_rq_clock(rq);</span>
<span class='curline'><a href='../S/441.html#L4705'>rq</a>               4705 sched/core.c   				rq-&gt;nr_uninterruptible++;</span>
<span class='curline'><a href='../S/441.html#L4718'>rq</a>               4718 sched/core.c   			deactivate_task(rq, prev, DEQUEUE_SLEEP | DEQUEUE_NOCLOCK);</span>
<span class='curline'><a href='../S/441.html#L4721'>rq</a>               4721 sched/core.c   				atomic_inc(&amp;rq-&gt;nr_iowait);</span>
<span class='curline'><a href='../S/441.html#L4728'>rq</a>               4728 sched/core.c   	next = pick_next_task(rq, prev, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L4732'>rq</a>               4732 sched/core.c   	trace_android_rvh_schedule(prev, next, rq);</span>
<span class='curline'><a href='../S/441.html#L4734'>rq</a>               4734 sched/core.c   		rq-&gt;nr_switches++;</span>
<span class='curline'><a href='../S/441.html#L4739'>rq</a>               4739 sched/core.c   		RCU_INIT_POINTER(rq-&gt;curr, next);</span>
<span class='curline'><a href='../S/441.html#L4761'>rq</a>               4761 sched/core.c   		rq = context_switch(rq, prev, next, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L4763'>rq</a>               4763 sched/core.c   		rq-&gt;clock_update_flags &amp;= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);</span>
<span class='curline'><a href='../S/441.html#L4764'>rq</a>               4764 sched/core.c   		rq_unlock_irq(rq, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L4767'>rq</a>               4767 sched/core.c   	balance_callback(rq);</span>
<span class='curline'><a href='../S/441.html#L5072'>rq</a>               5072 sched/core.c   	struct rq *rq;</span>
<span class='curline'><a href='../S/441.html#L5084'>rq</a>               5084 sched/core.c   	rq = __task_rq_lock(p, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L5085'>rq</a>               5085 sched/core.c   	update_rq_clock(rq);</span>
<span class='curline'><a href='../S/441.html#L5116'>rq</a>               5116 sched/core.c   	if (unlikely(p == rq-&gt;idle)) {</span>
<span class='curline'><a href='../S/441.html#L5117'>rq</a>               5117 sched/core.c   		WARN_ON(p != rq-&gt;curr);</span>
<span class='curline'><a href='../S/441.html#L5130'>rq</a>               5130 sched/core.c   	running = task_current(rq, p);</span>
<span class='curline'><a href='../S/441.html#L5132'>rq</a>               5132 sched/core.c   		dequeue_task(rq, p, queue_flag);</span>
<span class='curline'><a href='../S/441.html#L5134'>rq</a>               5134 sched/core.c   		put_prev_task(rq, p);</span>
<span class='curline'><a href='../S/441.html#L5172'>rq</a>               5172 sched/core.c   		enqueue_task(rq, p, queue_flag);</span>
<span class='curline'><a href='../S/441.html#L5174'>rq</a>               5174 sched/core.c   		set_next_task(rq, p);</span>
<span class='curline'><a href='../S/441.html#L5176'>rq</a>               5176 sched/core.c   	check_class_changed(rq, p, prev_class, oldprio);</span>
<span class='curline'><a href='../S/441.html#L5180'>rq</a>               5180 sched/core.c   	__task_rq_unlock(rq, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L5182'>rq</a>               5182 sched/core.c   	balance_callback(rq);</span>
<span class='curline'><a href='../S/441.html#L5197'>rq</a>               5197 sched/core.c   	struct rq *rq;</span>
<span class='curline'><a href='../S/441.html#L5206'>rq</a>               5206 sched/core.c   	rq = task_rq_lock(p, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L5207'>rq</a>               5207 sched/core.c   	update_rq_clock(rq);</span>
<span class='curline'><a href='../S/441.html#L5220'>rq</a>               5220 sched/core.c   	running = task_current(rq, p);</span>
<span class='curline'><a href='../S/441.html#L5222'>rq</a>               5222 sched/core.c   		dequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);</span>
<span class='curline'><a href='../S/441.html#L5224'>rq</a>               5224 sched/core.c   		put_prev_task(rq, p);</span>
<span class='curline'><a href='../S/441.html#L5232'>rq</a>               5232 sched/core.c   		enqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);</span>
<span class='curline'><a href='../S/441.html#L5234'>rq</a>               5234 sched/core.c   		set_next_task(rq, p);</span>
<span class='curline'><a href='../S/441.html#L5240'>rq</a>               5240 sched/core.c   	p-&gt;sched_class-&gt;prio_changed(rq, p, old_prio);</span>
<span class='curline'><a href='../S/441.html#L5243'>rq</a>               5243 sched/core.c   	task_rq_unlock(rq, p, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L5317'>rq</a>               5317 sched/core.c   	struct rq *rq = cpu_rq(cpu);</span>
<span class='curline'><a href='../S/441.html#L5319'>rq</a>               5319 sched/core.c   	if (rq-&gt;curr != rq-&gt;idle)</span>
<span class='curline'><a href='../S/441.html#L5322'>rq</a>               5322 sched/core.c   	if (rq-&gt;nr_running)</span>
<span class='curline'><a href='../S/441.html#L5326'>rq</a>               5326 sched/core.c   	if (rq-&gt;ttwu_pending)</span>
<span class='curline'><a href='../S/441.html#L5405'>rq</a>               5405 sched/core.c   static void __setscheduler(struct rq *rq, struct task_struct *p,</span>
<span class='curline'><a href='../S/441.html#L5463'>rq</a>               5463 sched/core.c   	struct rq *rq;</span>
<span class='curline'><a href='../S/441.html#L5568'>rq</a>               5568 sched/core.c   	rq = task_rq_lock(p, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L5569'>rq</a>               5569 sched/core.c   	update_rq_clock(rq);</span>
<span class='curline'><a href='../S/441.html#L5574'>rq</a>               5574 sched/core.c   	if (p == rq-&gt;stop) {</span>
<span class='curline'><a href='../S/441.html#L5615'>rq</a>               5615 sched/core.c   			cpumask_t *span = rq-&gt;rd-&gt;span;</span>
<span class='curline'><a href='../S/441.html#L5623'>rq</a>               5623 sched/core.c   			    rq-&gt;rd-&gt;dl_bw.bw == 0) {</span>
<span class='curline'><a href='../S/441.html#L5634'>rq</a>               5634 sched/core.c   		task_rq_unlock(rq, p, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L5665'>rq</a>               5665 sched/core.c   	running = task_current(rq, p);</span>
<span class='curline'><a href='../S/441.html#L5667'>rq</a>               5667 sched/core.c   		dequeue_task(rq, p, queue_flags);</span>
<span class='curline'><a href='../S/441.html#L5669'>rq</a>               5669 sched/core.c   		put_prev_task(rq, p);</span>
<span class='curline'><a href='../S/441.html#L5673'>rq</a>               5673 sched/core.c   	__setscheduler(rq, p, attr, pi);</span>
<span class='curline'><a href='../S/441.html#L5684'>rq</a>               5684 sched/core.c   		enqueue_task(rq, p, queue_flags);</span>
<span class='curline'><a href='../S/441.html#L5687'>rq</a>               5687 sched/core.c   		set_next_task(rq, p);</span>
<span class='curline'><a href='../S/441.html#L5689'>rq</a>               5689 sched/core.c   	check_class_changed(rq, p, prev_class, oldprio);</span>
<span class='curline'><a href='../S/441.html#L5693'>rq</a>               5693 sched/core.c   	task_rq_unlock(rq, p, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L5699'>rq</a>               5699 sched/core.c   	balance_callback(rq);</span>
<span class='curline'><a href='../S/441.html#L5705'>rq</a>               5705 sched/core.c   	task_rq_unlock(rq, p, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L6331'>rq</a>               6331 sched/core.c   	struct rq *rq;</span>
<span class='curline'><a href='../S/441.html#L6333'>rq</a>               6333 sched/core.c   	rq = this_rq_lock_irq(&amp;rf);</span>
<span class='curline'><a href='../S/441.html#L6335'>rq</a>               6335 sched/core.c   	schedstat_inc(rq-&gt;yld_count);</span>
<span class='curline'><a href='../S/441.html#L6336'>rq</a>               6336 sched/core.c   	current-&gt;sched_class-&gt;yield_task(rq);</span>
<span class='curline'><a href='../S/441.html#L6339'>rq</a>               6339 sched/core.c   	rq_unlock_irq(rq, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L6439'>rq</a>               6439 sched/core.c   	struct rq *rq, *p_rq;</span>
<span class='curline'><a href='../S/441.html#L6444'>rq</a>               6444 sched/core.c   	rq = this_rq();</span>
<span class='curline'><a href='../S/441.html#L6452'>rq</a>               6452 sched/core.c   	if (rq-&gt;nr_running == 1 &amp;&amp; p_rq-&gt;nr_running == 1) {</span>
<span class='curline'><a href='../S/441.html#L6457'>rq</a>               6457 sched/core.c   	double_rq_lock(rq, p_rq);</span>
<span class='curline'><a href='../S/441.html#L6459'>rq</a>               6459 sched/core.c   		double_rq_unlock(rq, p_rq);</span>
<span class='curline'><a href='../S/441.html#L6472'>rq</a>               6472 sched/core.c   	yielded = curr-&gt;sched_class-&gt;yield_to_task(rq, p);</span>
<span class='curline'><a href='../S/441.html#L6474'>rq</a>               6474 sched/core.c   		schedstat_inc(rq-&gt;yld_count);</span>
<span class='curline'><a href='../S/441.html#L6479'>rq</a>               6479 sched/core.c   		if (preempt &amp;&amp; rq != p_rq)</span>
<span class='curline'><a href='../S/441.html#L6484'>rq</a>               6484 sched/core.c   	double_rq_unlock(rq, p_rq);</span>
<span class='curline'><a href='../S/441.html#L6595'>rq</a>               6595 sched/core.c   	struct rq *rq;</span>
<span class='curline'><a href='../S/441.html#L6611'>rq</a>               6611 sched/core.c   	rq = task_rq_lock(p, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L6614'>rq</a>               6614 sched/core.c   		time_slice = p-&gt;sched_class-&gt;get_rr_interval(rq, p);</span>
<span class='curline'><a href='../S/441.html#L6615'>rq</a>               6615 sched/core.c   	task_rq_unlock(rq, p, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L6756'>rq</a>               6756 sched/core.c   	struct rq *rq = cpu_rq(cpu);</span>
<span class='curline'><a href='../S/441.html#L6762'>rq</a>               6762 sched/core.c   	raw_spin_lock(&amp;rq-&gt;lock);</span>
<span class='curline'><a href='../S/441.html#L6794'>rq</a>               6794 sched/core.c   	rq-&gt;idle = idle;</span>
<span class='curline'><a href='../S/441.html#L6795'>rq</a>               6795 sched/core.c   	rcu_assign_pointer(rq-&gt;curr, idle);</span>
<span class='curline'><a href='../S/441.html#L6800'>rq</a>               6800 sched/core.c   	raw_spin_unlock(&amp;rq-&gt;lock);</span>
<span class='curline'><a href='../S/441.html#L6888'>rq</a>               6888 sched/core.c   	struct rq *rq;</span>
<span class='curline'><a href='../S/441.html#L6890'>rq</a>               6890 sched/core.c   	rq = task_rq_lock(p, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L6892'>rq</a>               6892 sched/core.c   	running = task_current(rq, p);</span>
<span class='curline'><a href='../S/441.html#L6895'>rq</a>               6895 sched/core.c   		dequeue_task(rq, p, DEQUEUE_SAVE);</span>
<span class='curline'><a href='../S/441.html#L6897'>rq</a>               6897 sched/core.c   		put_prev_task(rq, p);</span>
<span class='curline'><a href='../S/441.html#L6902'>rq</a>               6902 sched/core.c   		enqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);</span>
<span class='curline'><a href='../S/441.html#L6904'>rq</a>               6904 sched/core.c   		set_next_task(rq, p);</span>
<span class='curline'><a href='../S/441.html#L6905'>rq</a>               6905 sched/core.c   	task_rq_unlock(rq, p, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L6938'>rq</a>               6938 sched/core.c   static void calc_load_migrate(struct rq *rq)</span>
<span class='curline'><a href='../S/441.html#L6940'>rq</a>               6940 sched/core.c   	long delta = calc_load_fold_active(rq, 1);</span>
<span class='curline'><a href='../S/441.html#L6945'>rq</a>               6945 sched/core.c   static struct task_struct *__pick_migrate_task(struct rq *rq)</span>
<span class='curline'><a href='../S/441.html#L6951'>rq</a>               6951 sched/core.c   		next = class-&gt;pick_next_task(rq);</span>
<span class='curline'><a href='../S/441.html#L6953'>rq</a>               6953 sched/core.c   			next-&gt;sched_class-&gt;put_prev_task(rq, next);</span>
<span class='curline'><a href='../S/441.html#L6972'>rq</a>               6972 sched/core.c   static void migrate_tasks(struct rq *dead_rq, struct rq_flags *rf, bool force)</span>
<span class='curline'><a href='../S/441.html#L6974'>rq</a>               6974 sched/core.c   	struct rq *rq = dead_rq;</span>
<span class='curline'><a href='../S/441.html#L6975'>rq</a>               6975 sched/core.c   	struct task_struct *next, *tmp, *stop = rq-&gt;stop;</span>
<span class='curline'><a href='../S/441.html#L6989'>rq</a>               6989 sched/core.c   	rq-&gt;stop = NULL;</span>
<span class='curline'><a href='../S/441.html#L6996'>rq</a>               6996 sched/core.c   	update_rq_clock(rq);</span>
<span class='curline'><a href='../S/441.html#L7008'>rq</a>               7008 sched/core.c   		if (rq-&gt;nr_running == 1)</span>
<span class='curline'><a href='../S/441.html#L7011'>rq</a>               7011 sched/core.c   		next = __pick_migrate_task(rq);</span>
<span class='curline'><a href='../S/441.html#L7022'>rq</a>               7022 sched/core.c   			deactivate_task(rq, next,</span>
<span class='curline'><a href='../S/441.html#L7036'>rq</a>               7036 sched/core.c   		rq_unlock(rq, rf);</span>
<span class='curline'><a href='../S/441.html#L7038'>rq</a>               7038 sched/core.c   		rq_relock(rq, rf);</span>
<span class='curline'><a href='../S/441.html#L7045'>rq</a>               7045 sched/core.c   		if (task_rq(next) != rq || !task_on_rq_queued(next)) {</span>
<span class='curline'><a href='../S/441.html#L7059'>rq</a>               7059 sched/core.c   		rq = __migrate_task(rq, rf, next, dest_cpu);</span>
<span class='curline'><a href='../S/441.html#L7060'>rq</a>               7060 sched/core.c   		if (rq != dead_rq) {</span>
<span class='curline'><a href='../S/441.html#L7061'>rq</a>               7061 sched/core.c   			rq_unlock(rq, rf);</span>
<span class='curline'><a href='../S/441.html#L7062'>rq</a>               7062 sched/core.c   			rq = dead_rq;</span>
<span class='curline'><a href='../S/441.html#L7064'>rq</a>               7064 sched/core.c   			rq_relock(rq, rf);</span>
<span class='curline'><a href='../S/441.html#L7073'>rq</a>               7073 sched/core.c   		activate_task(rq, next, ENQUEUE_NOCLOCK);</span>
<span class='curline'><a href='../S/441.html#L7077'>rq</a>               7077 sched/core.c   	rq-&gt;stop = stop;</span>
<span class='curline'><a href='../S/441.html#L7082'>rq</a>               7082 sched/core.c   	struct rq *rq = this_rq();</span>
<span class='curline'><a href='../S/441.html#L7085'>rq</a>               7085 sched/core.c   	rq_lock_irqsave(rq, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L7086'>rq</a>               7086 sched/core.c   	migrate_tasks(rq, &amp;rf, false);</span>
<span class='curline'><a href='../S/441.html#L7087'>rq</a>               7087 sched/core.c   	rq_unlock_irqrestore(rq, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L7115'>rq</a>               7115 sched/core.c   void set_rq_online(struct rq *rq)</span>
<span class='curline'><a href='../S/441.html#L7117'>rq</a>               7117 sched/core.c   	if (!rq-&gt;online) {</span>
<span class='curline'><a href='../S/441.html#L7120'>rq</a>               7120 sched/core.c   		cpumask_set_cpu(rq-&gt;cpu, rq-&gt;rd-&gt;online);</span>
<span class='curline'><a href='../S/441.html#L7121'>rq</a>               7121 sched/core.c   		rq-&gt;online = 1;</span>
<span class='curline'><a href='../S/441.html#L7125'>rq</a>               7125 sched/core.c   				class-&gt;rq_online(rq);</span>
<span class='curline'><a href='../S/441.html#L7130'>rq</a>               7130 sched/core.c   void set_rq_offline(struct rq *rq)</span>
<span class='curline'><a href='../S/441.html#L7132'>rq</a>               7132 sched/core.c   	if (rq-&gt;online) {</span>
<span class='curline'><a href='../S/441.html#L7137'>rq</a>               7137 sched/core.c   				class-&gt;rq_offline(rq);</span>
<span class='curline'><a href='../S/441.html#L7140'>rq</a>               7140 sched/core.c   		cpumask_clear_cpu(rq-&gt;cpu, rq-&gt;rd-&gt;online);</span>
<span class='curline'><a href='../S/441.html#L7141'>rq</a>               7141 sched/core.c   		rq-&gt;online = 0;</span>
<span class='curline'><a href='../S/441.html#L7195'>rq</a>               7195 sched/core.c   	struct rq *rq = cpu_rq(cpu);</span>
<span class='curline'><a href='../S/441.html#L7221'>rq</a>               7221 sched/core.c   	rq_lock_irqsave(rq, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L7222'>rq</a>               7222 sched/core.c   	if (rq-&gt;rd) {</span>
<span class='curline'><a href='../S/441.html#L7223'>rq</a>               7223 sched/core.c   		BUG_ON(!cpumask_test_cpu(cpu, rq-&gt;rd-&gt;span));</span>
<span class='curline'><a href='../S/441.html#L7224'>rq</a>               7224 sched/core.c   		set_rq_online(rq);</span>
<span class='curline'><a href='../S/441.html#L7226'>rq</a>               7226 sched/core.c   	rq_unlock_irqrestore(rq, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L7317'>rq</a>               7317 sched/core.c   	struct rq *rq = cpu_rq(cpu);</span>
<span class='curline'><a href='../S/441.html#L7319'>rq</a>               7319 sched/core.c   	rq-&gt;calc_load_update = calc_load_update;</span>
<span class='curline'><a href='../S/441.html#L7333'>rq</a>               7333 sched/core.c   	struct rq *rq = cpu_rq(cpu);</span>
<span class='curline'><a href='../S/441.html#L7339'>rq</a>               7339 sched/core.c   	rq_lock_irqsave(rq, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L7340'>rq</a>               7340 sched/core.c   	if (rq-&gt;rd) {</span>
<span class='curline'><a href='../S/441.html#L7341'>rq</a>               7341 sched/core.c   		BUG_ON(!cpumask_test_cpu(cpu, rq-&gt;rd-&gt;span));</span>
<span class='curline'><a href='../S/441.html#L7342'>rq</a>               7342 sched/core.c   		set_rq_offline(rq);</span>
<span class='curline'><a href='../S/441.html#L7344'>rq</a>               7344 sched/core.c   	migrate_tasks(rq, &amp;rf, true);</span>
<span class='curline'><a href='../S/441.html#L7345'>rq</a>               7345 sched/core.c   	BUG_ON(rq-&gt;nr_running != 1);</span>
<span class='curline'><a href='../S/441.html#L7346'>rq</a>               7346 sched/core.c   	rq_unlock_irqrestore(rq, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L7350'>rq</a>               7350 sched/core.c   	calc_load_migrate(rq);</span>
<span class='curline'><a href='../S/441.html#L7351'>rq</a>               7351 sched/core.c   	nohz_balance_exit_idle(rq);</span>
<span class='curline'><a href='../S/441.html#L7352'>rq</a>               7352 sched/core.c   	hrtick_clear(rq);</span>
<span class='curline'><a href='../S/441.html#L7494'>rq</a>               7494 sched/core.c   		struct rq *rq;</span>
<span class='curline'><a href='../S/441.html#L7496'>rq</a>               7496 sched/core.c   		rq = cpu_rq(i);</span>
<span class='curline'><a href='../S/441.html#L7497'>rq</a>               7497 sched/core.c   		raw_spin_lock_init(&amp;rq-&gt;lock);</span>
<span class='curline'><a href='../S/441.html#L7498'>rq</a>               7498 sched/core.c   		rq-&gt;nr_running = 0;</span>
<span class='curline'><a href='../S/441.html#L7499'>rq</a>               7499 sched/core.c   		rq-&gt;calc_load_active = 0;</span>
<span class='curline'><a href='../S/441.html#L7500'>rq</a>               7500 sched/core.c   		rq-&gt;calc_load_update = jiffies + LOAD_FREQ;</span>
<span class='curline'><a href='../S/441.html#L7501'>rq</a>               7501 sched/core.c   		init_cfs_rq(&amp;rq-&gt;cfs);</span>
<span class='curline'><a href='../S/441.html#L7502'>rq</a>               7502 sched/core.c   		init_rt_rq(&amp;rq-&gt;rt);</span>
<span class='curline'><a href='../S/441.html#L7503'>rq</a>               7503 sched/core.c   		init_dl_rq(&amp;rq-&gt;dl);</span>
<span class='curline'><a href='../S/441.html#L7505'>rq</a>               7505 sched/core.c   		INIT_LIST_HEAD(&amp;rq-&gt;leaf_cfs_rq_list);</span>
<span class='curline'><a href='../S/441.html#L7506'>rq</a>               7506 sched/core.c   		rq-&gt;tmp_alone_branch = &amp;rq-&gt;leaf_cfs_rq_list;</span>
<span class='curline'><a href='../S/441.html#L7526'>rq</a>               7526 sched/core.c   		init_tg_cfs_entry(&amp;root_task_group, &amp;rq-&gt;cfs, NULL, i, NULL);</span>
<span class='curline'><a href='../S/441.html#L7529'>rq</a>               7529 sched/core.c   		rq-&gt;rt.rt_runtime = def_rt_bandwidth.rt_runtime;</span>
<span class='curline'><a href='../S/441.html#L7531'>rq</a>               7531 sched/core.c   		init_tg_rt_entry(&amp;root_task_group, &amp;rq-&gt;rt, NULL, i, NULL);</span>
<span class='curline'><a href='../S/441.html#L7534'>rq</a>               7534 sched/core.c   		rq-&gt;sd = NULL;</span>
<span class='curline'><a href='../S/441.html#L7535'>rq</a>               7535 sched/core.c   		rq-&gt;rd = NULL;</span>
<span class='curline'><a href='../S/441.html#L7536'>rq</a>               7536 sched/core.c   		rq-&gt;cpu_capacity = rq-&gt;cpu_capacity_orig = SCHED_CAPACITY_SCALE;</span>
<span class='curline'><a href='../S/441.html#L7537'>rq</a>               7537 sched/core.c   		rq-&gt;balance_callback = NULL;</span>
<span class='curline'><a href='../S/441.html#L7538'>rq</a>               7538 sched/core.c   		rq-&gt;active_balance = 0;</span>
<span class='curline'><a href='../S/441.html#L7539'>rq</a>               7539 sched/core.c   		rq-&gt;next_balance = jiffies;</span>
<span class='curline'><a href='../S/441.html#L7540'>rq</a>               7540 sched/core.c   		rq-&gt;push_cpu = 0;</span>
<span class='curline'><a href='../S/441.html#L7541'>rq</a>               7541 sched/core.c   		rq-&gt;cpu = i;</span>
<span class='curline'><a href='../S/441.html#L7542'>rq</a>               7542 sched/core.c   		rq-&gt;online = 0;</span>
<span class='curline'><a href='../S/441.html#L7543'>rq</a>               7543 sched/core.c   		rq-&gt;idle_stamp = 0;</span>
<span class='curline'><a href='../S/441.html#L7544'>rq</a>               7544 sched/core.c   		rq-&gt;avg_idle = 2*sysctl_sched_migration_cost;</span>
<span class='curline'><a href='../S/441.html#L7545'>rq</a>               7545 sched/core.c   		rq-&gt;max_idle_balance_cost = sysctl_sched_migration_cost;</span>
<span class='curline'><a href='../S/441.html#L7547'>rq</a>               7547 sched/core.c   		INIT_LIST_HEAD(&amp;rq-&gt;cfs_tasks);</span>
<span class='curline'><a href='../S/441.html#L7549'>rq</a>               7549 sched/core.c   		rq_attach_root(rq, &amp;def_root_domain);</span>
<span class='curline'><a href='../S/441.html#L7551'>rq</a>               7551 sched/core.c   		rq-&gt;last_blocked_load_update_tick = jiffies;</span>
<span class='curline'><a href='../S/441.html#L7552'>rq</a>               7552 sched/core.c   		atomic_set(&amp;rq-&gt;nohz_flags, 0);</span>
<span class='curline'><a href='../S/441.html#L7554'>rq</a>               7554 sched/core.c   		rq_csd_init(rq, &amp;rq-&gt;nohz_csd, nohz_csd_func);</span>
<span class='curline'><a href='../S/441.html#L7557'>rq</a>               7557 sched/core.c   		hrtick_rq_init(rq);</span>
<span class='curline'><a href='../S/441.html#L7558'>rq</a>               7558 sched/core.c   		atomic_set(&amp;rq-&gt;nr_iowait, 0);</span>
<span class='curline'><a href='../S/441.html#L7913'>rq</a>               7913 sched/core.c   	struct rq *rq;</span>
<span class='curline'><a href='../S/441.html#L7915'>rq</a>               7915 sched/core.c   	rq = task_rq_lock(tsk, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L7916'>rq</a>               7916 sched/core.c   	update_rq_clock(rq);</span>
<span class='curline'><a href='../S/441.html#L7918'>rq</a>               7918 sched/core.c   	running = task_current(rq, tsk);</span>
<span class='curline'><a href='../S/441.html#L7922'>rq</a>               7922 sched/core.c   		dequeue_task(rq, tsk, queue_flags);</span>
<span class='curline'><a href='../S/441.html#L7924'>rq</a>               7924 sched/core.c   		put_prev_task(rq, tsk);</span>
<span class='curline'><a href='../S/441.html#L7929'>rq</a>               7929 sched/core.c   		enqueue_task(rq, tsk, queue_flags);</span>
<span class='curline'><a href='../S/441.html#L7931'>rq</a>               7931 sched/core.c   		set_next_task(rq, tsk);</span>
<span class='curline'><a href='../S/441.html#L7937'>rq</a>               7937 sched/core.c   		resched_curr(rq);</span>
<span class='curline'><a href='../S/441.html#L7940'>rq</a>               7940 sched/core.c   	task_rq_unlock(rq, tsk, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L8008'>rq</a>               8008 sched/core.c   	struct rq *rq;</span>
<span class='curline'><a href='../S/441.html#L8010'>rq</a>               8010 sched/core.c   	rq = task_rq_lock(task, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L8012'>rq</a>               8012 sched/core.c   	update_rq_clock(rq);</span>
<span class='curline'><a href='../S/441.html#L8015'>rq</a>               8015 sched/core.c   	task_rq_unlock(rq, task, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L8347'>rq</a>               8347 sched/core.c   		struct rq *rq = cfs_rq-&gt;rq;</span>
<span class='curline'><a href='../S/441.html#L8350'>rq</a>               8350 sched/core.c   		rq_lock_irq(rq, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L8356'>rq</a>               8356 sched/core.c   		rq_unlock_irq(rq, &amp;rf);</span>
<span class='curline'><a href='../S/441.html#L8885'>rq</a>               8885 sched/core.c   void call_trace_sched_update_nr_running(struct rq *rq, int count)</span>
<span class='curline'><a href='../S/441.html#L8887'>rq</a>               8887 sched/core.c           trace_sched_update_nr_running_tp(rq, count);</span>
<span class='curline'><a href='../S/466.html#L207'>rq</a>                207 sched/cpufreq_schedutil.c 	struct rq *rq = cpu_rq(cpu);</span>
<span class='curline'><a href='../S/466.html#L210'>rq</a>                210 sched/cpufreq_schedutil.c 	    type == FREQUENCY_UTIL &amp;&amp; rt_rq_is_runnable(&amp;rq-&gt;rt)) {</span>
<span class='curline'><a href='../S/466.html#L219'>rq</a>                219 sched/cpufreq_schedutil.c 	irq = cpu_util_irq(rq);</span>
<span class='curline'><a href='../S/466.html#L235'>rq</a>                235 sched/cpufreq_schedutil.c 	util = util_cfs + cpu_util_rt(rq);</span>
<span class='curline'><a href='../S/466.html#L237'>rq</a>                237 sched/cpufreq_schedutil.c 		util = uclamp_rq_util_with(rq, util, p);</span>
<span class='curline'><a href='../S/466.html#L239'>rq</a>                239 sched/cpufreq_schedutil.c 	dl_util = cpu_util_dl(rq);</span>
<span class='curline'><a href='../S/466.html#L283'>rq</a>                283 sched/cpufreq_schedutil.c 		util += cpu_bw_dl(rq);</span>
<span class='curline'><a href='../S/466.html#L291'>rq</a>                291 sched/cpufreq_schedutil.c 	struct rq *rq = cpu_rq(sg_cpu-&gt;cpu);</span>
<span class='curline'><a href='../S/466.html#L292'>rq</a>                292 sched/cpufreq_schedutil.c 	unsigned long util = cpu_util_cfs(rq);</span>
<span class='curline'><a href='../S/466.html#L296'>rq</a>                296 sched/cpufreq_schedutil.c 	sg_cpu-&gt;bw_dl = cpu_bw_dl(rq);</span>
<span class='curline'><a href='../S/473.html#L232'>rq</a>                232 sched/cputime.c 	struct rq *rq = this_rq();</span>
<span class='curline'><a href='../S/473.html#L234'>rq</a>                234 sched/cputime.c 	if (atomic_read(&amp;rq-&gt;nr_iowait) &gt; 0)</span>
<span class='curline'><a href='../S/473.html#L290'>rq</a>                290 sched/cputime.c 	struct rq *rq;</span>
<span class='curline'><a href='../S/473.html#L292'>rq</a>                292 sched/cputime.c 	rq = task_rq_lock(t, &amp;rf);</span>
<span class='curline'><a href='../S/473.html#L294'>rq</a>                294 sched/cputime.c 	task_rq_unlock(rq, t, &amp;rf);</span>
<span class='curline'><a href='../S/473.html#L979'>rq</a>                979 sched/cputime.c 	struct rq *rq;</span>
<span class='curline'><a href='../S/473.html#L985'>rq</a>                985 sched/cputime.c 	rq = cpu_rq(cpu);</span>
<span class='curline'><a href='../S/473.html#L991'>rq</a>                991 sched/cputime.c 		curr = rcu_dereference(rq-&gt;curr);</span>
<span class='curline'><a href='../S/473.html#L1064'>rq</a>               1064 sched/cputime.c 	struct rq *rq;</span>
<span class='curline'><a href='../S/473.html#L1072'>rq</a>               1072 sched/cputime.c 	rq = cpu_rq(cpu);</span>
<span class='curline'><a href='../S/473.html#L1078'>rq</a>               1078 sched/cputime.c 		curr = rcu_dereference(rq-&gt;curr);</span>
<span class='curline'><a href='../S/451.html#L28'>rq</a>                 28 sched/deadline.c static inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)</span>
<span class='curline'><a href='../S/451.html#L30'>rq</a>                 30 sched/deadline.c 	return container_of(dl_rq, struct rq, dl);</span>
<span class='curline'><a href='../S/451.html#L36'>rq</a>                 36 sched/deadline.c 	struct rq *rq = task_rq(p);</span>
<span class='curline'><a href='../S/451.html#L38'>rq</a>                 38 sched/deadline.c 	return &amp;rq-&gt;dl;</span>
<span class='curline'><a href='../S/451.html#L219'>rq</a>                219 sched/deadline.c 	struct rq *rq;</span>
<span class='curline'><a href='../S/451.html#L226'>rq</a>                226 sched/deadline.c 	rq = task_rq(p);</span>
<span class='curline'><a href='../S/451.html#L228'>rq</a>                228 sched/deadline.c 		sub_running_bw(&amp;p-&gt;dl, &amp;rq-&gt;dl);</span>
<span class='curline'><a href='../S/451.html#L240'>rq</a>                240 sched/deadline.c 	__sub_rq_bw(p-&gt;dl.dl_bw, &amp;rq-&gt;dl);</span>
<span class='curline'><a href='../S/451.html#L241'>rq</a>                241 sched/deadline.c 	__add_rq_bw(new_bw, &amp;rq-&gt;dl);</span>
<span class='curline'><a href='../S/451.html#L303'>rq</a>                303 sched/deadline.c 	struct rq *rq = rq_of_dl_rq(dl_rq);</span>
<span class='curline'><a href='../S/451.html#L326'>rq</a>                326 sched/deadline.c 	zerolag_time -= rq_clock(rq);</span>
<span class='curline'><a href='../S/451.html#L339'>rq</a>                339 sched/deadline.c 				sub_rq_bw(&amp;p-&gt;dl, &amp;rq-&gt;dl);</span>
<span class='curline'><a href='../S/451.html#L441'>rq</a>                441 sched/deadline.c static inline int dl_overloaded(struct rq *rq)</span>
<span class='curline'><a href='../S/451.html#L443'>rq</a>                443 sched/deadline.c 	return atomic_read(&amp;rq-&gt;rd-&gt;dlo_count);</span>
<span class='curline'><a href='../S/451.html#L446'>rq</a>                446 sched/deadline.c static inline void dl_set_overload(struct rq *rq)</span>
<span class='curline'><a href='../S/451.html#L448'>rq</a>                448 sched/deadline.c 	if (!rq-&gt;online)</span>
<span class='curline'><a href='../S/451.html#L451'>rq</a>                451 sched/deadline.c 	cpumask_set_cpu(rq-&gt;cpu, rq-&gt;rd-&gt;dlo_mask);</span>
<span class='curline'><a href='../S/451.html#L459'>rq</a>                459 sched/deadline.c 	atomic_inc(&amp;rq-&gt;rd-&gt;dlo_count);</span>
<span class='curline'><a href='../S/451.html#L462'>rq</a>                462 sched/deadline.c static inline void dl_clear_overload(struct rq *rq)</span>
<span class='curline'><a href='../S/451.html#L464'>rq</a>                464 sched/deadline.c 	if (!rq-&gt;online)</span>
<span class='curline'><a href='../S/451.html#L467'>rq</a>                467 sched/deadline.c 	atomic_dec(&amp;rq-&gt;rd-&gt;dlo_count);</span>
<span class='curline'><a href='../S/451.html#L468'>rq</a>                468 sched/deadline.c 	cpumask_clear_cpu(rq-&gt;cpu, rq-&gt;rd-&gt;dlo_mask);</span>
<span class='curline'><a href='../S/451.html#L508'>rq</a>                508 sched/deadline.c static void enqueue_pushable_dl_task(struct rq *rq, struct task_struct *p)</span>
<span class='curline'><a href='../S/451.html#L510'>rq</a>                510 sched/deadline.c 	struct dl_rq *dl_rq = &amp;rq-&gt;dl;</span>
<span class='curline'><a href='../S/451.html#L538'>rq</a>                538 sched/deadline.c static void dequeue_pushable_dl_task(struct rq *rq, struct task_struct *p)</span>
<span class='curline'><a href='../S/451.html#L540'>rq</a>                540 sched/deadline.c 	struct dl_rq *dl_rq = &amp;rq-&gt;dl;</span>
<span class='curline'><a href='../S/451.html#L559'>rq</a>                559 sched/deadline.c static inline int has_pushable_dl_tasks(struct rq *rq)</span>
<span class='curline'><a href='../S/451.html#L561'>rq</a>                561 sched/deadline.c 	return !RB_EMPTY_ROOT(&amp;rq-&gt;dl.pushable_dl_tasks_root.rb_root);</span>
<span class='curline'><a href='../S/451.html#L564'>rq</a>                564 sched/deadline.c static int push_dl_task(struct rq *rq);</span>
<span class='curline'><a href='../S/451.html#L566'>rq</a>                566 sched/deadline.c static inline bool need_pull_dl_task(struct rq *rq, struct task_struct *prev)</span>
<span class='curline'><a href='../S/451.html#L574'>rq</a>                574 sched/deadline.c static void push_dl_tasks(struct rq *);</span>
<span class='curline'><a href='../S/451.html#L575'>rq</a>                575 sched/deadline.c static void pull_dl_task(struct rq *);</span>
<span class='curline'><a href='../S/451.html#L577'>rq</a>                577 sched/deadline.c static inline void deadline_queue_push_tasks(struct rq *rq)</span>
<span class='curline'><a href='../S/451.html#L579'>rq</a>                579 sched/deadline.c 	if (!has_pushable_dl_tasks(rq))</span>
<span class='curline'><a href='../S/451.html#L582'>rq</a>                582 sched/deadline.c 	queue_balance_callback(rq, &amp;per_cpu(dl_push_head, rq-&gt;cpu), push_dl_tasks);</span>
<span class='curline'><a href='../S/451.html#L585'>rq</a>                585 sched/deadline.c static inline void deadline_queue_pull_task(struct rq *rq)</span>
<span class='curline'><a href='../S/451.html#L587'>rq</a>                587 sched/deadline.c 	queue_balance_callback(rq, &amp;per_cpu(dl_pull_head, rq-&gt;cpu), pull_dl_task);</span>
<span class='curline'><a href='../S/451.html#L590'>rq</a>                590 sched/deadline.c static struct rq *find_lock_later_rq(struct task_struct *task, struct rq *rq);</span>
<span class='curline'><a href='../S/451.html#L592'>rq</a>                592 sched/deadline.c static struct rq *dl_task_offline_migration(struct rq *rq, struct task_struct *p)</span>
<span class='curline'><a href='../S/451.html#L594'>rq</a>                594 sched/deadline.c 	struct rq *later_rq = NULL;</span>
<span class='curline'><a href='../S/451.html#L597'>rq</a>                597 sched/deadline.c 	later_rq = find_lock_later_rq(p, rq);</span>
<span class='curline'><a href='../S/451.html#L621'>rq</a>                621 sched/deadline.c 		double_lock_balance(rq, later_rq);</span>
<span class='curline'><a href='../S/451.html#L631'>rq</a>                631 sched/deadline.c 		sub_running_bw(&amp;p-&gt;dl, &amp;rq-&gt;dl);</span>
<span class='curline'><a href='../S/451.html#L632'>rq</a>                632 sched/deadline.c 		sub_rq_bw(&amp;p-&gt;dl, &amp;rq-&gt;dl);</span>
<span class='curline'><a href='../S/451.html#L637'>rq</a>                637 sched/deadline.c 		sub_rq_bw(&amp;p-&gt;dl, &amp;rq-&gt;dl);</span>
<span class='curline'><a href='../S/451.html#L646'>rq</a>                646 sched/deadline.c 	dl_b = &amp;rq-&gt;rd-&gt;dl_bw;</span>
<span class='curline'><a href='../S/451.html#L648'>rq</a>                648 sched/deadline.c 	__dl_sub(dl_b, p-&gt;dl.dl_bw, cpumask_weight(rq-&gt;rd-&gt;span));</span>
<span class='curline'><a href='../S/451.html#L657'>rq</a>                657 sched/deadline.c 	double_unlock_balance(later_rq, rq);</span>
<span class='curline'><a href='../S/451.html#L665'>rq</a>                665 sched/deadline.c void enqueue_pushable_dl_task(struct rq *rq, struct task_struct *p)</span>
<span class='curline'><a href='../S/451.html#L670'>rq</a>                670 sched/deadline.c void dequeue_pushable_dl_task(struct rq *rq, struct task_struct *p)</span>
<span class='curline'><a href='../S/451.html#L684'>rq</a>                684 sched/deadline.c static inline bool need_pull_dl_task(struct rq *rq, struct task_struct *prev)</span>
<span class='curline'><a href='../S/451.html#L689'>rq</a>                689 sched/deadline.c static inline void pull_dl_task(struct rq *rq)</span>
<span class='curline'><a href='../S/451.html#L693'>rq</a>                693 sched/deadline.c static inline void deadline_queue_push_tasks(struct rq *rq)</span>
<span class='curline'><a href='../S/451.html#L697'>rq</a>                697 sched/deadline.c static inline void deadline_queue_pull_task(struct rq *rq)</span>
<span class='curline'><a href='../S/451.html#L702'>rq</a>                702 sched/deadline.c static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);</span>
<span class='curline'><a href='../S/451.html#L703'>rq</a>                703 sched/deadline.c static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);</span>
<span class='curline'><a href='../S/451.html#L704'>rq</a>                704 sched/deadline.c static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);</span>
<span class='curline'><a href='../S/451.html#L721'>rq</a>                721 sched/deadline.c 	struct rq *rq = rq_of_dl_rq(dl_rq);</span>
<span class='curline'><a href='../S/451.html#L724'>rq</a>                724 sched/deadline.c 	WARN_ON(dl_time_before(rq_clock(rq), dl_se-&gt;deadline));</span>
<span class='curline'><a href='../S/451.html#L739'>rq</a>                739 sched/deadline.c 	dl_se-&gt;deadline = rq_clock(rq) + dl_se-&gt;dl_deadline;</span>
<span class='curline'><a href='../S/451.html#L764'>rq</a>                764 sched/deadline.c 	struct rq *rq = rq_of_dl_rq(dl_rq);</span>
<span class='curline'><a href='../S/451.html#L773'>rq</a>                773 sched/deadline.c 		dl_se-&gt;deadline = rq_clock(rq) + pi_of(dl_se)-&gt;dl_deadline;</span>
<span class='curline'><a href='../S/451.html#L800'>rq</a>                800 sched/deadline.c 	if (dl_time_before(dl_se-&gt;deadline, rq_clock(rq))) {</span>
<span class='curline'><a href='../S/451.html#L802'>rq</a>                802 sched/deadline.c 		dl_se-&gt;deadline = rq_clock(rq) + pi_of(dl_se)-&gt;dl_deadline;</span>
<span class='curline'><a href='../S/451.html#L884'>rq</a>                884 sched/deadline.c update_dl_revised_wakeup(struct sched_dl_entity *dl_se, struct rq *rq)</span>
<span class='curline'><a href='../S/451.html#L886'>rq</a>                886 sched/deadline.c 	u64 laxity = dl_se-&gt;deadline - rq_clock(rq);</span>
<span class='curline'><a href='../S/451.html#L894'>rq</a>                894 sched/deadline.c 	WARN_ON(dl_time_before(dl_se-&gt;deadline, rq_clock(rq)));</span>
<span class='curline'><a href='../S/451.html#L948'>rq</a>                948 sched/deadline.c 	struct rq *rq = rq_of_dl_rq(dl_rq);</span>
<span class='curline'><a href='../S/451.html#L950'>rq</a>                950 sched/deadline.c 	if (dl_time_before(dl_se-&gt;deadline, rq_clock(rq)) ||</span>
<span class='curline'><a href='../S/451.html#L951'>rq</a>                951 sched/deadline.c 	    dl_entity_overflow(dl_se, rq_clock(rq))) {</span>
<span class='curline'><a href='../S/451.html#L954'>rq</a>                954 sched/deadline.c 			     !dl_time_before(dl_se-&gt;deadline, rq_clock(rq)) &amp;&amp;</span>
<span class='curline'><a href='../S/451.html#L956'>rq</a>                956 sched/deadline.c 			update_dl_revised_wakeup(dl_se, rq);</span>
<span class='curline'><a href='../S/451.html#L960'>rq</a>                960 sched/deadline.c 		dl_se-&gt;deadline = rq_clock(rq) + pi_of(dl_se)-&gt;dl_deadline;</span>
<span class='curline'><a href='../S/451.html#L984'>rq</a>                984 sched/deadline.c 	struct rq *rq = task_rq(p);</span>
<span class='curline'><a href='../S/451.html#L988'>rq</a>                988 sched/deadline.c 	lockdep_assert_held(&amp;rq-&gt;lock);</span>
<span class='curline'><a href='../S/451.html#L997'>rq</a>                997 sched/deadline.c 	delta = ktime_to_ns(now) - rq_clock(rq);</span>
<span class='curline'><a href='../S/451.html#L1045'>rq</a>               1045 sched/deadline.c 	struct rq *rq;</span>
<span class='curline'><a href='../S/451.html#L1047'>rq</a>               1047 sched/deadline.c 	rq = task_rq_lock(p, &amp;rf);</span>
<span class='curline'><a href='../S/451.html#L1071'>rq</a>               1071 sched/deadline.c 	update_rq_clock(rq);</span>
<span class='curline'><a href='../S/451.html#L1093'>rq</a>               1093 sched/deadline.c 	if (unlikely(!rq-&gt;online)) {</span>
<span class='curline'><a href='../S/451.html#L1098'>rq</a>               1098 sched/deadline.c 		lockdep_unpin_lock(&amp;rq-&gt;lock, rf.cookie);</span>
<span class='curline'><a href='../S/451.html#L1099'>rq</a>               1099 sched/deadline.c 		rq = dl_task_offline_migration(rq, p);</span>
<span class='curline'><a href='../S/451.html#L1100'>rq</a>               1100 sched/deadline.c 		rf.cookie = lockdep_pin_lock(&amp;rq-&gt;lock);</span>
<span class='curline'><a href='../S/451.html#L1101'>rq</a>               1101 sched/deadline.c 		update_rq_clock(rq);</span>
<span class='curline'><a href='../S/451.html#L1111'>rq</a>               1111 sched/deadline.c 	enqueue_task_dl(rq, p, ENQUEUE_REPLENISH);</span>
<span class='curline'><a href='../S/451.html#L1112'>rq</a>               1112 sched/deadline.c 	if (dl_task(rq-&gt;curr))</span>
<span class='curline'><a href='../S/451.html#L1113'>rq</a>               1113 sched/deadline.c 		check_preempt_curr_dl(rq, p, 0);</span>
<span class='curline'><a href='../S/451.html#L1115'>rq</a>               1115 sched/deadline.c 		resched_curr(rq);</span>
<span class='curline'><a href='../S/451.html#L1122'>rq</a>               1122 sched/deadline.c 	if (has_pushable_dl_tasks(rq)) {</span>
<span class='curline'><a href='../S/451.html#L1127'>rq</a>               1127 sched/deadline.c 		rq_unpin_lock(rq, &amp;rf);</span>
<span class='curline'><a href='../S/451.html#L1128'>rq</a>               1128 sched/deadline.c 		push_dl_task(rq);</span>
<span class='curline'><a href='../S/451.html#L1129'>rq</a>               1129 sched/deadline.c 		rq_repin_lock(rq, &amp;rf);</span>
<span class='curline'><a href='../S/451.html#L1134'>rq</a>               1134 sched/deadline.c 	task_rq_unlock(rq, p, &amp;rf);</span>
<span class='curline'><a href='../S/451.html#L1174'>rq</a>               1174 sched/deadline.c 	struct rq *rq = rq_of_dl_rq(dl_rq_of_se(dl_se));</span>
<span class='curline'><a href='../S/451.html#L1176'>rq</a>               1176 sched/deadline.c 	if (dl_time_before(dl_se-&gt;deadline, rq_clock(rq)) &amp;&amp;</span>
<span class='curline'><a href='../S/451.html#L1177'>rq</a>               1177 sched/deadline.c 	    dl_time_before(rq_clock(rq), dl_next_period(dl_se))) {</span>
<span class='curline'><a href='../S/451.html#L1213'>rq</a>               1213 sched/deadline.c static u64 grub_reclaim(u64 delta, struct rq *rq, struct sched_dl_entity *dl_se)</span>
<span class='curline'><a href='../S/451.html#L1215'>rq</a>               1215 sched/deadline.c 	u64 u_inact = rq-&gt;dl.this_bw - rq-&gt;dl.running_bw; /* Utot - Uact */</span>
<span class='curline'><a href='../S/451.html#L1217'>rq</a>               1217 sched/deadline.c 	u64 u_act_min = (dl_se-&gt;dl_bw * rq-&gt;dl.bw_ratio) &gt;&gt; RATIO_SHIFT;</span>
<span class='curline'><a href='../S/451.html#L1227'>rq</a>               1227 sched/deadline.c 	if (u_inact + rq-&gt;dl.extra_bw &gt; BW_UNIT - u_act_min)</span>
<span class='curline'><a href='../S/451.html#L1230'>rq</a>               1230 sched/deadline.c 		u_act = BW_UNIT - u_inact - rq-&gt;dl.extra_bw;</span>
<span class='curline'><a href='../S/451.html#L1239'>rq</a>               1239 sched/deadline.c static void update_curr_dl(struct rq *rq)</span>
<span class='curline'><a href='../S/451.html#L1241'>rq</a>               1241 sched/deadline.c 	struct task_struct *curr = rq-&gt;curr;</span>
<span class='curline'><a href='../S/451.html#L1244'>rq</a>               1244 sched/deadline.c 	int cpu = cpu_of(rq);</span>
<span class='curline'><a href='../S/451.html#L1258'>rq</a>               1258 sched/deadline.c 	now = rq_clock_task(rq);</span>
<span class='curline'><a href='../S/451.html#L1287'>rq</a>               1287 sched/deadline.c 						 rq,</span>
<span class='curline'><a href='../S/451.html#L1308'>rq</a>               1308 sched/deadline.c 		__dequeue_task_dl(rq, curr, 0);</span>
<span class='curline'><a href='../S/451.html#L1310'>rq</a>               1310 sched/deadline.c 			enqueue_task_dl(rq, curr, ENQUEUE_REPLENISH);</span>
<span class='curline'><a href='../S/451.html#L1312'>rq</a>               1312 sched/deadline.c 		if (!is_leftmost(curr, &amp;rq-&gt;dl))</span>
<span class='curline'><a href='../S/451.html#L1313'>rq</a>               1313 sched/deadline.c 			resched_curr(rq);</span>
<span class='curline'><a href='../S/451.html#L1328'>rq</a>               1328 sched/deadline.c 		struct rt_rq *rt_rq = &amp;rq-&gt;rt;</span>
<span class='curline'><a href='../S/451.html#L1349'>rq</a>               1349 sched/deadline.c 	struct rq *rq;</span>
<span class='curline'><a href='../S/451.html#L1351'>rq</a>               1351 sched/deadline.c 	rq = task_rq_lock(p, &amp;rf);</span>
<span class='curline'><a href='../S/451.html#L1354'>rq</a>               1354 sched/deadline.c 	update_rq_clock(rq);</span>
<span class='curline'><a href='../S/451.html#L1375'>rq</a>               1375 sched/deadline.c 	sub_running_bw(dl_se, &amp;rq-&gt;dl);</span>
<span class='curline'><a href='../S/451.html#L1378'>rq</a>               1378 sched/deadline.c 	task_rq_unlock(rq, p, &amp;rf);</span>
<span class='curline'><a href='../S/451.html#L1396'>rq</a>               1396 sched/deadline.c 	struct rq *rq = rq_of_dl_rq(dl_rq);</span>
<span class='curline'><a href='../S/451.html#L1401'>rq</a>               1401 sched/deadline.c 		cpudl_set(&amp;rq-&gt;rd-&gt;cpudl, rq-&gt;cpu, deadline);</span>
<span class='curline'><a href='../S/451.html#L1407'>rq</a>               1407 sched/deadline.c 	struct rq *rq = rq_of_dl_rq(dl_rq);</span>
<span class='curline'><a href='../S/451.html#L1416'>rq</a>               1416 sched/deadline.c 		cpudl_clear(&amp;rq-&gt;rd-&gt;cpudl, rq-&gt;cpu);</span>
<span class='curline'><a href='../S/451.html#L1423'>rq</a>               1423 sched/deadline.c 		cpudl_set(&amp;rq-&gt;rd-&gt;cpudl, rq-&gt;cpu, entry-&gt;deadline);</span>
<span class='curline'><a href='../S/451.html#L1531'>rq</a>               1531 sched/deadline.c static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags)</span>
<span class='curline'><a href='../S/451.html#L1580'>rq</a>               1580 sched/deadline.c 		add_rq_bw(&amp;p-&gt;dl, &amp;rq-&gt;dl);</span>
<span class='curline'><a href='../S/451.html#L1581'>rq</a>               1581 sched/deadline.c 		add_running_bw(&amp;p-&gt;dl, &amp;rq-&gt;dl);</span>
<span class='curline'><a href='../S/451.html#L1605'>rq</a>               1605 sched/deadline.c 	if (!task_current(rq, p) &amp;&amp; p-&gt;nr_cpus_allowed &gt; 1)</span>
<span class='curline'><a href='../S/451.html#L1606'>rq</a>               1606 sched/deadline.c 		enqueue_pushable_dl_task(rq, p);</span>
<span class='curline'><a href='../S/451.html#L1609'>rq</a>               1609 sched/deadline.c static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags)</span>
<span class='curline'><a href='../S/451.html#L1612'>rq</a>               1612 sched/deadline.c 	dequeue_pushable_dl_task(rq, p);</span>
<span class='curline'><a href='../S/451.html#L1615'>rq</a>               1615 sched/deadline.c static void dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags)</span>
<span class='curline'><a href='../S/451.html#L1617'>rq</a>               1617 sched/deadline.c 	update_curr_dl(rq);</span>
<span class='curline'><a href='../S/451.html#L1618'>rq</a>               1618 sched/deadline.c 	__dequeue_task_dl(rq, p, flags);</span>
<span class='curline'><a href='../S/451.html#L1621'>rq</a>               1621 sched/deadline.c 		sub_running_bw(&amp;p-&gt;dl, &amp;rq-&gt;dl);</span>
<span class='curline'><a href='../S/451.html#L1622'>rq</a>               1622 sched/deadline.c 		sub_rq_bw(&amp;p-&gt;dl, &amp;rq-&gt;dl);</span>
<span class='curline'><a href='../S/451.html#L1648'>rq</a>               1648 sched/deadline.c static void yield_task_dl(struct rq *rq)</span>
<span class='curline'><a href='../S/451.html#L1656'>rq</a>               1656 sched/deadline.c 	rq-&gt;curr-&gt;dl.dl_yielded = 1;</span>
<span class='curline'><a href='../S/451.html#L1658'>rq</a>               1658 sched/deadline.c 	update_rq_clock(rq);</span>
<span class='curline'><a href='../S/451.html#L1659'>rq</a>               1659 sched/deadline.c 	update_curr_dl(rq);</span>
<span class='curline'><a href='../S/451.html#L1665'>rq</a>               1665 sched/deadline.c 	rq_clock_skip_update(rq);</span>
<span class='curline'><a href='../S/451.html#L1677'>rq</a>               1677 sched/deadline.c 	struct rq *rq;</span>
<span class='curline'><a href='../S/451.html#L1682'>rq</a>               1682 sched/deadline.c 	rq = cpu_rq(cpu);</span>
<span class='curline'><a href='../S/451.html#L1685'>rq</a>               1685 sched/deadline.c 	curr = READ_ONCE(rq-&gt;curr); /* unlocked access */</span>
<span class='curline'><a href='../S/451.html#L1725'>rq</a>               1725 sched/deadline.c 	struct rq *rq;</span>
<span class='curline'><a href='../S/451.html#L1730'>rq</a>               1730 sched/deadline.c 	rq = task_rq(p);</span>
<span class='curline'><a href='../S/451.html#L1736'>rq</a>               1736 sched/deadline.c 	raw_spin_lock(&amp;rq-&gt;lock);</span>
<span class='curline'><a href='../S/451.html#L1738'>rq</a>               1738 sched/deadline.c 		sub_running_bw(&amp;p-&gt;dl, &amp;rq-&gt;dl);</span>
<span class='curline'><a href='../S/451.html#L1750'>rq</a>               1750 sched/deadline.c 	sub_rq_bw(&amp;p-&gt;dl, &amp;rq-&gt;dl);</span>
<span class='curline'><a href='../S/451.html#L1751'>rq</a>               1751 sched/deadline.c 	raw_spin_unlock(&amp;rq-&gt;lock);</span>
<span class='curline'><a href='../S/451.html#L1754'>rq</a>               1754 sched/deadline.c static void check_preempt_equal_dl(struct rq *rq, struct task_struct *p)</span>
<span class='curline'><a href='../S/451.html#L1760'>rq</a>               1760 sched/deadline.c 	if (rq-&gt;curr-&gt;nr_cpus_allowed == 1 ||</span>
<span class='curline'><a href='../S/451.html#L1761'>rq</a>               1761 sched/deadline.c 	    !cpudl_find(&amp;rq-&gt;rd-&gt;cpudl, rq-&gt;curr, NULL))</span>
<span class='curline'><a href='../S/451.html#L1769'>rq</a>               1769 sched/deadline.c 	    cpudl_find(&amp;rq-&gt;rd-&gt;cpudl, p, NULL))</span>
<span class='curline'><a href='../S/451.html#L1772'>rq</a>               1772 sched/deadline.c 	resched_curr(rq);</span>
<span class='curline'><a href='../S/451.html#L1775'>rq</a>               1775 sched/deadline.c static int balance_dl(struct rq *rq, struct task_struct *p, struct rq_flags *rf)</span>
<span class='curline'><a href='../S/451.html#L1777'>rq</a>               1777 sched/deadline.c 	if (!on_dl_rq(&amp;p-&gt;dl) &amp;&amp; need_pull_dl_task(rq, p)) {</span>
<span class='curline'><a href='../S/451.html#L1784'>rq</a>               1784 sched/deadline.c 		rq_unpin_lock(rq, rf);</span>
<span class='curline'><a href='../S/451.html#L1785'>rq</a>               1785 sched/deadline.c 		pull_dl_task(rq);</span>
<span class='curline'><a href='../S/451.html#L1786'>rq</a>               1786 sched/deadline.c 		rq_repin_lock(rq, rf);</span>
<span class='curline'><a href='../S/451.html#L1789'>rq</a>               1789 sched/deadline.c 	return sched_stop_runnable(rq) || sched_dl_runnable(rq);</span>
<span class='curline'><a href='../S/451.html#L1797'>rq</a>               1797 sched/deadline.c static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p,</span>
<span class='curline'><a href='../S/451.html#L1800'>rq</a>               1800 sched/deadline.c 	if (dl_entity_preempt(&amp;p-&gt;dl, &amp;rq-&gt;curr-&gt;dl)) {</span>
<span class='curline'><a href='../S/451.html#L1801'>rq</a>               1801 sched/deadline.c 		resched_curr(rq);</span>
<span class='curline'><a href='../S/451.html#L1810'>rq</a>               1810 sched/deadline.c 	if ((p-&gt;dl.deadline == rq-&gt;curr-&gt;dl.deadline) &amp;&amp;</span>
<span class='curline'><a href='../S/451.html#L1811'>rq</a>               1811 sched/deadline.c 	    !test_tsk_need_resched(rq-&gt;curr))</span>
<span class='curline'><a href='../S/451.html#L1812'>rq</a>               1812 sched/deadline.c 		check_preempt_equal_dl(rq, p);</span>
<span class='curline'><a href='../S/451.html#L1817'>rq</a>               1817 sched/deadline.c static void start_hrtick_dl(struct rq *rq, struct task_struct *p)</span>
<span class='curline'><a href='../S/451.html#L1819'>rq</a>               1819 sched/deadline.c 	hrtick_start(rq, p-&gt;dl.runtime);</span>
<span class='curline'><a href='../S/451.html#L1822'>rq</a>               1822 sched/deadline.c static void start_hrtick_dl(struct rq *rq, struct task_struct *p)</span>
<span class='curline'><a href='../S/451.html#L1827'>rq</a>               1827 sched/deadline.c static void set_next_task_dl(struct rq *rq, struct task_struct *p, bool first)</span>
<span class='curline'><a href='../S/451.html#L1829'>rq</a>               1829 sched/deadline.c 	p-&gt;se.exec_start = rq_clock_task(rq);</span>
<span class='curline'><a href='../S/451.html#L1832'>rq</a>               1832 sched/deadline.c 	dequeue_pushable_dl_task(rq, p);</span>
<span class='curline'><a href='../S/451.html#L1837'>rq</a>               1837 sched/deadline.c 	if (hrtick_enabled(rq))</span>
<span class='curline'><a href='../S/451.html#L1838'>rq</a>               1838 sched/deadline.c 		start_hrtick_dl(rq, p);</span>
<span class='curline'><a href='../S/451.html#L1840'>rq</a>               1840 sched/deadline.c 	if (rq-&gt;curr-&gt;sched_class != &amp;dl_sched_class)</span>
<span class='curline'><a href='../S/451.html#L1841'>rq</a>               1841 sched/deadline.c 		update_dl_rq_load_avg(rq_clock_pelt(rq), rq, 0);</span>
<span class='curline'><a href='../S/451.html#L1843'>rq</a>               1843 sched/deadline.c 	deadline_queue_push_tasks(rq);</span>
<span class='curline'><a href='../S/451.html#L1846'>rq</a>               1846 sched/deadline.c static struct sched_dl_entity *pick_next_dl_entity(struct rq *rq,</span>
<span class='curline'><a href='../S/451.html#L1857'>rq</a>               1857 sched/deadline.c static struct task_struct *pick_next_task_dl(struct rq *rq)</span>
<span class='curline'><a href='../S/451.html#L1860'>rq</a>               1860 sched/deadline.c 	struct dl_rq *dl_rq = &amp;rq-&gt;dl;</span>
<span class='curline'><a href='../S/451.html#L1863'>rq</a>               1863 sched/deadline.c 	if (!sched_dl_runnable(rq))</span>
<span class='curline'><a href='../S/451.html#L1866'>rq</a>               1866 sched/deadline.c 	dl_se = pick_next_dl_entity(rq, dl_rq);</span>
<span class='curline'><a href='../S/451.html#L1869'>rq</a>               1869 sched/deadline.c 	set_next_task_dl(rq, p, true);</span>
<span class='curline'><a href='../S/451.html#L1873'>rq</a>               1873 sched/deadline.c static void put_prev_task_dl(struct rq *rq, struct task_struct *p)</span>
<span class='curline'><a href='../S/451.html#L1875'>rq</a>               1875 sched/deadline.c 	update_curr_dl(rq);</span>
<span class='curline'><a href='../S/451.html#L1877'>rq</a>               1877 sched/deadline.c 	update_dl_rq_load_avg(rq_clock_pelt(rq), rq, 1);</span>
<span class='curline'><a href='../S/451.html#L1879'>rq</a>               1879 sched/deadline.c 		enqueue_pushable_dl_task(rq, p);</span>
<span class='curline'><a href='../S/451.html#L1890'>rq</a>               1890 sched/deadline.c static void task_tick_dl(struct rq *rq, struct task_struct *p, int queued)</span>
<span class='curline'><a href='../S/451.html#L1892'>rq</a>               1892 sched/deadline.c 	update_curr_dl(rq);</span>
<span class='curline'><a href='../S/451.html#L1894'>rq</a>               1894 sched/deadline.c 	update_dl_rq_load_avg(rq_clock_pelt(rq), rq, 1);</span>
<span class='curline'><a href='../S/451.html#L1900'>rq</a>               1900 sched/deadline.c 	if (hrtick_enabled(rq) &amp;&amp; queued &amp;&amp; p-&gt;dl.runtime &gt; 0 &amp;&amp;</span>
<span class='curline'><a href='../S/451.html#L1901'>rq</a>               1901 sched/deadline.c 	    is_leftmost(p, &amp;rq-&gt;dl))</span>
<span class='curline'><a href='../S/451.html#L1902'>rq</a>               1902 sched/deadline.c 		start_hrtick_dl(rq, p);</span>
<span class='curline'><a href='../S/451.html#L1918'>rq</a>               1918 sched/deadline.c static int pick_dl_task(struct rq *rq, struct task_struct *p, int cpu)</span>
<span class='curline'><a href='../S/451.html#L1920'>rq</a>               1920 sched/deadline.c 	if (!task_running(rq, p) &amp;&amp;</span>
<span class='curline'><a href='../S/451.html#L1930'>rq</a>               1930 sched/deadline.c static struct task_struct *pick_earliest_pushable_dl_task(struct rq *rq, int cpu)</span>
<span class='curline'><a href='../S/451.html#L1932'>rq</a>               1932 sched/deadline.c 	struct rb_node *next_node = rq-&gt;dl.pushable_dl_tasks_root.rb_leftmost;</span>
<span class='curline'><a href='../S/451.html#L1935'>rq</a>               1935 sched/deadline.c 	if (!has_pushable_dl_tasks(rq))</span>
<span class='curline'><a href='../S/451.html#L1942'>rq</a>               1942 sched/deadline.c 		if (pick_dl_task(rq, p, cpu))</span>
<span class='curline'><a href='../S/451.html#L2042'>rq</a>               2042 sched/deadline.c static struct rq *find_lock_later_rq(struct task_struct *task, struct rq *rq)</span>
<span class='curline'><a href='../S/451.html#L2044'>rq</a>               2044 sched/deadline.c 	struct rq *later_rq = NULL;</span>
<span class='curline'><a href='../S/451.html#L2051'>rq</a>               2051 sched/deadline.c 		if ((cpu == -1) || (cpu == rq-&gt;cpu))</span>
<span class='curline'><a href='../S/451.html#L2069'>rq</a>               2069 sched/deadline.c 		if (double_lock_balance(rq, later_rq)) {</span>
<span class='curline'><a href='../S/451.html#L2070'>rq</a>               2070 sched/deadline.c 			if (unlikely(task_rq(task) != rq ||</span>
<span class='curline'><a href='../S/451.html#L2072'>rq</a>               2072 sched/deadline.c 				     task_running(rq, task) ||</span>
<span class='curline'><a href='../S/451.html#L2075'>rq</a>               2075 sched/deadline.c 				double_unlock_balance(rq, later_rq);</span>
<span class='curline'><a href='../S/451.html#L2092'>rq</a>               2092 sched/deadline.c 		double_unlock_balance(rq, later_rq);</span>
<span class='curline'><a href='../S/451.html#L2099'>rq</a>               2099 sched/deadline.c static struct task_struct *pick_next_pushable_dl_task(struct rq *rq)</span>
<span class='curline'><a href='../S/451.html#L2103'>rq</a>               2103 sched/deadline.c 	if (!has_pushable_dl_tasks(rq))</span>
<span class='curline'><a href='../S/451.html#L2106'>rq</a>               2106 sched/deadline.c 	p = rb_entry(rq-&gt;dl.pushable_dl_tasks_root.rb_leftmost,</span>
<span class='curline'><a href='../S/451.html#L2109'>rq</a>               2109 sched/deadline.c 	BUG_ON(rq-&gt;cpu != task_cpu(p));</span>
<span class='curline'><a href='../S/451.html#L2110'>rq</a>               2110 sched/deadline.c 	BUG_ON(task_current(rq, p));</span>
<span class='curline'><a href='../S/451.html#L2124'>rq</a>               2124 sched/deadline.c static int push_dl_task(struct rq *rq)</span>
<span class='curline'><a href='../S/451.html#L2127'>rq</a>               2127 sched/deadline.c 	struct rq *later_rq;</span>
<span class='curline'><a href='../S/451.html#L2130'>rq</a>               2130 sched/deadline.c 	if (!rq-&gt;dl.overloaded)</span>
<span class='curline'><a href='../S/451.html#L2133'>rq</a>               2133 sched/deadline.c 	next_task = pick_next_pushable_dl_task(rq);</span>
<span class='curline'><a href='../S/451.html#L2138'>rq</a>               2138 sched/deadline.c 	if (WARN_ON(next_task == rq-&gt;curr))</span>
<span class='curline'><a href='../S/451.html#L2146'>rq</a>               2146 sched/deadline.c 	if (dl_task(rq-&gt;curr) &amp;&amp;</span>
<span class='curline'><a href='../S/451.html#L2147'>rq</a>               2147 sched/deadline.c 	    dl_time_before(next_task-&gt;dl.deadline, rq-&gt;curr-&gt;dl.deadline) &amp;&amp;</span>
<span class='curline'><a href='../S/451.html#L2148'>rq</a>               2148 sched/deadline.c 	    rq-&gt;curr-&gt;nr_cpus_allowed &gt; 1) {</span>
<span class='curline'><a href='../S/451.html#L2149'>rq</a>               2149 sched/deadline.c 		resched_curr(rq);</span>
<span class='curline'><a href='../S/451.html#L2157'>rq</a>               2157 sched/deadline.c 	later_rq = find_lock_later_rq(next_task, rq);</span>
<span class='curline'><a href='../S/451.html#L2166'>rq</a>               2166 sched/deadline.c 		task = pick_next_pushable_dl_task(rq);</span>
<span class='curline'><a href='../S/451.html#L2184'>rq</a>               2184 sched/deadline.c 	deactivate_task(rq, next_task, 0);</span>
<span class='curline'><a href='../S/451.html#L2197'>rq</a>               2197 sched/deadline.c 	double_unlock_balance(rq, later_rq);</span>
<span class='curline'><a href='../S/451.html#L2205'>rq</a>               2205 sched/deadline.c static void push_dl_tasks(struct rq *rq)</span>
<span class='curline'><a href='../S/451.html#L2208'>rq</a>               2208 sched/deadline.c 	while (push_dl_task(rq))</span>
<span class='curline'><a href='../S/451.html#L2212'>rq</a>               2212 sched/deadline.c static void pull_dl_task(struct rq *this_rq)</span>
<span class='curline'><a href='../S/451.html#L2217'>rq</a>               2217 sched/deadline.c 	struct rq *src_rq;</span>
<span class='curline'><a href='../S/451.html#L2297'>rq</a>               2297 sched/deadline.c static void task_woken_dl(struct rq *rq, struct task_struct *p)</span>
<span class='curline'><a href='../S/451.html#L2299'>rq</a>               2299 sched/deadline.c 	if (!task_running(rq, p) &amp;&amp;</span>
<span class='curline'><a href='../S/451.html#L2300'>rq</a>               2300 sched/deadline.c 	    !test_tsk_need_resched(rq-&gt;curr) &amp;&amp;</span>
<span class='curline'><a href='../S/451.html#L2302'>rq</a>               2302 sched/deadline.c 	    dl_task(rq-&gt;curr) &amp;&amp;</span>
<span class='curline'><a href='../S/451.html#L2303'>rq</a>               2303 sched/deadline.c 	    (rq-&gt;curr-&gt;nr_cpus_allowed &lt; 2 ||</span>
<span class='curline'><a href='../S/451.html#L2304'>rq</a>               2304 sched/deadline.c 	     !dl_entity_preempt(&amp;p-&gt;dl, &amp;rq-&gt;curr-&gt;dl))) {</span>
<span class='curline'><a href='../S/451.html#L2305'>rq</a>               2305 sched/deadline.c 		push_dl_tasks(rq);</span>
<span class='curline'><a href='../S/451.html#L2313'>rq</a>               2313 sched/deadline.c 	struct rq *rq;</span>
<span class='curline'><a href='../S/451.html#L2317'>rq</a>               2317 sched/deadline.c 	rq = task_rq(p);</span>
<span class='curline'><a href='../S/451.html#L2318'>rq</a>               2318 sched/deadline.c 	src_rd = rq-&gt;rd;</span>
<span class='curline'><a href='../S/451.html#L2328'>rq</a>               2328 sched/deadline.c 		src_dl_b = dl_bw_of(cpu_of(rq));</span>
<span class='curline'><a href='../S/451.html#L2343'>rq</a>               2343 sched/deadline.c static void rq_online_dl(struct rq *rq)</span>
<span class='curline'><a href='../S/451.html#L2345'>rq</a>               2345 sched/deadline.c 	if (rq-&gt;dl.overloaded)</span>
<span class='curline'><a href='../S/451.html#L2346'>rq</a>               2346 sched/deadline.c 		dl_set_overload(rq);</span>
<span class='curline'><a href='../S/451.html#L2348'>rq</a>               2348 sched/deadline.c 	cpudl_set_freecpu(&amp;rq-&gt;rd-&gt;cpudl, rq-&gt;cpu);</span>
<span class='curline'><a href='../S/451.html#L2349'>rq</a>               2349 sched/deadline.c 	if (rq-&gt;dl.dl_nr_running &gt; 0)</span>
<span class='curline'><a href='../S/451.html#L2350'>rq</a>               2350 sched/deadline.c 		cpudl_set(&amp;rq-&gt;rd-&gt;cpudl, rq-&gt;cpu, rq-&gt;dl.earliest_dl.curr);</span>
<span class='curline'><a href='../S/451.html#L2354'>rq</a>               2354 sched/deadline.c static void rq_offline_dl(struct rq *rq)</span>
<span class='curline'><a href='../S/451.html#L2356'>rq</a>               2356 sched/deadline.c 	if (rq-&gt;dl.overloaded)</span>
<span class='curline'><a href='../S/451.html#L2357'>rq</a>               2357 sched/deadline.c 		dl_clear_overload(rq);</span>
<span class='curline'><a href='../S/451.html#L2359'>rq</a>               2359 sched/deadline.c 	cpudl_clear(&amp;rq-&gt;rd-&gt;cpudl, rq-&gt;cpu);</span>
<span class='curline'><a href='../S/451.html#L2360'>rq</a>               2360 sched/deadline.c 	cpudl_clear_freecpu(&amp;rq-&gt;rd-&gt;cpudl, rq-&gt;cpu);</span>
<span class='curline'><a href='../S/451.html#L2375'>rq</a>               2375 sched/deadline.c 	struct rq *rq;</span>
<span class='curline'><a href='../S/451.html#L2384'>rq</a>               2384 sched/deadline.c 	rq = __task_rq_lock(p, &amp;rf);</span>
<span class='curline'><a href='../S/451.html#L2386'>rq</a>               2386 sched/deadline.c 	dl_b = &amp;rq-&gt;rd-&gt;dl_bw;</span>
<span class='curline'><a href='../S/451.html#L2389'>rq</a>               2389 sched/deadline.c 	__dl_add(dl_b, p-&gt;dl.dl_bw, cpumask_weight(rq-&gt;rd-&gt;span));</span>
<span class='curline'><a href='../S/451.html#L2393'>rq</a>               2393 sched/deadline.c 	task_rq_unlock(rq, p, &amp;rf);</span>
<span class='curline'><a href='../S/451.html#L2407'>rq</a>               2407 sched/deadline.c static void switched_from_dl(struct rq *rq, struct task_struct *p)</span>
<span class='curline'><a href='../S/451.html#L2428'>rq</a>               2428 sched/deadline.c 			sub_running_bw(&amp;p-&gt;dl, &amp;rq-&gt;dl);</span>
<span class='curline'><a href='../S/451.html#L2429'>rq</a>               2429 sched/deadline.c 		sub_rq_bw(&amp;p-&gt;dl, &amp;rq-&gt;dl);</span>
<span class='curline'><a href='../S/451.html#L2445'>rq</a>               2445 sched/deadline.c 	if (!task_on_rq_queued(p) || rq-&gt;dl.dl_nr_running)</span>
<span class='curline'><a href='../S/451.html#L2448'>rq</a>               2448 sched/deadline.c 	deadline_queue_pull_task(rq);</span>
<span class='curline'><a href='../S/451.html#L2455'>rq</a>               2455 sched/deadline.c static void switched_to_dl(struct rq *rq, struct task_struct *p)</span>
<span class='curline'><a href='../S/451.html#L2462'>rq</a>               2462 sched/deadline.c 		add_rq_bw(&amp;p-&gt;dl, &amp;rq-&gt;dl);</span>
<span class='curline'><a href='../S/451.html#L2467'>rq</a>               2467 sched/deadline.c 	if (rq-&gt;curr != p) {</span>
<span class='curline'><a href='../S/451.html#L2469'>rq</a>               2469 sched/deadline.c 		if (p-&gt;nr_cpus_allowed &gt; 1 &amp;&amp; rq-&gt;dl.overloaded)</span>
<span class='curline'><a href='../S/451.html#L2470'>rq</a>               2470 sched/deadline.c 			deadline_queue_push_tasks(rq);</span>
<span class='curline'><a href='../S/451.html#L2472'>rq</a>               2472 sched/deadline.c 		if (dl_task(rq-&gt;curr))</span>
<span class='curline'><a href='../S/451.html#L2473'>rq</a>               2473 sched/deadline.c 			check_preempt_curr_dl(rq, p, 0);</span>
<span class='curline'><a href='../S/451.html#L2475'>rq</a>               2475 sched/deadline.c 			resched_curr(rq);</span>
<span class='curline'><a href='../S/451.html#L2483'>rq</a>               2483 sched/deadline.c static void prio_changed_dl(struct rq *rq, struct task_struct *p,</span>
<span class='curline'><a href='../S/451.html#L2486'>rq</a>               2486 sched/deadline.c 	if (task_on_rq_queued(p) || rq-&gt;curr == p) {</span>
<span class='curline'><a href='../S/451.html#L2494'>rq</a>               2494 sched/deadline.c 		if (!rq-&gt;dl.overloaded)</span>
<span class='curline'><a href='../S/451.html#L2495'>rq</a>               2495 sched/deadline.c 			deadline_queue_pull_task(rq);</span>
<span class='curline'><a href='../S/451.html#L2502'>rq</a>               2502 sched/deadline.c 		if (dl_time_before(rq-&gt;dl.earliest_dl.curr, p-&gt;dl.deadline))</span>
<span class='curline'><a href='../S/451.html#L2503'>rq</a>               2503 sched/deadline.c 			resched_curr(rq);</span>
<span class='curline'><a href='../S/451.html#L2510'>rq</a>               2510 sched/deadline.c 		resched_curr(rq);</span>
<span class='curline'><a href='../S/460.html#L508'>rq</a>                508 sched/debug.c  print_task(struct seq_file *m, struct rq *rq, struct task_struct *p)</span>
<span class='curline'><a href='../S/460.html#L510'>rq</a>                510 sched/debug.c  	if (rq-&gt;curr == p)</span>
<span class='curline'><a href='../S/460.html#L536'>rq</a>                536 sched/debug.c  static void print_rq(struct seq_file *m, struct rq *rq, int rq_cpu)</span>
<span class='curline'><a href='../S/460.html#L552'>rq</a>                552 sched/debug.c  		print_task(m, rq, p);</span>
<span class='curline'><a href='../S/460.html#L561'>rq</a>                561 sched/debug.c  	struct rq *rq = cpu_rq(cpu);</span>
<span class='curline'><a href='../S/460.html#L575'>rq</a>                575 sched/debug.c  	raw_spin_lock_irqsave(&amp;rq-&gt;lock, flags);</span>
<span class='curline'><a href='../S/460.html#L583'>rq</a>                583 sched/debug.c  	raw_spin_unlock_irqrestore(&amp;rq-&gt;lock, flags);</span>
<span class='curline'><a href='../S/460.html#L689'>rq</a>                689 sched/debug.c  	struct rq *rq = cpu_rq(cpu);</span>
<span class='curline'><a href='../S/460.html#L704'>rq</a>                704 sched/debug.c  	if (sizeof(rq-&gt;x) == 4)						\</span>
<span class='curline'><a href='../S/460.html#L705'>rq</a>                705 sched/debug.c  		SEQ_printf(m, "  .%-30s: %ld\n", #x, (long)(rq-&gt;x));	\</span>
<span class='curline'><a href='../S/460.html#L707'>rq</a>                707 sched/debug.c  		SEQ_printf(m, "  .%-30s: %Ld\n", #x, (long long)(rq-&gt;x));\</span>
<span class='curline'><a href='../S/460.html#L711'>rq</a>                711 sched/debug.c  	SEQ_printf(m, "  .%-30s: %Ld.%06ld\n", #x, SPLIT_NS(rq-&gt;x))</span>
<span class='curline'><a href='../S/460.html#L717'>rq</a>                717 sched/debug.c  	SEQ_printf(m, "  .%-30s: %ld\n", "curr-&gt;pid", (long)(task_pid_nr(rq-&gt;curr)));</span>
<span class='curline'><a href='../S/460.html#L724'>rq</a>                724 sched/debug.c  #define P64(n) SEQ_printf(m, "  .%-30s: %Ld\n", #n, rq-&gt;n);</span>
<span class='curline'><a href='../S/460.html#L730'>rq</a>                730 sched/debug.c  #define P(n) SEQ_printf(m, "  .%-30s: %d\n", #n, schedstat_val(rq-&gt;n));</span>
<span class='curline'><a href='../S/460.html#L744'>rq</a>                744 sched/debug.c  	print_rq(m, rq, cpu);</span>
<span class='curline'><a href='../S/464.html#L307'>rq</a>                307 sched/fair.c   	struct rq *rq = rq_of(cfs_rq);</span>
<span class='curline'><a href='../S/464.html#L308'>rq</a>                308 sched/fair.c   	int cpu = cpu_of(rq);</span>
<span class='curline'><a href='../S/464.html#L311'>rq</a>                311 sched/fair.c   		return rq-&gt;tmp_alone_branch == &amp;rq-&gt;leaf_cfs_rq_list;</span>
<span class='curline'><a href='../S/464.html#L339'>rq</a>                339 sched/fair.c   		rq-&gt;tmp_alone_branch = &amp;rq-&gt;leaf_cfs_rq_list;</span>
<span class='curline'><a href='../S/464.html#L349'>rq</a>                349 sched/fair.c   			&amp;rq-&gt;leaf_cfs_rq_list);</span>
<span class='curline'><a href='../S/464.html#L354'>rq</a>                354 sched/fair.c   		rq-&gt;tmp_alone_branch = &amp;rq-&gt;leaf_cfs_rq_list;</span>
<span class='curline'><a href='../S/464.html#L364'>rq</a>                364 sched/fair.c   	list_add_rcu(&amp;cfs_rq-&gt;leaf_cfs_rq_list, rq-&gt;tmp_alone_branch);</span>
<span class='curline'><a href='../S/464.html#L369'>rq</a>                369 sched/fair.c   	rq-&gt;tmp_alone_branch = &amp;cfs_rq-&gt;leaf_cfs_rq_list;</span>
<span class='curline'><a href='../S/464.html#L376'>rq</a>                376 sched/fair.c   		struct rq *rq = rq_of(cfs_rq);</span>
<span class='curline'><a href='../S/464.html#L385'>rq</a>                385 sched/fair.c   		if (rq-&gt;tmp_alone_branch == &amp;cfs_rq-&gt;leaf_cfs_rq_list)</span>
<span class='curline'><a href='../S/464.html#L386'>rq</a>                386 sched/fair.c   			rq-&gt;tmp_alone_branch = cfs_rq-&gt;leaf_cfs_rq_list.prev;</span>
<span class='curline'><a href='../S/464.html#L393'>rq</a>                393 sched/fair.c   static inline void assert_list_leaf_cfs_rq(struct rq *rq)</span>
<span class='curline'><a href='../S/464.html#L395'>rq</a>                395 sched/fair.c   	SCHED_WARN_ON(rq-&gt;tmp_alone_branch != &amp;rq-&gt;leaf_cfs_rq_list);</span>
<span class='curline'><a href='../S/464.html#L399'>rq</a>                399 sched/fair.c   #define for_each_leaf_cfs_rq_safe(rq, cfs_rq, pos)			\</span>
<span class='curline'><a href='../S/464.html#L400'>rq</a>                400 sched/fair.c   	list_for_each_entry_safe(cfs_rq, pos, &amp;rq-&gt;leaf_cfs_rq_list,	\</span>
<span class='curline'><a href='../S/464.html#L468'>rq</a>                468 sched/fair.c   	struct rq *rq = task_rq(p);</span>
<span class='curline'><a href='../S/464.html#L470'>rq</a>                470 sched/fair.c   	return &amp;rq-&gt;cfs;</span>
<span class='curline'><a href='../S/464.html#L494'>rq</a>                494 sched/fair.c   static inline void assert_list_leaf_cfs_rq(struct rq *rq)</span>
<span class='curline'><a href='../S/464.html#L498'>rq</a>                498 sched/fair.c   #define for_each_leaf_cfs_rq_safe(rq, cfs_rq, pos)	\</span>
<span class='curline'><a href='../S/464.html#L499'>rq</a>                499 sched/fair.c   		for (cfs_rq = &amp;rq-&gt;cfs, pos = NULL; cfs_rq; cfs_rq = pos)</span>
<span class='curline'><a href='../S/464.html#L895'>rq</a>                895 sched/fair.c   static void update_curr_fair(struct rq *rq)</span>
<span class='curline'><a href='../S/464.html#L897'>rq</a>                897 sched/fair.c   	update_curr(cfs_rq_of(&amp;rq-&gt;curr-&gt;se));</span>
<span class='curline'><a href='../S/464.html#L1218'>rq</a>               1218 sched/fair.c   static void account_numa_enqueue(struct rq *rq, struct task_struct *p)</span>
<span class='curline'><a href='../S/464.html#L1220'>rq</a>               1220 sched/fair.c   	rq-&gt;nr_numa_running += (p-&gt;numa_preferred_nid != NUMA_NO_NODE);</span>
<span class='curline'><a href='../S/464.html#L1221'>rq</a>               1221 sched/fair.c   	rq-&gt;nr_preferred_running += (p-&gt;numa_preferred_nid == task_node(p));</span>
<span class='curline'><a href='../S/464.html#L1224'>rq</a>               1224 sched/fair.c   static void account_numa_dequeue(struct rq *rq, struct task_struct *p)</span>
<span class='curline'><a href='../S/464.html#L1226'>rq</a>               1226 sched/fair.c   	rq-&gt;nr_numa_running -= (p-&gt;numa_preferred_nid != NUMA_NO_NODE);</span>
<span class='curline'><a href='../S/464.html#L1227'>rq</a>               1227 sched/fair.c   	rq-&gt;nr_preferred_running -= (p-&gt;numa_preferred_nid == task_node(p));</span>
<span class='curline'><a href='../S/464.html#L1569'>rq</a>               1569 sched/fair.c   static unsigned long cpu_load(struct rq *rq);</span>
<span class='curline'><a href='../S/464.html#L1570'>rq</a>               1570 sched/fair.c   static unsigned long cpu_runnable(struct rq *rq);</span>
<span class='curline'><a href='../S/464.html#L1633'>rq</a>               1633 sched/fair.c   		struct rq *rq = cpu_rq(cpu);</span>
<span class='curline'><a href='../S/464.html#L1635'>rq</a>               1635 sched/fair.c   		ns-&gt;load += cpu_load(rq);</span>
<span class='curline'><a href='../S/464.html#L1636'>rq</a>               1636 sched/fair.c   		ns-&gt;runnable += cpu_runnable(rq);</span>
<span class='curline'><a href='../S/464.html#L1638'>rq</a>               1638 sched/fair.c   		ns-&gt;nr_running += rq-&gt;cfs.h_nr_running;</span>
<span class='curline'><a href='../S/464.html#L1641'>rq</a>               1641 sched/fair.c   		if (find_idle &amp;&amp; !rq-&gt;nr_running &amp;&amp; idle_cpu(cpu)) {</span>
<span class='curline'><a href='../S/464.html#L1642'>rq</a>               1642 sched/fair.c   			if (READ_ONCE(rq-&gt;numa_migrate_on) ||</span>
<span class='curline'><a href='../S/464.html#L1665'>rq</a>               1665 sched/fair.c   	struct rq *rq = cpu_rq(env-&gt;dst_cpu);</span>
<span class='curline'><a href='../S/464.html#L1668'>rq</a>               1668 sched/fair.c   	if (env-&gt;best_cpu != env-&gt;dst_cpu &amp;&amp; xchg(&amp;rq-&gt;numa_migrate_on, 1)) {</span>
<span class='curline'><a href='../S/464.html#L1680'>rq</a>               1680 sched/fair.c   			rq = cpu_rq(env-&gt;dst_cpu);</span>
<span class='curline'><a href='../S/464.html#L1681'>rq</a>               1681 sched/fair.c   			if (!xchg(&amp;rq-&gt;numa_migrate_on, 1))</span>
<span class='curline'><a href='../S/464.html#L1695'>rq</a>               1695 sched/fair.c   		rq = cpu_rq(env-&gt;best_cpu);</span>
<span class='curline'><a href='../S/464.html#L1696'>rq</a>               1696 sched/fair.c   		WRITE_ONCE(rq-&gt;numa_migrate_on, 0);</span>
<span class='curline'><a href='../S/464.html#L1754'>rq</a>               1754 sched/fair.c   	struct rq *dst_rq = cpu_rq(env-&gt;dst_cpu);</span>
<span class='curline'><a href='../S/464.html#L2004'>rq</a>               2004 sched/fair.c   	struct rq *best_rq;</span>
<span class='curline'><a href='../S/464.html#L2924'>rq</a>               2924 sched/fair.c   static void task_tick_numa(struct rq *rq, struct task_struct *curr)</span>
<span class='curline'><a href='../S/464.html#L2989'>rq</a>               2989 sched/fair.c   static void task_tick_numa(struct rq *rq, struct task_struct *curr)</span>
<span class='curline'><a href='../S/464.html#L2993'>rq</a>               2993 sched/fair.c   static inline void account_numa_enqueue(struct rq *rq, struct task_struct *p)</span>
<span class='curline'><a href='../S/464.html#L2997'>rq</a>               2997 sched/fair.c   static inline void account_numa_dequeue(struct rq *rq, struct task_struct *p)</span>
<span class='curline'><a href='../S/464.html#L3013'>rq</a>               3013 sched/fair.c   		struct rq *rq = rq_of(cfs_rq);</span>
<span class='curline'><a href='../S/464.html#L3015'>rq</a>               3015 sched/fair.c   		account_numa_enqueue(rq, task_of(se));</span>
<span class='curline'><a href='../S/464.html#L3016'>rq</a>               3016 sched/fair.c   		list_add(&amp;se-&gt;group_node, &amp;rq-&gt;cfs_tasks);</span>
<span class='curline'><a href='../S/464.html#L3289'>rq</a>               3289 sched/fair.c   	struct rq *rq = rq_of(cfs_rq);</span>
<span class='curline'><a href='../S/464.html#L3291'>rq</a>               3291 sched/fair.c   	if (&amp;rq-&gt;cfs == cfs_rq) {</span>
<span class='curline'><a href='../S/464.html#L3306'>rq</a>               3306 sched/fair.c   		cpufreq_update_util(rq, flags);</span>
<span class='curline'><a href='../S/464.html#L3908'>rq</a>               3908 sched/fair.c   static int newidle_balance(struct rq *this_rq, struct rq_flags *rf);</span>
<span class='curline'><a href='../S/464.html#L4083'>rq</a>               4083 sched/fair.c   static inline void update_misfit_status(struct task_struct *p, struct rq *rq)</span>
<span class='curline'><a href='../S/464.html#L4087'>rq</a>               4087 sched/fair.c   	trace_android_rvh_update_misfit_status(p, rq, &amp;need_update);</span>
<span class='curline'><a href='../S/464.html#L4092'>rq</a>               4092 sched/fair.c   		rq-&gt;misfit_task_load = 0;</span>
<span class='curline'><a href='../S/464.html#L4096'>rq</a>               4096 sched/fair.c   	if (task_fits_capacity(p, capacity_of(cpu_of(rq)))) {</span>
<span class='curline'><a href='../S/464.html#L4097'>rq</a>               4097 sched/fair.c   		rq-&gt;misfit_task_load = 0;</span>
<span class='curline'><a href='../S/464.html#L4105'>rq</a>               4105 sched/fair.c   	rq-&gt;misfit_task_load = max_t(unsigned long, task_h_load(p), 1);</span>
<span class='curline'><a href='../S/464.html#L4126'>rq</a>               4126 sched/fair.c   static inline int newidle_balance(struct rq *rq, struct rq_flags *rf)</span>
<span class='curline'><a href='../S/464.html#L4140'>rq</a>               4140 sched/fair.c   static inline void update_misfit_status(struct task_struct *p, struct rq *rq) {}</span>
<span class='curline'><a href='../S/464.html#L4773'>rq</a>               4773 sched/fair.c   	struct rq *rq = data;</span>
<span class='curline'><a href='../S/464.html#L4774'>rq</a>               4774 sched/fair.c   	struct cfs_rq *cfs_rq = tg-&gt;cfs_rq[cpu_of(rq)];</span>
<span class='curline'><a href='../S/464.html#L4778'>rq</a>               4778 sched/fair.c   		cfs_rq-&gt;throttled_clock_task_time += rq_clock_task(rq) -</span>
<span class='curline'><a href='../S/464.html#L4791'>rq</a>               4791 sched/fair.c   	struct rq *rq = data;</span>
<span class='curline'><a href='../S/464.html#L4792'>rq</a>               4792 sched/fair.c   	struct cfs_rq *cfs_rq = tg-&gt;cfs_rq[cpu_of(rq)];</span>
<span class='curline'><a href='../S/464.html#L4796'>rq</a>               4796 sched/fair.c   		cfs_rq-&gt;throttled_clock_task = rq_clock_task(rq);</span>
<span class='curline'><a href='../S/464.html#L4806'>rq</a>               4806 sched/fair.c   	struct rq *rq = rq_of(cfs_rq);</span>
<span class='curline'><a href='../S/464.html#L4836'>rq</a>               4836 sched/fair.c   	walk_tg_tree_from(cfs_rq-&gt;tg, tg_throttle_down, tg_nop, (void *)rq);</span>
<span class='curline'><a href='../S/464.html#L4862'>rq</a>               4862 sched/fair.c   		sub_nr_running(rq, task_delta);</span>
<span class='curline'><a href='../S/464.html#L4869'>rq</a>               4869 sched/fair.c   	cfs_rq-&gt;throttled_clock = rq_clock(rq);</span>
<span class='curline'><a href='../S/464.html#L4875'>rq</a>               4875 sched/fair.c   	struct rq *rq = rq_of(cfs_rq);</span>
<span class='curline'><a href='../S/464.html#L4880'>rq</a>               4880 sched/fair.c   	se = cfs_rq-&gt;tg-&gt;se[cpu_of(rq)];</span>
<span class='curline'><a href='../S/464.html#L4884'>rq</a>               4884 sched/fair.c   	update_rq_clock(rq);</span>
<span class='curline'><a href='../S/464.html#L4887'>rq</a>               4887 sched/fair.c   	cfs_b-&gt;throttled_time += rq_clock(rq) - cfs_rq-&gt;throttled_clock;</span>
<span class='curline'><a href='../S/464.html#L4892'>rq</a>               4892 sched/fair.c   	walk_tg_tree_from(cfs_rq-&gt;tg, tg_nop, tg_unthrottle_up, (void *)rq);</span>
<span class='curline'><a href='../S/464.html#L4936'>rq</a>               4936 sched/fair.c   	add_nr_running(rq, task_delta);</span>
<span class='curline'><a href='../S/464.html#L4951'>rq</a>               4951 sched/fair.c   	assert_list_leaf_cfs_rq(rq);</span>
<span class='curline'><a href='../S/464.html#L4954'>rq</a>               4954 sched/fair.c   	if (rq-&gt;curr == rq-&gt;idle &amp;&amp; rq-&gt;cfs.nr_running)</span>
<span class='curline'><a href='../S/464.html#L4955'>rq</a>               4955 sched/fair.c   		resched_curr(rq);</span>
<span class='curline'><a href='../S/464.html#L4966'>rq</a>               4966 sched/fair.c   		struct rq *rq = rq_of(cfs_rq);</span>
<span class='curline'><a href='../S/464.html#L4969'>rq</a>               4969 sched/fair.c   		rq_lock_irqsave(rq, &amp;rf);</span>
<span class='curline'><a href='../S/464.html#L4991'>rq</a>               4991 sched/fair.c   		rq_unlock_irqrestore(rq, &amp;rf);</span>
<span class='curline'><a href='../S/464.html#L5353'>rq</a>               5353 sched/fair.c   static void __maybe_unused update_runtime_enabled(struct rq *rq)</span>
<span class='curline'><a href='../S/464.html#L5357'>rq</a>               5357 sched/fair.c   	lockdep_assert_held(&amp;rq-&gt;lock);</span>
<span class='curline'><a href='../S/464.html#L5362'>rq</a>               5362 sched/fair.c   		struct cfs_rq *cfs_rq = tg-&gt;cfs_rq[cpu_of(rq)];</span>
<span class='curline'><a href='../S/464.html#L5372'>rq</a>               5372 sched/fair.c   static void __maybe_unused unthrottle_offline_cfs_rqs(struct rq *rq)</span>
<span class='curline'><a href='../S/464.html#L5376'>rq</a>               5376 sched/fair.c   	lockdep_assert_held(&amp;rq-&gt;lock);</span>
<span class='curline'><a href='../S/464.html#L5380'>rq</a>               5380 sched/fair.c   		struct cfs_rq *cfs_rq = tg-&gt;cfs_rq[cpu_of(rq)];</span>
<span class='curline'><a href='../S/464.html#L5442'>rq</a>               5442 sched/fair.c   static inline void update_runtime_enabled(struct rq *rq) {}</span>
<span class='curline'><a href='../S/464.html#L5443'>rq</a>               5443 sched/fair.c   static inline void unthrottle_offline_cfs_rqs(struct rq *rq) {}</span>
<span class='curline'><a href='../S/464.html#L5452'>rq</a>               5452 sched/fair.c   static void hrtick_start_fair(struct rq *rq, struct task_struct *p)</span>
<span class='curline'><a href='../S/464.html#L5457'>rq</a>               5457 sched/fair.c   	SCHED_WARN_ON(task_rq(p) != rq);</span>
<span class='curline'><a href='../S/464.html#L5459'>rq</a>               5459 sched/fair.c   	if (rq-&gt;cfs.h_nr_running &gt; 1) {</span>
<span class='curline'><a href='../S/464.html#L5465'>rq</a>               5465 sched/fair.c   			if (rq-&gt;curr == p)</span>
<span class='curline'><a href='../S/464.html#L5466'>rq</a>               5466 sched/fair.c   				resched_curr(rq);</span>
<span class='curline'><a href='../S/464.html#L5469'>rq</a>               5469 sched/fair.c   		hrtick_start(rq, delta);</span>
<span class='curline'><a href='../S/464.html#L5478'>rq</a>               5478 sched/fair.c   static void hrtick_update(struct rq *rq)</span>
<span class='curline'><a href='../S/464.html#L5480'>rq</a>               5480 sched/fair.c   	struct task_struct *curr = rq-&gt;curr;</span>
<span class='curline'><a href='../S/464.html#L5482'>rq</a>               5482 sched/fair.c   	if (!hrtick_enabled(rq) || curr-&gt;sched_class != &amp;fair_sched_class)</span>
<span class='curline'><a href='../S/464.html#L5486'>rq</a>               5486 sched/fair.c   		hrtick_start_fair(rq, curr);</span>
<span class='curline'><a href='../S/464.html#L5490'>rq</a>               5490 sched/fair.c   hrtick_start_fair(struct rq *rq, struct task_struct *p)</span>
<span class='curline'><a href='../S/464.html#L5494'>rq</a>               5494 sched/fair.c   static inline void hrtick_update(struct rq *rq)</span>
<span class='curline'><a href='../S/464.html#L5513'>rq</a>               5513 sched/fair.c   static inline void update_overutilized_status(struct rq *rq)</span>
<span class='curline'><a href='../S/464.html#L5515'>rq</a>               5515 sched/fair.c   	if (!READ_ONCE(rq-&gt;rd-&gt;overutilized) &amp;&amp; cpu_overutilized(rq-&gt;cpu)) {</span>
<span class='curline'><a href='../S/464.html#L5516'>rq</a>               5516 sched/fair.c   		WRITE_ONCE(rq-&gt;rd-&gt;overutilized, SG_OVERUTILIZED);</span>
<span class='curline'><a href='../S/464.html#L5517'>rq</a>               5517 sched/fair.c   		trace_sched_overutilized_tp(rq-&gt;rd, SG_OVERUTILIZED);</span>
<span class='curline'><a href='../S/464.html#L5521'>rq</a>               5521 sched/fair.c   static inline void update_overutilized_status(struct rq *rq) { }</span>
<span class='curline'><a href='../S/464.html#L5525'>rq</a>               5525 sched/fair.c   static int sched_idle_rq(struct rq *rq)</span>
<span class='curline'><a href='../S/464.html#L5527'>rq</a>               5527 sched/fair.c   	return unlikely(rq-&gt;nr_running == rq-&gt;cfs.idle_h_nr_running &amp;&amp;</span>
<span class='curline'><a href='../S/464.html#L5528'>rq</a>               5528 sched/fair.c   			rq-&gt;nr_running);</span>
<span class='curline'><a href='../S/464.html#L5544'>rq</a>               5544 sched/fair.c   enqueue_task_fair(struct rq *rq, struct task_struct *p, int flags)</span>
<span class='curline'><a href='../S/464.html#L5558'>rq</a>               5558 sched/fair.c   	util_est_enqueue(&amp;rq-&gt;cfs, p);</span>
<span class='curline'><a href='../S/464.html#L5568'>rq</a>               5568 sched/fair.c   		cpufreq_update_util(rq, SCHED_CPUFREQ_IOWAIT);</span>
<span class='curline'><a href='../S/464.html#L5586'>rq</a>               5586 sched/fair.c   	trace_android_rvh_enqueue_task_fair(rq, p, flags);</span>
<span class='curline'><a href='../S/464.html#L5610'>rq</a>               5610 sched/fair.c   	add_nr_running(rq, 1);</span>
<span class='curline'><a href='../S/464.html#L5627'>rq</a>               5627 sched/fair.c   		update_overutilized_status(rq);</span>
<span class='curline'><a href='../S/464.html#L5645'>rq</a>               5645 sched/fair.c   	assert_list_leaf_cfs_rq(rq);</span>
<span class='curline'><a href='../S/464.html#L5647'>rq</a>               5647 sched/fair.c   	hrtick_update(rq);</span>
<span class='curline'><a href='../S/464.html#L5657'>rq</a>               5657 sched/fair.c   static void dequeue_task_fair(struct rq *rq, struct task_struct *p, int flags)</span>
<span class='curline'><a href='../S/464.html#L5663'>rq</a>               5663 sched/fair.c   	bool was_sched_idle = sched_idle_rq(rq);</span>
<span class='curline'><a href='../S/464.html#L5665'>rq</a>               5665 sched/fair.c   	util_est_dequeue(&amp;rq-&gt;cfs, p);</span>
<span class='curline'><a href='../S/464.html#L5693'>rq</a>               5693 sched/fair.c   	trace_android_rvh_dequeue_task_fair(rq, p, flags);</span>
<span class='curline'><a href='../S/464.html#L5711'>rq</a>               5711 sched/fair.c   	sub_nr_running(rq, 1);</span>
<span class='curline'><a href='../S/464.html#L5714'>rq</a>               5714 sched/fair.c   	if (unlikely(!was_sched_idle &amp;&amp; sched_idle_rq(rq)))</span>
<span class='curline'><a href='../S/464.html#L5715'>rq</a>               5715 sched/fair.c   		rq-&gt;next_balance = jiffies;</span>
<span class='curline'><a href='../S/464.html#L5718'>rq</a>               5718 sched/fair.c   	util_est_update(&amp;rq-&gt;cfs, p, task_sleep);</span>
<span class='curline'><a href='../S/464.html#L5719'>rq</a>               5719 sched/fair.c   	hrtick_update(rq);</span>
<span class='curline'><a href='../S/464.html#L5740'>rq</a>               5740 sched/fair.c   static unsigned long cpu_load(struct rq *rq)</span>
<span class='curline'><a href='../S/464.html#L5742'>rq</a>               5742 sched/fair.c   	return cfs_rq_load_avg(&amp;rq-&gt;cfs);</span>
<span class='curline'><a href='../S/464.html#L5758'>rq</a>               5758 sched/fair.c   static unsigned long cpu_load_without(struct rq *rq, struct task_struct *p)</span>
<span class='curline'><a href='../S/464.html#L5764'>rq</a>               5764 sched/fair.c   	if (cpu_of(rq) != task_cpu(p) || !READ_ONCE(p-&gt;se.avg.last_update_time))</span>
<span class='curline'><a href='../S/464.html#L5765'>rq</a>               5765 sched/fair.c   		return cpu_load(rq);</span>
<span class='curline'><a href='../S/464.html#L5767'>rq</a>               5767 sched/fair.c   	cfs_rq = &amp;rq-&gt;cfs;</span>
<span class='curline'><a href='../S/464.html#L5776'>rq</a>               5776 sched/fair.c   static unsigned long cpu_runnable(struct rq *rq)</span>
<span class='curline'><a href='../S/464.html#L5778'>rq</a>               5778 sched/fair.c   	return cfs_rq_runnable_avg(&amp;rq-&gt;cfs);</span>
<span class='curline'><a href='../S/464.html#L5781'>rq</a>               5781 sched/fair.c   static unsigned long cpu_runnable_without(struct rq *rq, struct task_struct *p)</span>
<span class='curline'><a href='../S/464.html#L5787'>rq</a>               5787 sched/fair.c   	if (cpu_of(rq) != task_cpu(p) || !READ_ONCE(p-&gt;se.avg.last_update_time))</span>
<span class='curline'><a href='../S/464.html#L5788'>rq</a>               5788 sched/fair.c   		return cpu_runnable(rq);</span>
<span class='curline'><a href='../S/464.html#L5790'>rq</a>               5790 sched/fair.c   	cfs_rq = &amp;rq-&gt;cfs;</span>
<span class='curline'><a href='../S/464.html#L5976'>rq</a>               5976 sched/fair.c   			struct rq *rq = cpu_rq(i);</span>
<span class='curline'><a href='../S/464.html#L5977'>rq</a>               5977 sched/fair.c   			struct cpuidle_state *idle = idle_get_state(rq);</span>
<span class='curline'><a href='../S/464.html#L5985'>rq</a>               5985 sched/fair.c   				latest_idle_timestamp = rq-&gt;idle_stamp;</span>
<span class='curline'><a href='../S/464.html#L5988'>rq</a>               5988 sched/fair.c   				   rq-&gt;idle_stamp &gt; latest_idle_timestamp) {</span>
<span class='curline'><a href='../S/464.html#L5994'>rq</a>               5994 sched/fair.c   				latest_idle_timestamp = rq-&gt;idle_stamp;</span>
<span class='curline'><a href='../S/464.html#L6093'>rq</a>               6093 sched/fair.c   void __update_idle_core(struct rq *rq)</span>
<span class='curline'><a href='../S/464.html#L6095'>rq</a>               6095 sched/fair.c   	int core = cpu_of(rq);</span>
<span class='curline'><a href='../S/464.html#L6964'>rq</a>               6964 sched/fair.c   balance_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)</span>
<span class='curline'><a href='../S/464.html#L6966'>rq</a>               6966 sched/fair.c   	if (rq-&gt;nr_running)</span>
<span class='curline'><a href='../S/464.html#L6969'>rq</a>               6969 sched/fair.c   	return newidle_balance(rq, rf) != 0;</span>
<span class='curline'><a href='../S/464.html#L7055'>rq</a>               7055 sched/fair.c   static void check_preempt_wakeup(struct rq *rq, struct task_struct *p, int wake_flags)</span>
<span class='curline'><a href='../S/464.html#L7057'>rq</a>               7057 sched/fair.c   	struct task_struct *curr = rq-&gt;curr;</span>
<span class='curline'><a href='../S/464.html#L7112'>rq</a>               7112 sched/fair.c   	trace_android_rvh_check_preempt_wakeup(rq, p, &amp;preempt, &amp;nopreempt,</span>
<span class='curline'><a href='../S/464.html#L7132'>rq</a>               7132 sched/fair.c   	resched_curr(rq);</span>
<span class='curline'><a href='../S/464.html#L7142'>rq</a>               7142 sched/fair.c   	if (unlikely(!se-&gt;on_rq || curr == rq-&gt;idle))</span>
<span class='curline'><a href='../S/464.html#L7150'>rq</a>               7150 sched/fair.c   pick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)</span>
<span class='curline'><a href='../S/464.html#L7152'>rq</a>               7152 sched/fair.c   	struct cfs_rq *cfs_rq = &amp;rq-&gt;cfs;</span>
<span class='curline'><a href='../S/464.html#L7159'>rq</a>               7159 sched/fair.c   	if (!sched_fair_runnable(rq))</span>
<span class='curline'><a href='../S/464.html#L7196'>rq</a>               7196 sched/fair.c   				cfs_rq = &amp;rq-&gt;cfs;</span>
<span class='curline'><a href='../S/464.html#L7210'>rq</a>               7210 sched/fair.c   	trace_android_rvh_replace_next_task_fair(rq, &amp;p, &amp;se, &amp;repick, false, prev);</span>
<span class='curline'><a href='../S/464.html#L7241'>rq</a>               7241 sched/fair.c   		put_prev_task(rq, prev);</span>
<span class='curline'><a href='../S/464.html#L7243'>rq</a>               7243 sched/fair.c   	trace_android_rvh_replace_next_task_fair(rq, &amp;p, &amp;se, &amp;repick, true, prev);</span>
<span class='curline'><a href='../S/464.html#L7265'>rq</a>               7265 sched/fair.c   	list_move(&amp;p-&gt;se.group_node, &amp;rq-&gt;cfs_tasks);</span>
<span class='curline'><a href='../S/464.html#L7268'>rq</a>               7268 sched/fair.c   	if (hrtick_enabled(rq))</span>
<span class='curline'><a href='../S/464.html#L7269'>rq</a>               7269 sched/fair.c   		hrtick_start_fair(rq, p);</span>
<span class='curline'><a href='../S/464.html#L7271'>rq</a>               7271 sched/fair.c   	update_misfit_status(p, rq);</span>
<span class='curline'><a href='../S/464.html#L7279'>rq</a>               7279 sched/fair.c   	new_tasks = newidle_balance(rq, rf);</span>
<span class='curline'><a href='../S/464.html#L7296'>rq</a>               7296 sched/fair.c   	update_idle_rq_clock_pelt(rq);</span>
<span class='curline'><a href='../S/464.html#L7301'>rq</a>               7301 sched/fair.c   static struct task_struct *__pick_next_task_fair(struct rq *rq)</span>
<span class='curline'><a href='../S/464.html#L7303'>rq</a>               7303 sched/fair.c   	return pick_next_task_fair(rq, NULL, NULL);</span>
<span class='curline'><a href='../S/464.html#L7309'>rq</a>               7309 sched/fair.c   static void put_prev_task_fair(struct rq *rq, struct task_struct *prev)</span>
<span class='curline'><a href='../S/464.html#L7325'>rq</a>               7325 sched/fair.c   static void yield_task_fair(struct rq *rq)</span>
<span class='curline'><a href='../S/464.html#L7327'>rq</a>               7327 sched/fair.c   	struct task_struct *curr = rq-&gt;curr;</span>
<span class='curline'><a href='../S/464.html#L7334'>rq</a>               7334 sched/fair.c   	if (unlikely(rq-&gt;nr_running == 1))</span>
<span class='curline'><a href='../S/464.html#L7340'>rq</a>               7340 sched/fair.c   		update_rq_clock(rq);</span>
<span class='curline'><a href='../S/464.html#L7350'>rq</a>               7350 sched/fair.c   		rq_clock_skip_update(rq);</span>
<span class='curline'><a href='../S/464.html#L7356'>rq</a>               7356 sched/fair.c   static bool yield_to_task_fair(struct rq *rq, struct task_struct *p)</span>
<span class='curline'><a href='../S/464.html#L7367'>rq</a>               7367 sched/fair.c   	yield_task_fair(rq);</span>
<span class='curline'><a href='../S/464.html#L7551'>rq</a>               7551 sched/fair.c   	struct rq		*src_rq;</span>
<span class='curline'><a href='../S/464.html#L7555'>rq</a>               7555 sched/fair.c   	struct rq		*dst_rq;</span>
<span class='curline'><a href='../S/464.html#L7951'>rq</a>               7951 sched/fair.c   static void attach_task(struct rq *rq, struct task_struct *p)</span>
<span class='curline'><a href='../S/464.html#L7953'>rq</a>               7953 sched/fair.c   	lockdep_assert_held(&amp;rq-&gt;lock);</span>
<span class='curline'><a href='../S/464.html#L7955'>rq</a>               7955 sched/fair.c   	BUG_ON(task_rq(p) != rq);</span>
<span class='curline'><a href='../S/464.html#L7956'>rq</a>               7956 sched/fair.c   	activate_task(rq, p, ENQUEUE_NOCLOCK);</span>
<span class='curline'><a href='../S/464.html#L7957'>rq</a>               7957 sched/fair.c   	check_preempt_curr(rq, p, 0);</span>
<span class='curline'><a href='../S/464.html#L7964'>rq</a>               7964 sched/fair.c   static void attach_one_task(struct rq *rq, struct task_struct *p)</span>
<span class='curline'><a href='../S/464.html#L7968'>rq</a>               7968 sched/fair.c   	rq_lock(rq, &amp;rf);</span>
<span class='curline'><a href='../S/464.html#L7969'>rq</a>               7969 sched/fair.c   	update_rq_clock(rq);</span>
<span class='curline'><a href='../S/464.html#L7970'>rq</a>               7970 sched/fair.c   	attach_task(rq, p);</span>
<span class='curline'><a href='../S/464.html#L7971'>rq</a>               7971 sched/fair.c   	rq_unlock(rq, &amp;rf);</span>
<span class='curline'><a href='../S/464.html#L8009'>rq</a>               8009 sched/fair.c   static inline bool others_have_blocked(struct rq *rq)</span>
<span class='curline'><a href='../S/464.html#L8011'>rq</a>               8011 sched/fair.c   	if (READ_ONCE(rq-&gt;avg_rt.util_avg))</span>
<span class='curline'><a href='../S/464.html#L8014'>rq</a>               8014 sched/fair.c   	if (READ_ONCE(rq-&gt;avg_dl.util_avg))</span>
<span class='curline'><a href='../S/464.html#L8017'>rq</a>               8017 sched/fair.c   	if (thermal_load_avg(rq))</span>
<span class='curline'><a href='../S/464.html#L8021'>rq</a>               8021 sched/fair.c   	if (READ_ONCE(rq-&gt;avg_irq.util_avg))</span>
<span class='curline'><a href='../S/464.html#L8028'>rq</a>               8028 sched/fair.c   static inline void update_blocked_load_status(struct rq *rq, bool has_blocked)</span>
<span class='curline'><a href='../S/464.html#L8030'>rq</a>               8030 sched/fair.c   	rq-&gt;last_blocked_load_update_tick = jiffies;</span>
<span class='curline'><a href='../S/464.html#L8033'>rq</a>               8033 sched/fair.c   		rq-&gt;has_blocked_load = 0;</span>
<span class='curline'><a href='../S/464.html#L8037'>rq</a>               8037 sched/fair.c   static inline bool others_have_blocked(struct rq *rq) { return false; }</span>
<span class='curline'><a href='../S/464.html#L8038'>rq</a>               8038 sched/fair.c   static inline void update_blocked_load_status(struct rq *rq, bool has_blocked) {}</span>
<span class='curline'><a href='../S/464.html#L8041'>rq</a>               8041 sched/fair.c   static bool __update_blocked_others(struct rq *rq, bool *done)</span>
<span class='curline'><a href='../S/464.html#L8044'>rq</a>               8044 sched/fair.c   	u64 now = rq_clock_pelt(rq);</span>
<span class='curline'><a href='../S/464.html#L8052'>rq</a>               8052 sched/fair.c   	curr_class = rq-&gt;curr-&gt;sched_class;</span>
<span class='curline'><a href='../S/464.html#L8054'>rq</a>               8054 sched/fair.c   	thermal_pressure = arch_scale_thermal_pressure(cpu_of(rq));</span>
<span class='curline'><a href='../S/464.html#L8056'>rq</a>               8056 sched/fair.c   	decayed = update_rt_rq_load_avg(now, rq, curr_class == &amp;rt_sched_class) |</span>
<span class='curline'><a href='../S/464.html#L8057'>rq</a>               8057 sched/fair.c   		  update_dl_rq_load_avg(now, rq, curr_class == &amp;dl_sched_class) |</span>
<span class='curline'><a href='../S/464.html#L8058'>rq</a>               8058 sched/fair.c   		  update_thermal_load_avg(rq_clock_thermal(rq), rq, thermal_pressure) |</span>
<span class='curline'><a href='../S/464.html#L8059'>rq</a>               8059 sched/fair.c   		  update_irq_load_avg(rq, 0);</span>
<span class='curline'><a href='../S/464.html#L8061'>rq</a>               8061 sched/fair.c   	if (others_have_blocked(rq))</span>
<span class='curline'><a href='../S/464.html#L8086'>rq</a>               8086 sched/fair.c   static bool __update_blocked_fair(struct rq *rq, bool *done)</span>
<span class='curline'><a href='../S/464.html#L8090'>rq</a>               8090 sched/fair.c   	int cpu = cpu_of(rq);</span>
<span class='curline'><a href='../S/464.html#L8096'>rq</a>               8096 sched/fair.c   	for_each_leaf_cfs_rq_safe(rq, cfs_rq, pos) {</span>
<span class='curline'><a href='../S/464.html#L8102'>rq</a>               8102 sched/fair.c   			if (cfs_rq == &amp;rq-&gt;cfs)</span>
<span class='curline'><a href='../S/464.html#L8133'>rq</a>               8133 sched/fair.c   	struct rq *rq = rq_of(cfs_rq);</span>
<span class='curline'><a href='../S/464.html#L8134'>rq</a>               8134 sched/fair.c   	struct sched_entity *se = cfs_rq-&gt;tg-&gt;se[cpu_of(rq)];</span>
<span class='curline'><a href='../S/464.html#L8173'>rq</a>               8173 sched/fair.c   static bool __update_blocked_fair(struct rq *rq, bool *done)</span>
<span class='curline'><a href='../S/464.html#L8175'>rq</a>               8175 sched/fair.c   	struct cfs_rq *cfs_rq = &amp;rq-&gt;cfs;</span>
<span class='curline'><a href='../S/464.html#L8194'>rq</a>               8194 sched/fair.c   	struct rq *rq = cpu_rq(cpu);</span>
<span class='curline'><a href='../S/464.html#L8197'>rq</a>               8197 sched/fair.c   	rq_lock_irqsave(rq, &amp;rf);</span>
<span class='curline'><a href='../S/464.html#L8198'>rq</a>               8198 sched/fair.c   	update_rq_clock(rq);</span>
<span class='curline'><a href='../S/464.html#L8200'>rq</a>               8200 sched/fair.c   	decayed |= __update_blocked_others(rq, &amp;done);</span>
<span class='curline'><a href='../S/464.html#L8201'>rq</a>               8201 sched/fair.c   	decayed |= __update_blocked_fair(rq, &amp;done);</span>
<span class='curline'><a href='../S/464.html#L8203'>rq</a>               8203 sched/fair.c   	update_blocked_load_status(rq, !done);</span>
<span class='curline'><a href='../S/464.html#L8205'>rq</a>               8205 sched/fair.c   		cpufreq_update_util(rq, 0);</span>
<span class='curline'><a href='../S/464.html#L8206'>rq</a>               8206 sched/fair.c   	rq_unlock_irqrestore(rq, &amp;rf);</span>
<span class='curline'><a href='../S/464.html#L8272'>rq</a>               8272 sched/fair.c   	struct rq *rq = cpu_rq(cpu);</span>
<span class='curline'><a href='../S/464.html#L8277'>rq</a>               8277 sched/fair.c   	irq = cpu_util_irq(rq);</span>
<span class='curline'><a href='../S/464.html#L8288'>rq</a>               8288 sched/fair.c   	used = READ_ONCE(rq-&gt;avg_rt.util_avg);</span>
<span class='curline'><a href='../S/464.html#L8289'>rq</a>               8289 sched/fair.c   	used += READ_ONCE(rq-&gt;avg_dl.util_avg);</span>
<span class='curline'><a href='../S/464.html#L8290'>rq</a>               8290 sched/fair.c   	used += thermal_load_avg(rq);</span>
<span class='curline'><a href='../S/464.html#L8380'>rq</a>               8380 sched/fair.c   check_cpu_capacity(struct rq *rq, struct sched_domain *sd)</span>
<span class='curline'><a href='../S/464.html#L8382'>rq</a>               8382 sched/fair.c   	return ((rq-&gt;cpu_capacity * sd-&gt;imbalance_pct) &lt;</span>
<span class='curline'><a href='../S/464.html#L8383'>rq</a>               8383 sched/fair.c   				(rq-&gt;cpu_capacity_orig * 100));</span>
<span class='curline'><a href='../S/464.html#L8391'>rq</a>               8391 sched/fair.c   static inline int check_misfit_status(struct rq *rq, struct sched_domain *sd)</span>
<span class='curline'><a href='../S/464.html#L8393'>rq</a>               8393 sched/fair.c   	return rq-&gt;misfit_task_load &amp;&amp;</span>
<span class='curline'><a href='../S/464.html#L8394'>rq</a>               8394 sched/fair.c   		(rq-&gt;cpu_capacity_orig &lt; rq-&gt;rd-&gt;max_cpu_capacity ||</span>
<span class='curline'><a href='../S/464.html#L8395'>rq</a>               8395 sched/fair.c   		 check_cpu_capacity(rq, sd));</span>
<span class='curline'><a href='../S/464.html#L8529'>rq</a>               8529 sched/fair.c   static bool update_nohz_stats(struct rq *rq, bool force)</span>
<span class='curline'><a href='../S/464.html#L8532'>rq</a>               8532 sched/fair.c   	unsigned int cpu = rq-&gt;cpu;</span>
<span class='curline'><a href='../S/464.html#L8534'>rq</a>               8534 sched/fair.c   	if (!rq-&gt;has_blocked_load)</span>
<span class='curline'><a href='../S/464.html#L8540'>rq</a>               8540 sched/fair.c   	if (!force &amp;&amp; !time_after(jiffies, rq-&gt;last_blocked_load_update_tick))</span>
<span class='curline'><a href='../S/464.html#L8545'>rq</a>               8545 sched/fair.c   	return rq-&gt;has_blocked_load;</span>
<span class='curline'><a href='../S/464.html#L8570'>rq</a>               8570 sched/fair.c   		struct rq *rq = cpu_rq(i);</span>
<span class='curline'><a href='../S/464.html#L8572'>rq</a>               8572 sched/fair.c   		if ((env-&gt;flags &amp; LBF_NOHZ_STATS) &amp;&amp; update_nohz_stats(rq, false))</span>
<span class='curline'><a href='../S/464.html#L8575'>rq</a>               8575 sched/fair.c   		sgs-&gt;group_load += cpu_load(rq);</span>
<span class='curline'><a href='../S/464.html#L8577'>rq</a>               8577 sched/fair.c   		sgs-&gt;group_runnable += cpu_runnable(rq);</span>
<span class='curline'><a href='../S/464.html#L8578'>rq</a>               8578 sched/fair.c   		sgs-&gt;sum_h_nr_running += rq-&gt;cfs.h_nr_running;</span>
<span class='curline'><a href='../S/464.html#L8580'>rq</a>               8580 sched/fair.c   		nr_running = rq-&gt;nr_running;</span>
<span class='curline'><a href='../S/464.html#L8590'>rq</a>               8590 sched/fair.c   		sgs-&gt;nr_numa_running += rq-&gt;nr_numa_running;</span>
<span class='curline'><a href='../S/464.html#L8591'>rq</a>               8591 sched/fair.c   		sgs-&gt;nr_preferred_running += rq-&gt;nr_preferred_running;</span>
<span class='curline'><a href='../S/464.html#L8607'>rq</a>               8607 sched/fair.c   		    sgs-&gt;group_misfit_task_load &lt; rq-&gt;misfit_task_load) {</span>
<span class='curline'><a href='../S/464.html#L8608'>rq</a>               8608 sched/fair.c   			sgs-&gt;group_misfit_task_load = rq-&gt;misfit_task_load;</span>
<span class='curline'><a href='../S/464.html#L8764'>rq</a>               8764 sched/fair.c   static inline enum fbq_type fbq_classify_rq(struct rq *rq)</span>
<span class='curline'><a href='../S/464.html#L8766'>rq</a>               8766 sched/fair.c   	if (rq-&gt;nr_running &gt; rq-&gt;nr_numa_running)</span>
<span class='curline'><a href='../S/464.html#L8768'>rq</a>               8768 sched/fair.c   	if (rq-&gt;nr_running &gt; rq-&gt;nr_preferred_running)</span>
<span class='curline'><a href='../S/464.html#L8778'>rq</a>               8778 sched/fair.c   static inline enum fbq_type fbq_classify_rq(struct rq *rq)</span>
<span class='curline'><a href='../S/464.html#L8812'>rq</a>               8812 sched/fair.c   	struct rq *rq = cpu_rq(cpu);</span>
<span class='curline'><a href='../S/464.html#L8814'>rq</a>               8814 sched/fair.c   	if (rq-&gt;curr != rq-&gt;idle &amp;&amp; rq-&gt;curr != p)</span>
<span class='curline'><a href='../S/464.html#L8824'>rq</a>               8824 sched/fair.c   	if (rq-&gt;ttwu_pending)</span>
<span class='curline'><a href='../S/464.html#L8848'>rq</a>               8848 sched/fair.c   		struct rq *rq = cpu_rq(i);</span>
<span class='curline'><a href='../S/464.html#L8851'>rq</a>               8851 sched/fair.c   		sgs-&gt;group_load += cpu_load_without(rq, p);</span>
<span class='curline'><a href='../S/464.html#L8853'>rq</a>               8853 sched/fair.c   		sgs-&gt;group_runnable += cpu_runnable_without(rq, p);</span>
<span class='curline'><a href='../S/464.html#L8855'>rq</a>               8855 sched/fair.c   		sgs-&gt;sum_h_nr_running += rq-&gt;cfs.h_nr_running - local;</span>
<span class='curline'><a href='../S/464.html#L8857'>rq</a>               8857 sched/fair.c   		nr_running = rq-&gt;nr_running - local;</span>
<span class='curline'><a href='../S/464.html#L9498'>rq</a>               9498 sched/fair.c   static struct rq *find_busiest_queue(struct lb_env *env,</span>
<span class='curline'><a href='../S/464.html#L9501'>rq</a>               9501 sched/fair.c   	struct rq *busiest = NULL, *rq;</span>
<span class='curline'><a href='../S/464.html#L9516'>rq</a>               9516 sched/fair.c   		rq = cpu_rq(i);</span>
<span class='curline'><a href='../S/464.html#L9517'>rq</a>               9517 sched/fair.c   		rt = fbq_classify_rq(rq);</span>
<span class='curline'><a href='../S/464.html#L9542'>rq</a>               9542 sched/fair.c   		nr_running = rq-&gt;cfs.h_nr_running;</span>
<span class='curline'><a href='../S/464.html#L9561'>rq</a>               9561 sched/fair.c   			load = cpu_load(rq);</span>
<span class='curline'><a href='../S/464.html#L9564'>rq</a>               9564 sched/fair.c   			    !check_cpu_capacity(rq, env-&gt;sd))</span>
<span class='curline'><a href='../S/464.html#L9583'>rq</a>               9583 sched/fair.c   				busiest = rq;</span>
<span class='curline'><a href='../S/464.html#L9588'>rq</a>               9588 sched/fair.c   			util = cpu_util(cpu_of(rq));</span>
<span class='curline'><a href='../S/464.html#L9600'>rq</a>               9600 sched/fair.c   				busiest = rq;</span>
<span class='curline'><a href='../S/464.html#L9607'>rq</a>               9607 sched/fair.c   				busiest = rq;</span>
<span class='curline'><a href='../S/464.html#L9616'>rq</a>               9616 sched/fair.c   			if (rq-&gt;misfit_task_load &gt; busiest_load) {</span>
<span class='curline'><a href='../S/464.html#L9617'>rq</a>               9617 sched/fair.c   				busiest_load = rq-&gt;misfit_task_load;</span>
<span class='curline'><a href='../S/464.html#L9618'>rq</a>               9618 sched/fair.c   				busiest = rq;</span>
<span class='curline'><a href='../S/464.html#L9722'>rq</a>               9722 sched/fair.c   static int load_balance(int this_cpu, struct rq *this_rq,</span>
<span class='curline'><a href='../S/464.html#L9729'>rq</a>               9729 sched/fair.c   	struct rq *busiest;</span>
<span class='curline'><a href='../S/464.html#L10042'>rq</a>               10042 sched/fair.c   	struct rq *busiest_rq = data;</span>
<span class='curline'><a href='../S/464.html#L10045'>rq</a>               10045 sched/fair.c   	struct rq *target_rq = cpu_rq(target_cpu);</span>
<span class='curline'><a href='../S/464.html#L10142'>rq</a>               10142 sched/fair.c   static void rebalance_domains(struct rq *rq, enum cpu_idle_type idle)</span>
<span class='curline'><a href='../S/464.html#L10145'>rq</a>               10145 sched/fair.c   	int cpu = rq-&gt;cpu;</span>
<span class='curline'><a href='../S/464.html#L10155'>rq</a>               10155 sched/fair.c   	trace_android_rvh_sched_rebalance_domains(rq, &amp;continue_balancing);</span>
<span class='curline'><a href='../S/464.html#L10193'>rq</a>               10193 sched/fair.c   			if (load_balance(cpu, rq, sd, idle, &amp;continue_balancing)) {</span>
<span class='curline'><a href='../S/464.html#L10218'>rq</a>               10218 sched/fair.c   		rq-&gt;max_idle_balance_cost =</span>
<span class='curline'><a href='../S/464.html#L10229'>rq</a>               10229 sched/fair.c   		rq-&gt;next_balance = next_balance;</span>
<span class='curline'><a href='../S/464.html#L10240'>rq</a>               10240 sched/fair.c   		if ((idle == CPU_IDLE) &amp;&amp; time_after(nohz.next_balance, rq-&gt;next_balance))</span>
<span class='curline'><a href='../S/464.html#L10241'>rq</a>               10241 sched/fair.c   			nohz.next_balance = rq-&gt;next_balance;</span>
<span class='curline'><a href='../S/464.html#L10246'>rq</a>               10246 sched/fair.c   static inline int on_null_domain(struct rq *rq)</span>
<span class='curline'><a href='../S/464.html#L10248'>rq</a>               10248 sched/fair.c   	return unlikely(!rcu_dereference_sched(rq-&gt;sd));</span>
<span class='curline'><a href='../S/464.html#L10318'>rq</a>               10318 sched/fair.c   static void nohz_balancer_kick(struct rq *rq)</span>
<span class='curline'><a href='../S/464.html#L10323'>rq</a>               10323 sched/fair.c   	int nr_busy, i, cpu = rq-&gt;cpu;</span>
<span class='curline'><a href='../S/464.html#L10327'>rq</a>               10327 sched/fair.c   	if (unlikely(rq-&gt;idle_balance))</span>
<span class='curline'><a href='../S/464.html#L10334'>rq</a>               10334 sched/fair.c   	nohz_balance_exit_idle(rq);</span>
<span class='curline'><a href='../S/464.html#L10350'>rq</a>               10350 sched/fair.c   	trace_android_rvh_sched_nohz_balancer_kick(rq, &amp;flags, &amp;done);</span>
<span class='curline'><a href='../S/464.html#L10354'>rq</a>               10354 sched/fair.c   	if (rq-&gt;nr_running &gt;= 2) {</span>
<span class='curline'><a href='../S/464.html#L10361'>rq</a>               10361 sched/fair.c   	sd = rcu_dereference(rq-&gt;sd);</span>
<span class='curline'><a href='../S/464.html#L10368'>rq</a>               10368 sched/fair.c   		if (rq-&gt;cfs.h_nr_running &gt;= 1 &amp;&amp; check_cpu_capacity(rq, sd)) {</span>
<span class='curline'><a href='../S/464.html#L10395'>rq</a>               10395 sched/fair.c   		if (check_misfit_status(rq, sd)) {</span>
<span class='curline'><a href='../S/464.html#L10450'>rq</a>               10450 sched/fair.c   void nohz_balance_exit_idle(struct rq *rq)</span>
<span class='curline'><a href='../S/464.html#L10452'>rq</a>               10452 sched/fair.c   	SCHED_WARN_ON(rq != this_rq());</span>
<span class='curline'><a href='../S/464.html#L10454'>rq</a>               10454 sched/fair.c   	if (likely(!rq-&gt;nohz_tick_stopped))</span>
<span class='curline'><a href='../S/464.html#L10457'>rq</a>               10457 sched/fair.c   	rq-&gt;nohz_tick_stopped = 0;</span>
<span class='curline'><a href='../S/464.html#L10458'>rq</a>               10458 sched/fair.c   	cpumask_clear_cpu(rq-&gt;cpu, nohz.idle_cpus_mask);</span>
<span class='curline'><a href='../S/464.html#L10461'>rq</a>               10461 sched/fair.c   	set_cpu_sd_state_busy(rq-&gt;cpu);</span>
<span class='curline'><a href='../S/464.html#L10486'>rq</a>               10486 sched/fair.c   	struct rq *rq = cpu_rq(cpu);</span>
<span class='curline'><a href='../S/464.html#L10501'>rq</a>               10501 sched/fair.c   		nohz_balance_exit_idle(rq);</span>
<span class='curline'><a href='../S/464.html#L10514'>rq</a>               10514 sched/fair.c   	rq-&gt;has_blocked_load = 1;</span>
<span class='curline'><a href='../S/464.html#L10522'>rq</a>               10522 sched/fair.c   	if (rq-&gt;nohz_tick_stopped)</span>
<span class='curline'><a href='../S/464.html#L10526'>rq</a>               10526 sched/fair.c   	if (on_null_domain(rq))</span>
<span class='curline'><a href='../S/464.html#L10529'>rq</a>               10529 sched/fair.c   	rq-&gt;nohz_tick_stopped = 1;</span>
<span class='curline'><a href='../S/464.html#L10558'>rq</a>               10558 sched/fair.c   static bool _nohz_idle_balance(struct rq *this_rq, unsigned int flags,</span>
<span class='curline'><a href='../S/464.html#L10569'>rq</a>               10569 sched/fair.c   	struct rq *rq;</span>
<span class='curline'><a href='../S/464.html#L10603'>rq</a>               10603 sched/fair.c   		rq = cpu_rq(balance_cpu);</span>
<span class='curline'><a href='../S/464.html#L10605'>rq</a>               10605 sched/fair.c   		has_blocked_load |= update_nohz_stats(rq, true);</span>
<span class='curline'><a href='../S/464.html#L10611'>rq</a>               10611 sched/fair.c   		if (time_after_eq(jiffies, rq-&gt;next_balance)) {</span>
<span class='curline'><a href='../S/464.html#L10614'>rq</a>               10614 sched/fair.c   			rq_lock_irqsave(rq, &amp;rf);</span>
<span class='curline'><a href='../S/464.html#L10615'>rq</a>               10615 sched/fair.c   			update_rq_clock(rq);</span>
<span class='curline'><a href='../S/464.html#L10616'>rq</a>               10616 sched/fair.c   			rq_unlock_irqrestore(rq, &amp;rf);</span>
<span class='curline'><a href='../S/464.html#L10619'>rq</a>               10619 sched/fair.c   				rebalance_domains(rq, CPU_IDLE);</span>
<span class='curline'><a href='../S/464.html#L10622'>rq</a>               10622 sched/fair.c   		if (time_after(next_balance, rq-&gt;next_balance)) {</span>
<span class='curline'><a href='../S/464.html#L10623'>rq</a>               10623 sched/fair.c   			next_balance = rq-&gt;next_balance;</span>
<span class='curline'><a href='../S/464.html#L10663'>rq</a>               10663 sched/fair.c   static bool nohz_idle_balance(struct rq *this_rq, enum cpu_idle_type idle)</span>
<span class='curline'><a href='../S/464.html#L10680'>rq</a>               10680 sched/fair.c   static void nohz_newidle_balance(struct rq *this_rq)</span>
<span class='curline'><a href='../S/464.html#L10713'>rq</a>               10713 sched/fair.c   static inline void nohz_balancer_kick(struct rq *rq) { }</span>
<span class='curline'><a href='../S/464.html#L10715'>rq</a>               10715 sched/fair.c   static inline bool nohz_idle_balance(struct rq *this_rq, enum cpu_idle_type idle)</span>
<span class='curline'><a href='../S/464.html#L10720'>rq</a>               10720 sched/fair.c   static inline void nohz_newidle_balance(struct rq *this_rq) { }</span>
<span class='curline'><a href='../S/464.html#L10732'>rq</a>               10732 sched/fair.c   static int newidle_balance(struct rq *this_rq, struct rq_flags *rf)</span>
<span class='curline'><a href='../S/464.html#L10854'>rq</a>               10854 sched/fair.c   	struct rq *this_rq = this_rq();</span>
<span class='curline'><a href='../S/464.html#L10877'>rq</a>               10877 sched/fair.c   void trigger_load_balance(struct rq *rq)</span>
<span class='curline'><a href='../S/464.html#L10880'>rq</a>               10880 sched/fair.c   	if (unlikely(on_null_domain(rq)))</span>
<span class='curline'><a href='../S/464.html#L10883'>rq</a>               10883 sched/fair.c   	if (time_after_eq(jiffies, rq-&gt;next_balance))</span>
<span class='curline'><a href='../S/464.html#L10886'>rq</a>               10886 sched/fair.c   	nohz_balancer_kick(rq);</span>
<span class='curline'><a href='../S/464.html#L10889'>rq</a>               10889 sched/fair.c   static void rq_online_fair(struct rq *rq)</span>
<span class='curline'><a href='../S/464.html#L10893'>rq</a>               10893 sched/fair.c   	update_runtime_enabled(rq);</span>
<span class='curline'><a href='../S/464.html#L10896'>rq</a>               10896 sched/fair.c   static void rq_offline_fair(struct rq *rq)</span>
<span class='curline'><a href='../S/464.html#L10901'>rq</a>               10901 sched/fair.c   	unthrottle_offline_cfs_rqs(rq);</span>
<span class='curline'><a href='../S/464.html#L10914'>rq</a>               10914 sched/fair.c   static void task_tick_fair(struct rq *rq, struct task_struct *curr, int queued)</span>
<span class='curline'><a href='../S/464.html#L10925'>rq</a>               10925 sched/fair.c   		task_tick_numa(rq, curr);</span>
<span class='curline'><a href='../S/464.html#L10927'>rq</a>               10927 sched/fair.c   	update_misfit_status(curr, rq);</span>
<span class='curline'><a href='../S/464.html#L10940'>rq</a>               10940 sched/fair.c   	struct rq *rq = this_rq();</span>
<span class='curline'><a href='../S/464.html#L10943'>rq</a>               10943 sched/fair.c   	rq_lock(rq, &amp;rf);</span>
<span class='curline'><a href='../S/464.html#L10944'>rq</a>               10944 sched/fair.c   	update_rq_clock(rq);</span>
<span class='curline'><a href='../S/464.html#L10960'>rq</a>               10960 sched/fair.c   		resched_curr(rq);</span>
<span class='curline'><a href='../S/464.html#L10964'>rq</a>               10964 sched/fair.c   	rq_unlock(rq, &amp;rf);</span>
<span class='curline'><a href='../S/464.html#L10972'>rq</a>               10972 sched/fair.c   prio_changed_fair(struct rq *rq, struct task_struct *p, int oldprio)</span>
<span class='curline'><a href='../S/464.html#L10977'>rq</a>               10977 sched/fair.c   	if (rq-&gt;cfs.nr_running == 1)</span>
<span class='curline'><a href='../S/464.html#L10985'>rq</a>               10985 sched/fair.c   	if (rq-&gt;curr == p) {</span>
<span class='curline'><a href='../S/464.html#L10987'>rq</a>               10987 sched/fair.c   			resched_curr(rq);</span>
<span class='curline'><a href='../S/464.html#L10989'>rq</a>               10989 sched/fair.c   		check_preempt_curr(rq, p, 0);</span>
<span class='curline'><a href='../S/464.html#L11109'>rq</a>               11109 sched/fair.c   static void switched_from_fair(struct rq *rq, struct task_struct *p)</span>
<span class='curline'><a href='../S/464.html#L11114'>rq</a>               11114 sched/fair.c   static void switched_to_fair(struct rq *rq, struct task_struct *p)</span>
<span class='curline'><a href='../S/464.html#L11124'>rq</a>               11124 sched/fair.c   		if (rq-&gt;curr == p)</span>
<span class='curline'><a href='../S/464.html#L11125'>rq</a>               11125 sched/fair.c   			resched_curr(rq);</span>
<span class='curline'><a href='../S/464.html#L11127'>rq</a>               11127 sched/fair.c   			check_preempt_curr(rq, p, 0);</span>
<span class='curline'><a href='../S/464.html#L11136'>rq</a>               11136 sched/fair.c   static void set_next_task_fair(struct rq *rq, struct task_struct *p, bool first)</span>
<span class='curline'><a href='../S/464.html#L11146'>rq</a>               11146 sched/fair.c   		list_move(&amp;se-&gt;group_node, &amp;rq-&gt;cfs_tasks);</span>
<span class='curline'><a href='../S/464.html#L11267'>rq</a>               11267 sched/fair.c   	struct rq *rq;</span>
<span class='curline'><a href='../S/464.html#L11271'>rq</a>               11271 sched/fair.c   		rq = cpu_rq(i);</span>
<span class='curline'><a href='../S/464.html#L11273'>rq</a>               11273 sched/fair.c   		rq_lock_irq(rq, &amp;rf);</span>
<span class='curline'><a href='../S/464.html#L11274'>rq</a>               11274 sched/fair.c   		update_rq_clock(rq);</span>
<span class='curline'><a href='../S/464.html#L11277'>rq</a>               11277 sched/fair.c   		rq_unlock_irq(rq, &amp;rf);</span>
<span class='curline'><a href='../S/464.html#L11284'>rq</a>               11284 sched/fair.c   	struct rq *rq;</span>
<span class='curline'><a href='../S/464.html#L11298'>rq</a>               11298 sched/fair.c   		rq = cpu_rq(cpu);</span>
<span class='curline'><a href='../S/464.html#L11300'>rq</a>               11300 sched/fair.c   		raw_spin_lock_irqsave(&amp;rq-&gt;lock, flags);</span>
<span class='curline'><a href='../S/464.html#L11302'>rq</a>               11302 sched/fair.c   		raw_spin_unlock_irqrestore(&amp;rq-&gt;lock, flags);</span>
<span class='curline'><a href='../S/464.html#L11310'>rq</a>               11310 sched/fair.c   	struct rq *rq = cpu_rq(cpu);</span>
<span class='curline'><a href='../S/464.html#L11313'>rq</a>               11313 sched/fair.c   	cfs_rq-&gt;rq = rq;</span>
<span class='curline'><a href='../S/464.html#L11324'>rq</a>               11324 sched/fair.c   		se-&gt;cfs_rq = &amp;rq-&gt;cfs;</span>
<span class='curline'><a href='../S/464.html#L11357'>rq</a>               11357 sched/fair.c   		struct rq *rq = cpu_rq(i);</span>
<span class='curline'><a href='../S/464.html#L11362'>rq</a>               11362 sched/fair.c   		rq_lock_irqsave(rq, &amp;rf);</span>
<span class='curline'><a href='../S/464.html#L11363'>rq</a>               11363 sched/fair.c   		update_rq_clock(rq);</span>
<span class='curline'><a href='../S/464.html#L11368'>rq</a>               11368 sched/fair.c   		rq_unlock_irqrestore(rq, &amp;rf);</span>
<span class='curline'><a href='../S/464.html#L11391'>rq</a>               11391 sched/fair.c   static unsigned int get_rr_interval_fair(struct rq *rq, struct task_struct *task)</span>
<span class='curline'><a href='../S/464.html#L11400'>rq</a>               11400 sched/fair.c   	if (rq-&gt;cfs.load.weight)</span>
<span class='curline'><a href='../S/464.html#L11538'>rq</a>               11538 sched/fair.c   const struct sched_avg *sched_trace_rq_avg_rt(struct rq *rq)</span>
<span class='curline'><a href='../S/464.html#L11541'>rq</a>               11541 sched/fair.c   	return rq ? &amp;rq-&gt;avg_rt : NULL;</span>
<span class='curline'><a href='../S/464.html#L11548'>rq</a>               11548 sched/fair.c   const struct sched_avg *sched_trace_rq_avg_dl(struct rq *rq)</span>
<span class='curline'><a href='../S/464.html#L11551'>rq</a>               11551 sched/fair.c   	return rq ? &amp;rq-&gt;avg_dl : NULL;</span>
<span class='curline'><a href='../S/464.html#L11558'>rq</a>               11558 sched/fair.c   const struct sched_avg *sched_trace_rq_avg_irq(struct rq *rq)</span>
<span class='curline'><a href='../S/464.html#L11561'>rq</a>               11561 sched/fair.c   	return rq ? &amp;rq-&gt;avg_irq : NULL;</span>
<span class='curline'><a href='../S/464.html#L11568'>rq</a>               11568 sched/fair.c   int sched_trace_rq_cpu(struct rq *rq)</span>
<span class='curline'><a href='../S/464.html#L11570'>rq</a>               11570 sched/fair.c   	return rq ? cpu_of(rq) : -1;</span>
<span class='curline'><a href='../S/464.html#L11574'>rq</a>               11574 sched/fair.c   int sched_trace_rq_cpu_capacity(struct rq *rq)</span>
<span class='curline'><a href='../S/464.html#L11576'>rq</a>               11576 sched/fair.c   	return rq ?</span>
<span class='curline'><a href='../S/464.html#L11578'>rq</a>               11578 sched/fair.c   		rq-&gt;cpu_capacity</span>
<span class='curline'><a href='../S/464.html#L11596'>rq</a>               11596 sched/fair.c   int sched_trace_rq_nr_running(struct rq *rq)</span>
<span class='curline'><a href='../S/464.html#L11598'>rq</a>               11598 sched/fair.c           return rq ? rq-&gt;nr_running : -1;</span>
<span class='curline'><a href='../S/455.html#L413'>rq</a>                413 sched/idle.c   balance_idle(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)</span>
<span class='curline'><a href='../S/455.html#L422'>rq</a>                422 sched/idle.c   static void check_preempt_curr_idle(struct rq *rq, struct task_struct *p, int flags)</span>
<span class='curline'><a href='../S/455.html#L424'>rq</a>                424 sched/idle.c   	resched_curr(rq);</span>
<span class='curline'><a href='../S/455.html#L427'>rq</a>                427 sched/idle.c   static void put_prev_task_idle(struct rq *rq, struct task_struct *prev)</span>
<span class='curline'><a href='../S/455.html#L431'>rq</a>                431 sched/idle.c   static void set_next_task_idle(struct rq *rq, struct task_struct *next, bool first)</span>
<span class='curline'><a href='../S/455.html#L433'>rq</a>                433 sched/idle.c   	update_idle_core(rq);</span>
<span class='curline'><a href='../S/455.html#L434'>rq</a>                434 sched/idle.c   	schedstat_inc(rq-&gt;sched_goidle);</span>
<span class='curline'><a href='../S/455.html#L437'>rq</a>                437 sched/idle.c   struct task_struct *pick_next_task_idle(struct rq *rq)</span>
<span class='curline'><a href='../S/455.html#L439'>rq</a>                439 sched/idle.c   	struct task_struct *next = rq-&gt;idle;</span>
<span class='curline'><a href='../S/455.html#L441'>rq</a>                441 sched/idle.c   	set_next_task_idle(rq, next, true);</span>
<span class='curline'><a href='../S/455.html#L451'>rq</a>                451 sched/idle.c   dequeue_task_idle(struct rq *rq, struct task_struct *p, int flags)</span>
<span class='curline'><a href='../S/455.html#L453'>rq</a>                453 sched/idle.c   	raw_spin_unlock_irq(&amp;rq-&gt;lock);</span>
<span class='curline'><a href='../S/455.html#L458'>rq</a>                458 sched/idle.c   	raw_spin_lock_irq(&amp;rq-&gt;lock);</span>
<span class='curline'><a href='../S/455.html#L469'>rq</a>                469 sched/idle.c   static void task_tick_idle(struct rq *rq, struct task_struct *curr, int queued)</span>
<span class='curline'><a href='../S/455.html#L473'>rq</a>                473 sched/idle.c   static void switched_to_idle(struct rq *rq, struct task_struct *p)</span>
<span class='curline'><a href='../S/455.html#L479'>rq</a>                479 sched/idle.c   prio_changed_idle(struct rq *rq, struct task_struct *p, int oldprio)</span>
<span class='curline'><a href='../S/455.html#L484'>rq</a>                484 sched/idle.c   static void update_curr_idle(struct rq *rq)</span>
<span class='curline'><a href='../S/454.html#L80'>rq</a>                 80 sched/loadavg.c long calc_load_fold_active(struct rq *this_rq, long adjust)</span>
<span class='curline'><a href='../S/454.html#L235'>rq</a>                235 sched/loadavg.c static void calc_load_nohz_fold(struct rq *rq)</span>
<span class='curline'><a href='../S/454.html#L239'>rq</a>                239 sched/loadavg.c 	delta = calc_load_fold_active(rq, 0);</span>
<span class='curline'><a href='../S/454.html#L260'>rq</a>                260 sched/loadavg.c void calc_load_nohz_remote(struct rq *rq)</span>
<span class='curline'><a href='../S/454.html#L262'>rq</a>                262 sched/loadavg.c 	calc_load_nohz_fold(rq);</span>
<span class='curline'><a href='../S/454.html#L267'>rq</a>                267 sched/loadavg.c 	struct rq *this_rq = this_rq();</span>
<span class='curline'><a href='../S/454.html#L387'>rq</a>                387 sched/loadavg.c void calc_global_load_tick(struct rq *this_rq)</span>
<span class='curline'><a href='../S/444.html#L326'>rq</a>                326 sched/membarrier.c 		struct rq *rq = cpu_rq(cpu);</span>
<span class='curline'><a href='../S/444.html#L329'>rq</a>                329 sched/membarrier.c 		p = rcu_dereference(rq-&gt;curr);</span>
<span class='curline'><a href='../S/463.html#L387'>rq</a>                387 sched/pelt.c   int update_rt_rq_load_avg(u64 now, struct rq *rq, int running)</span>
<span class='curline'><a href='../S/463.html#L389'>rq</a>                389 sched/pelt.c   	if (___update_load_sum(now, &amp;rq-&gt;avg_rt,</span>
<span class='curline'><a href='../S/463.html#L394'>rq</a>                394 sched/pelt.c   		___update_load_avg(&amp;rq-&gt;avg_rt, 1);</span>
<span class='curline'><a href='../S/463.html#L395'>rq</a>                395 sched/pelt.c   		trace_pelt_rt_tp(rq);</span>
<span class='curline'><a href='../S/463.html#L413'>rq</a>                413 sched/pelt.c   int update_dl_rq_load_avg(u64 now, struct rq *rq, int running)</span>
<span class='curline'><a href='../S/463.html#L415'>rq</a>                415 sched/pelt.c   	if (___update_load_sum(now, &amp;rq-&gt;avg_dl,</span>
<span class='curline'><a href='../S/463.html#L420'>rq</a>                420 sched/pelt.c   		___update_load_avg(&amp;rq-&gt;avg_dl, 1);</span>
<span class='curline'><a href='../S/463.html#L421'>rq</a>                421 sched/pelt.c   		trace_pelt_dl_tp(rq);</span>
<span class='curline'><a href='../S/463.html#L444'>rq</a>                444 sched/pelt.c   int update_thermal_load_avg(u64 now, struct rq *rq, u64 capacity)</span>
<span class='curline'><a href='../S/463.html#L446'>rq</a>                446 sched/pelt.c   	if (___update_load_sum(now, &amp;rq-&gt;avg_thermal,</span>
<span class='curline'><a href='../S/463.html#L450'>rq</a>                450 sched/pelt.c   		___update_load_avg(&amp;rq-&gt;avg_thermal, 1);</span>
<span class='curline'><a href='../S/463.html#L451'>rq</a>                451 sched/pelt.c   		trace_pelt_thermal_tp(rq);</span>
<span class='curline'><a href='../S/463.html#L471'>rq</a>                471 sched/pelt.c   int update_irq_load_avg(struct rq *rq, u64 running)</span>
<span class='curline'><a href='../S/463.html#L480'>rq</a>                480 sched/pelt.c   	running = cap_scale(running, arch_scale_freq_capacity(cpu_of(rq)));</span>
<span class='curline'><a href='../S/463.html#L481'>rq</a>                481 sched/pelt.c   	running = cap_scale(running, arch_scale_cpu_capacity(cpu_of(rq)));</span>
<span class='curline'><a href='../S/463.html#L494'>rq</a>                494 sched/pelt.c   	ret = ___update_load_sum(rq-&gt;clock - running, &amp;rq-&gt;avg_irq,</span>
<span class='curline'><a href='../S/463.html#L498'>rq</a>                498 sched/pelt.c   	ret += ___update_load_sum(rq-&gt;clock, &amp;rq-&gt;avg_irq,</span>
<span class='curline'><a href='../S/463.html#L504'>rq</a>                504 sched/pelt.c   		___update_load_avg(&amp;rq-&gt;avg_irq, 1);</span>
<span class='curline'><a href='../S/463.html#L505'>rq</a>                505 sched/pelt.c   		trace_pelt_irq_tp(rq);</span>
<span class='curline'><a href='../S/468.html#L7'>rq</a>                  7 sched/pelt.h   int update_rt_rq_load_avg(u64 now, struct rq *rq, int running);</span>
<span class='curline'><a href='../S/468.html#L8'>rq</a>                  8 sched/pelt.h   int update_dl_rq_load_avg(u64 now, struct rq *rq, int running);</span>
<span class='curline'><a href='../S/468.html#L11'>rq</a>                 11 sched/pelt.h   int update_thermal_load_avg(u64 now, struct rq *rq, u64 capacity);</span>
<span class='curline'><a href='../S/468.html#L13'>rq</a>                 13 sched/pelt.h   static inline u64 thermal_load_avg(struct rq *rq)</span>
<span class='curline'><a href='../S/468.html#L15'>rq</a>                 15 sched/pelt.h   	return READ_ONCE(rq-&gt;avg_thermal.load_avg);</span>
<span class='curline'><a href='../S/468.html#L19'>rq</a>                 19 sched/pelt.h   update_thermal_load_avg(u64 now, struct rq *rq, u64 capacity)</span>
<span class='curline'><a href='../S/468.html#L24'>rq</a>                 24 sched/pelt.h   static inline u64 thermal_load_avg(struct rq *rq)</span>
<span class='curline'><a href='../S/468.html#L31'>rq</a>                 31 sched/pelt.h   int update_irq_load_avg(struct rq *rq, u64 running);</span>
<span class='curline'><a href='../S/468.html#L34'>rq</a>                 34 sched/pelt.h   update_irq_load_avg(struct rq *rq, u64 running)</span>
<span class='curline'><a href='../S/468.html#L83'>rq</a>                 83 sched/pelt.h   static inline void update_rq_clock_pelt(struct rq *rq, s64 delta)</span>
<span class='curline'><a href='../S/468.html#L85'>rq</a>                 85 sched/pelt.h   	if (unlikely(is_idle_task(rq-&gt;curr))) {</span>
<span class='curline'><a href='../S/468.html#L87'>rq</a>                 87 sched/pelt.h   		rq-&gt;clock_pelt  = rq_clock_task(rq);</span>
<span class='curline'><a href='../S/468.html#L107'>rq</a>                107 sched/pelt.h   	delta = cap_scale(delta, arch_scale_cpu_capacity(cpu_of(rq)));</span>
<span class='curline'><a href='../S/468.html#L108'>rq</a>                108 sched/pelt.h   	delta = cap_scale(delta, arch_scale_freq_capacity(cpu_of(rq)));</span>
<span class='curline'><a href='../S/468.html#L110'>rq</a>                110 sched/pelt.h   	rq-&gt;clock_pelt += delta;</span>
<span class='curline'><a href='../S/468.html#L122'>rq</a>                122 sched/pelt.h   static inline void update_idle_rq_clock_pelt(struct rq *rq)</span>
<span class='curline'><a href='../S/468.html#L125'>rq</a>                125 sched/pelt.h   	u32 util_sum = rq-&gt;cfs.avg.util_sum;</span>
<span class='curline'><a href='../S/468.html#L126'>rq</a>                126 sched/pelt.h   	util_sum += rq-&gt;avg_rt.util_sum;</span>
<span class='curline'><a href='../S/468.html#L127'>rq</a>                127 sched/pelt.h   	util_sum += rq-&gt;avg_dl.util_sum;</span>
<span class='curline'><a href='../S/468.html#L139'>rq</a>                139 sched/pelt.h   		rq-&gt;lost_idle_time += rq_clock_task(rq) - rq-&gt;clock_pelt;</span>
<span class='curline'><a href='../S/468.html#L142'>rq</a>                142 sched/pelt.h   static inline u64 rq_clock_pelt(struct rq *rq)</span>
<span class='curline'><a href='../S/468.html#L144'>rq</a>                144 sched/pelt.h   	lockdep_assert_held(&amp;rq-&gt;lock);</span>
<span class='curline'><a href='../S/468.html#L145'>rq</a>                145 sched/pelt.h   	assert_clock_updated(rq);</span>
<span class='curline'><a href='../S/468.html#L147'>rq</a>                147 sched/pelt.h   	return rq-&gt;clock_pelt - rq-&gt;lost_idle_time;</span>
<span class='curline'><a href='../S/468.html#L175'>rq</a>                175 sched/pelt.h   update_rt_rq_load_avg(u64 now, struct rq *rq, int running)</span>
<span class='curline'><a href='../S/468.html#L181'>rq</a>                181 sched/pelt.h   update_dl_rq_load_avg(u64 now, struct rq *rq, int running)</span>
<span class='curline'><a href='../S/468.html#L187'>rq</a>                187 sched/pelt.h   update_thermal_load_avg(u64 now, struct rq *rq, u64 capacity)</span>
<span class='curline'><a href='../S/468.html#L192'>rq</a>                192 sched/pelt.h   static inline u64 thermal_load_avg(struct rq *rq)</span>
<span class='curline'><a href='../S/468.html#L198'>rq</a>                198 sched/pelt.h   update_irq_load_avg(struct rq *rq, u64 running)</span>
<span class='curline'><a href='../S/468.html#L203'>rq</a>                203 sched/pelt.h   static inline u64 rq_clock_pelt(struct rq *rq)</span>
<span class='curline'><a href='../S/468.html#L205'>rq</a>                205 sched/pelt.h   	return rq_clock_task(rq);</span>
<span class='curline'><a href='../S/468.html#L209'>rq</a>                209 sched/pelt.h   update_rq_clock_pelt(struct rq *rq, s64 delta) { }</span>
<span class='curline'><a href='../S/468.html#L212'>rq</a>                212 sched/pelt.h   update_idle_rq_clock_pelt(struct rq *rq) { }</span>
<span class='curline'><a href='../S/462.html#L886'>rq</a>                886 sched/psi.c    	struct rq *rq;</span>
<span class='curline'><a href='../S/462.html#L899'>rq</a>                899 sched/psi.c    	rq = this_rq_lock_irq(&amp;rf);</span>
<span class='curline'><a href='../S/462.html#L904'>rq</a>                904 sched/psi.c    	rq_unlock_irq(rq, &amp;rf);</span>
<span class='curline'><a href='../S/462.html#L916'>rq</a>                916 sched/psi.c    	struct rq *rq;</span>
<span class='curline'><a href='../S/462.html#L928'>rq</a>                928 sched/psi.c    	rq = this_rq_lock_irq(&amp;rf);</span>
<span class='curline'><a href='../S/462.html#L933'>rq</a>                933 sched/psi.c    	rq_unlock_irq(rq, &amp;rf);</span>
<span class='curline'><a href='../S/462.html#L976'>rq</a>                976 sched/psi.c    	struct rq *rq;</span>
<span class='curline'><a href='../S/462.html#L987'>rq</a>                987 sched/psi.c    	rq = task_rq_lock(task, &amp;rf);</span>
<span class='curline'><a href='../S/462.html#L991'>rq</a>                991 sched/psi.c    		if (task_current(rq, task))</span>
<span class='curline'><a href='../S/462.html#L1008'>rq</a>               1008 sched/psi.c    	task_rq_unlock(rq, task, &amp;rf);</span>
<span class='curline'><a href='../S/450.html#L125'>rq</a>                125 sched/rt.c     static inline struct rq *rq_of_rt_rq(struct rt_rq *rt_rq)</span>
<span class='curline'><a href='../S/450.html#L127'>rq</a>                127 sched/rt.c     	return rt_rq-&gt;rq;</span>
<span class='curline'><a href='../S/450.html#L135'>rq</a>                135 sched/rt.c     static inline struct rq *rq_of_rt_se(struct sched_rt_entity *rt_se)</span>
<span class='curline'><a href='../S/450.html#L139'>rq</a>                139 sched/rt.c     	return rt_rq-&gt;rq;</span>
<span class='curline'><a href='../S/450.html#L164'>rq</a>                164 sched/rt.c     	struct rq *rq = cpu_rq(cpu);</span>
<span class='curline'><a href='../S/450.html#L168'>rq</a>                168 sched/rt.c     	rt_rq-&gt;rq = rq;</span>
<span class='curline'><a href='../S/450.html#L178'>rq</a>                178 sched/rt.c     		rt_se-&gt;rt_rq = &amp;rq-&gt;rt;</span>
<span class='curline'><a href='../S/450.html#L236'>rq</a>                236 sched/rt.c     static inline struct rq *rq_of_rt_rq(struct rt_rq *rt_rq)</span>
<span class='curline'><a href='../S/450.html#L238'>rq</a>                238 sched/rt.c     	return container_of(rt_rq, struct rq, rt);</span>
<span class='curline'><a href='../S/450.html#L241'>rq</a>                241 sched/rt.c     static inline struct rq *rq_of_rt_se(struct sched_rt_entity *rt_se)</span>
<span class='curline'><a href='../S/450.html#L250'>rq</a>                250 sched/rt.c     	struct rq *rq = rq_of_rt_se(rt_se);</span>
<span class='curline'><a href='../S/450.html#L252'>rq</a>                252 sched/rt.c     	return &amp;rq-&gt;rt;</span>
<span class='curline'><a href='../S/450.html#L265'>rq</a>                265 sched/rt.c     static void pull_rt_task(struct rq *this_rq);</span>
<span class='curline'><a href='../S/450.html#L267'>rq</a>                267 sched/rt.c     static inline bool need_pull_rt_task(struct rq *rq, struct task_struct *prev)</span>
<span class='curline'><a href='../S/450.html#L270'>rq</a>                270 sched/rt.c     	return rq-&gt;rt.highest_prio.curr &gt; prev-&gt;prio;</span>
<span class='curline'><a href='../S/450.html#L273'>rq</a>                273 sched/rt.c     static inline int rt_overloaded(struct rq *rq)</span>
<span class='curline'><a href='../S/450.html#L275'>rq</a>                275 sched/rt.c     	return atomic_read(&amp;rq-&gt;rd-&gt;rto_count);</span>
<span class='curline'><a href='../S/450.html#L278'>rq</a>                278 sched/rt.c     static inline void rt_set_overload(struct rq *rq)</span>
<span class='curline'><a href='../S/450.html#L280'>rq</a>                280 sched/rt.c     	if (!rq-&gt;online)</span>
<span class='curline'><a href='../S/450.html#L283'>rq</a>                283 sched/rt.c     	cpumask_set_cpu(rq-&gt;cpu, rq-&gt;rd-&gt;rto_mask);</span>
<span class='curline'><a href='../S/450.html#L294'>rq</a>                294 sched/rt.c     	atomic_inc(&amp;rq-&gt;rd-&gt;rto_count);</span>
<span class='curline'><a href='../S/450.html#L297'>rq</a>                297 sched/rt.c     static inline void rt_clear_overload(struct rq *rq)</span>
<span class='curline'><a href='../S/450.html#L299'>rq</a>                299 sched/rt.c     	if (!rq-&gt;online)</span>
<span class='curline'><a href='../S/450.html#L303'>rq</a>                303 sched/rt.c     	atomic_dec(&amp;rq-&gt;rd-&gt;rto_count);</span>
<span class='curline'><a href='../S/450.html#L304'>rq</a>                304 sched/rt.c     	cpumask_clear_cpu(rq-&gt;cpu, rq-&gt;rd-&gt;rto_mask);</span>
<span class='curline'><a href='../S/450.html#L354'>rq</a>                354 sched/rt.c     static inline int has_pushable_tasks(struct rq *rq)</span>
<span class='curline'><a href='../S/450.html#L356'>rq</a>                356 sched/rt.c     	return !plist_head_empty(&amp;rq-&gt;rt.pushable_tasks);</span>
<span class='curline'><a href='../S/450.html#L362'>rq</a>                362 sched/rt.c     static void push_rt_tasks(struct rq *);</span>
<span class='curline'><a href='../S/450.html#L363'>rq</a>                363 sched/rt.c     static void pull_rt_task(struct rq *);</span>
<span class='curline'><a href='../S/450.html#L365'>rq</a>                365 sched/rt.c     static inline void rt_queue_push_tasks(struct rq *rq)</span>
<span class='curline'><a href='../S/450.html#L367'>rq</a>                367 sched/rt.c     	if (!has_pushable_tasks(rq))</span>
<span class='curline'><a href='../S/450.html#L370'>rq</a>                370 sched/rt.c     	queue_balance_callback(rq, &amp;per_cpu(rt_push_head, rq-&gt;cpu), push_rt_tasks);</span>
<span class='curline'><a href='../S/450.html#L373'>rq</a>                373 sched/rt.c     static inline void rt_queue_pull_task(struct rq *rq)</span>
<span class='curline'><a href='../S/450.html#L375'>rq</a>                375 sched/rt.c     	queue_balance_callback(rq, &amp;per_cpu(rt_pull_head, rq-&gt;cpu), pull_rt_task);</span>
<span class='curline'><a href='../S/450.html#L378'>rq</a>                378 sched/rt.c     static void enqueue_pushable_task(struct rq *rq, struct task_struct *p)</span>
<span class='curline'><a href='../S/450.html#L380'>rq</a>                380 sched/rt.c     	plist_del(&amp;p-&gt;pushable_tasks, &amp;rq-&gt;rt.pushable_tasks);</span>
<span class='curline'><a href='../S/450.html#L382'>rq</a>                382 sched/rt.c     	plist_add(&amp;p-&gt;pushable_tasks, &amp;rq-&gt;rt.pushable_tasks);</span>
<span class='curline'><a href='../S/450.html#L385'>rq</a>                385 sched/rt.c     	if (p-&gt;prio &lt; rq-&gt;rt.highest_prio.next)</span>
<span class='curline'><a href='../S/450.html#L386'>rq</a>                386 sched/rt.c     		rq-&gt;rt.highest_prio.next = p-&gt;prio;</span>
<span class='curline'><a href='../S/450.html#L389'>rq</a>                389 sched/rt.c     static void dequeue_pushable_task(struct rq *rq, struct task_struct *p)</span>
<span class='curline'><a href='../S/450.html#L391'>rq</a>                391 sched/rt.c     	plist_del(&amp;p-&gt;pushable_tasks, &amp;rq-&gt;rt.pushable_tasks);</span>
<span class='curline'><a href='../S/450.html#L394'>rq</a>                394 sched/rt.c     	if (has_pushable_tasks(rq)) {</span>
<span class='curline'><a href='../S/450.html#L395'>rq</a>                395 sched/rt.c     		p = plist_first_entry(&amp;rq-&gt;rt.pushable_tasks,</span>
<span class='curline'><a href='../S/450.html#L397'>rq</a>                397 sched/rt.c     		rq-&gt;rt.highest_prio.next = p-&gt;prio;</span>
<span class='curline'><a href='../S/450.html#L399'>rq</a>                399 sched/rt.c     		rq-&gt;rt.highest_prio.next = MAX_RT_PRIO;</span>
<span class='curline'><a href='../S/450.html#L404'>rq</a>                404 sched/rt.c     static inline void enqueue_pushable_task(struct rq *rq, struct task_struct *p)</span>
<span class='curline'><a href='../S/450.html#L408'>rq</a>                408 sched/rt.c     static inline void dequeue_pushable_task(struct rq *rq, struct task_struct *p)</span>
<span class='curline'><a href='../S/450.html#L422'>rq</a>                422 sched/rt.c     static inline bool need_pull_rt_task(struct rq *rq, struct task_struct *prev)</span>
<span class='curline'><a href='../S/450.html#L427'>rq</a>                427 sched/rt.c     static inline void pull_rt_task(struct rq *this_rq)</span>
<span class='curline'><a href='../S/450.html#L431'>rq</a>                431 sched/rt.c     static inline void rt_queue_push_tasks(struct rq *rq)</span>
<span class='curline'><a href='../S/450.html#L513'>rq</a>                513 sched/rt.c     #define for_each_rt_rq(rt_rq, iter, rq)					\</span>
<span class='curline'><a href='../S/450.html#L516'>rq</a>                516 sched/rt.c     		(rt_rq = iter-&gt;rt_rq[cpu_of(rq)]);)</span>
<span class='curline'><a href='../S/450.html#L532'>rq</a>                532 sched/rt.c     	struct rq *rq = rq_of_rt_rq(rt_rq);</span>
<span class='curline'><a href='../S/450.html#L535'>rq</a>                535 sched/rt.c     	int cpu = cpu_of(rq);</span>
<span class='curline'><a href='../S/450.html#L546'>rq</a>                546 sched/rt.c     			resched_curr(rq);</span>
<span class='curline'><a href='../S/450.html#L620'>rq</a>                620 sched/rt.c     #define for_each_rt_rq(rt_rq, iter, rq) \</span>
<span class='curline'><a href='../S/450.html#L621'>rq</a>                621 sched/rt.c     	for ((void) iter, rt_rq = &amp;rq-&gt;rt; rt_rq; rt_rq = NULL)</span>
<span class='curline'><a href='../S/450.html#L633'>rq</a>                633 sched/rt.c     	struct rq *rq = rq_of_rt_rq(rt_rq);</span>
<span class='curline'><a href='../S/450.html#L639'>rq</a>                639 sched/rt.c     	resched_curr(rq);</span>
<span class='curline'><a href='../S/450.html#L734'>rq</a>                734 sched/rt.c     static void __disable_runtime(struct rq *rq)</span>
<span class='curline'><a href='../S/450.html#L736'>rq</a>                736 sched/rt.c     	struct root_domain *rd = rq-&gt;rd;</span>
<span class='curline'><a href='../S/450.html#L743'>rq</a>                743 sched/rt.c     	for_each_rt_rq(rt_rq, iter, rq) {</span>
<span class='curline'><a href='../S/450.html#L816'>rq</a>                816 sched/rt.c     static void __enable_runtime(struct rq *rq)</span>
<span class='curline'><a href='../S/450.html#L827'>rq</a>                827 sched/rt.c     	for_each_rt_rq(rt_rq, iter, rq) {</span>
<span class='curline'><a href='../S/450.html#L877'>rq</a>                877 sched/rt.c     		struct rq *rq = rq_of_rt_rq(rt_rq);</span>
<span class='curline'><a href='../S/450.html#L892'>rq</a>                892 sched/rt.c     		raw_spin_lock(&amp;rq-&gt;lock);</span>
<span class='curline'><a href='../S/450.html#L893'>rq</a>                893 sched/rt.c     		update_rq_clock(rq);</span>
<span class='curline'><a href='../S/450.html#L914'>rq</a>                914 sched/rt.c     				if (rt_rq-&gt;rt_nr_running &amp;&amp; rq-&gt;curr == rq-&gt;idle)</span>
<span class='curline'><a href='../S/450.html#L915'>rq</a>                915 sched/rt.c     					rq_clock_cancel_skipupdate(rq);</span>
<span class='curline'><a href='../S/450.html#L930'>rq</a>                930 sched/rt.c     		raw_spin_unlock(&amp;rq-&gt;lock);</span>
<span class='curline'><a href='../S/450.html#L1005'>rq</a>               1005 sched/rt.c     static void update_curr_rt(struct rq *rq)</span>
<span class='curline'><a href='../S/450.html#L1007'>rq</a>               1007 sched/rt.c     	struct task_struct *curr = rq-&gt;curr;</span>
<span class='curline'><a href='../S/450.html#L1015'>rq</a>               1015 sched/rt.c     	now = rq_clock_task(rq);</span>
<span class='curline'><a href='../S/450.html#L1039'>rq</a>               1039 sched/rt.c     				resched_curr(rq);</span>
<span class='curline'><a href='../S/450.html#L1048'>rq</a>               1048 sched/rt.c     	struct rq *rq = rq_of_rt_rq(rt_rq);</span>
<span class='curline'><a href='../S/450.html#L1050'>rq</a>               1050 sched/rt.c     	BUG_ON(&amp;rq-&gt;rt != rt_rq);</span>
<span class='curline'><a href='../S/450.html#L1055'>rq</a>               1055 sched/rt.c     	BUG_ON(!rq-&gt;nr_running);</span>
<span class='curline'><a href='../S/450.html#L1057'>rq</a>               1057 sched/rt.c     	sub_nr_running(rq, rt_rq-&gt;rt_nr_running);</span>
<span class='curline'><a href='../S/450.html#L1065'>rq</a>               1065 sched/rt.c     	struct rq *rq = rq_of_rt_rq(rt_rq);</span>
<span class='curline'><a href='../S/450.html#L1067'>rq</a>               1067 sched/rt.c     	BUG_ON(&amp;rq-&gt;rt != rt_rq);</span>
<span class='curline'><a href='../S/450.html#L1076'>rq</a>               1076 sched/rt.c     		add_nr_running(rq, rt_rq-&gt;rt_nr_running);</span>
<span class='curline'><a href='../S/450.html#L1081'>rq</a>               1081 sched/rt.c     	cpufreq_update_util(rq, 0);</span>
<span class='curline'><a href='../S/450.html#L1089'>rq</a>               1089 sched/rt.c     	struct rq *rq = rq_of_rt_rq(rt_rq);</span>
<span class='curline'><a href='../S/450.html#L1095'>rq</a>               1095 sched/rt.c     	if (&amp;rq-&gt;rt != rt_rq)</span>
<span class='curline'><a href='../S/450.html#L1098'>rq</a>               1098 sched/rt.c     	if (rq-&gt;online &amp;&amp; prio &lt; prev_prio)</span>
<span class='curline'><a href='../S/450.html#L1099'>rq</a>               1099 sched/rt.c     		cpupri_set(&amp;rq-&gt;rd-&gt;cpupri, rq-&gt;cpu, prio);</span>
<span class='curline'><a href='../S/450.html#L1105'>rq</a>               1105 sched/rt.c     	struct rq *rq = rq_of_rt_rq(rt_rq);</span>
<span class='curline'><a href='../S/450.html#L1111'>rq</a>               1111 sched/rt.c     	if (&amp;rq-&gt;rt != rt_rq)</span>
<span class='curline'><a href='../S/450.html#L1114'>rq</a>               1114 sched/rt.c     	if (rq-&gt;online &amp;&amp; rt_rq-&gt;highest_prio.curr != prev_prio)</span>
<span class='curline'><a href='../S/450.html#L1115'>rq</a>               1115 sched/rt.c     		cpupri_set(&amp;rq-&gt;rd-&gt;cpupri, rq-&gt;cpu, rt_rq-&gt;highest_prio.curr);</span>
<span class='curline'><a href='../S/450.html#L1352'>rq</a>               1352 sched/rt.c     	struct rq *rq = rq_of_rt_se(rt_se);</span>
<span class='curline'><a href='../S/450.html#L1357'>rq</a>               1357 sched/rt.c     	enqueue_top_rt_rq(&amp;rq-&gt;rt);</span>
<span class='curline'><a href='../S/450.html#L1362'>rq</a>               1362 sched/rt.c     	struct rq *rq = rq_of_rt_se(rt_se);</span>
<span class='curline'><a href='../S/450.html#L1372'>rq</a>               1372 sched/rt.c     	enqueue_top_rt_rq(&amp;rq-&gt;rt);</span>
<span class='curline'><a href='../S/450.html#L1376'>rq</a>               1376 sched/rt.c     static inline bool should_honor_rt_sync(struct rq *rq, struct task_struct *p,</span>
<span class='curline'><a href='../S/450.html#L1384'>rq</a>               1384 sched/rt.c     	return sync &amp;&amp; task_has_rt_policy(rq-&gt;curr) &amp;&amp;</span>
<span class='curline'><a href='../S/450.html#L1385'>rq</a>               1385 sched/rt.c     		p-&gt;prio &lt;= rq-&gt;rt.highest_prio.next &amp;&amp;</span>
<span class='curline'><a href='../S/450.html#L1386'>rq</a>               1386 sched/rt.c     		rq-&gt;rt.rt_nr_running &lt;= 2;</span>
<span class='curline'><a href='../S/450.html#L1389'>rq</a>               1389 sched/rt.c     static inline bool should_honor_rt_sync(struct rq *rq, struct task_struct *p,</span>
<span class='curline'><a href='../S/450.html#L1400'>rq</a>               1400 sched/rt.c     enqueue_task_rt(struct rq *rq, struct task_struct *p, int flags)</span>
<span class='curline'><a href='../S/450.html#L1410'>rq</a>               1410 sched/rt.c     	if (!task_current(rq, p) &amp;&amp; p-&gt;nr_cpus_allowed &gt; 1 &amp;&amp;</span>
<span class='curline'><a href='../S/450.html#L1411'>rq</a>               1411 sched/rt.c     	    !should_honor_rt_sync(rq, p, sync))</span>
<span class='curline'><a href='../S/450.html#L1412'>rq</a>               1412 sched/rt.c     		enqueue_pushable_task(rq, p);</span>
<span class='curline'><a href='../S/450.html#L1415'>rq</a>               1415 sched/rt.c     static void dequeue_task_rt(struct rq *rq, struct task_struct *p, int flags)</span>
<span class='curline'><a href='../S/450.html#L1419'>rq</a>               1419 sched/rt.c     	update_curr_rt(rq);</span>
<span class='curline'><a href='../S/450.html#L1422'>rq</a>               1422 sched/rt.c     	dequeue_pushable_task(rq, p);</span>
<span class='curline'><a href='../S/450.html#L1443'>rq</a>               1443 sched/rt.c     static void requeue_task_rt(struct rq *rq, struct task_struct *p, int head)</span>
<span class='curline'><a href='../S/450.html#L1454'>rq</a>               1454 sched/rt.c     static void yield_task_rt(struct rq *rq)</span>
<span class='curline'><a href='../S/450.html#L1456'>rq</a>               1456 sched/rt.c     	requeue_task_rt(rq, rq-&gt;curr, 0);</span>
<span class='curline'><a href='../S/450.html#L1487'>rq</a>               1487 sched/rt.c     	struct rq *rq;</span>
<span class='curline'><a href='../S/450.html#L1488'>rq</a>               1488 sched/rt.c     	struct rq *this_cpu_rq;</span>
<span class='curline'><a href='../S/450.html#L1504'>rq</a>               1504 sched/rt.c     	rq = cpu_rq(cpu);</span>
<span class='curline'><a href='../S/450.html#L1507'>rq</a>               1507 sched/rt.c     	curr = READ_ONCE(rq-&gt;curr); /* unlocked access */</span>
<span class='curline'><a href='../S/450.html#L1585'>rq</a>               1585 sched/rt.c     static void check_preempt_equal_prio(struct rq *rq, struct task_struct *p)</span>
<span class='curline'><a href='../S/450.html#L1591'>rq</a>               1591 sched/rt.c     	if (rq-&gt;curr-&gt;nr_cpus_allowed == 1 ||</span>
<span class='curline'><a href='../S/450.html#L1592'>rq</a>               1592 sched/rt.c     	    !cpupri_find(&amp;rq-&gt;rd-&gt;cpupri, rq-&gt;curr, NULL))</span>
<span class='curline'><a href='../S/450.html#L1600'>rq</a>               1600 sched/rt.c     	    cpupri_find(&amp;rq-&gt;rd-&gt;cpupri, p, NULL))</span>
<span class='curline'><a href='../S/450.html#L1608'>rq</a>               1608 sched/rt.c     	requeue_task_rt(rq, p, 1);</span>
<span class='curline'><a href='../S/450.html#L1609'>rq</a>               1609 sched/rt.c     	resched_curr(rq);</span>
<span class='curline'><a href='../S/450.html#L1612'>rq</a>               1612 sched/rt.c     static int balance_rt(struct rq *rq, struct task_struct *p, struct rq_flags *rf)</span>
<span class='curline'><a href='../S/450.html#L1614'>rq</a>               1614 sched/rt.c     	if (!on_rt_rq(&amp;p-&gt;rt) &amp;&amp; need_pull_rt_task(rq, p)) {</span>
<span class='curline'><a href='../S/450.html#L1623'>rq</a>               1623 sched/rt.c     		rq_unpin_lock(rq, rf);</span>
<span class='curline'><a href='../S/450.html#L1624'>rq</a>               1624 sched/rt.c     		trace_android_rvh_sched_balance_rt(rq, p, &amp;done);</span>
<span class='curline'><a href='../S/450.html#L1626'>rq</a>               1626 sched/rt.c     			pull_rt_task(rq);</span>
<span class='curline'><a href='../S/450.html#L1627'>rq</a>               1627 sched/rt.c     		rq_repin_lock(rq, rf);</span>
<span class='curline'><a href='../S/450.html#L1630'>rq</a>               1630 sched/rt.c     	return sched_stop_runnable(rq) || sched_dl_runnable(rq) || sched_rt_runnable(rq);</span>
<span class='curline'><a href='../S/450.html#L1637'>rq</a>               1637 sched/rt.c     static void check_preempt_curr_rt(struct rq *rq, struct task_struct *p, int flags)</span>
<span class='curline'><a href='../S/450.html#L1639'>rq</a>               1639 sched/rt.c     	if (p-&gt;prio &lt; rq-&gt;curr-&gt;prio) {</span>
<span class='curline'><a href='../S/450.html#L1640'>rq</a>               1640 sched/rt.c     		resched_curr(rq);</span>
<span class='curline'><a href='../S/450.html#L1657'>rq</a>               1657 sched/rt.c     	if (p-&gt;prio == rq-&gt;curr-&gt;prio &amp;&amp; !test_tsk_need_resched(rq-&gt;curr))</span>
<span class='curline'><a href='../S/450.html#L1658'>rq</a>               1658 sched/rt.c     		check_preempt_equal_prio(rq, p);</span>
<span class='curline'><a href='../S/450.html#L1662'>rq</a>               1662 sched/rt.c     static inline void set_next_task_rt(struct rq *rq, struct task_struct *p, bool first)</span>
<span class='curline'><a href='../S/450.html#L1664'>rq</a>               1664 sched/rt.c     	p-&gt;se.exec_start = rq_clock_task(rq);</span>
<span class='curline'><a href='../S/450.html#L1667'>rq</a>               1667 sched/rt.c     	dequeue_pushable_task(rq, p);</span>
<span class='curline'><a href='../S/450.html#L1677'>rq</a>               1677 sched/rt.c     	if (rq-&gt;curr-&gt;sched_class != &amp;rt_sched_class)</span>
<span class='curline'><a href='../S/450.html#L1678'>rq</a>               1678 sched/rt.c     		update_rt_rq_load_avg(rq_clock_pelt(rq), rq, 0);</span>
<span class='curline'><a href='../S/450.html#L1680'>rq</a>               1680 sched/rt.c     	rt_queue_push_tasks(rq);</span>
<span class='curline'><a href='../S/450.html#L1683'>rq</a>               1683 sched/rt.c     static struct sched_rt_entity *pick_next_rt_entity(struct rq *rq,</span>
<span class='curline'><a href='../S/450.html#L1700'>rq</a>               1700 sched/rt.c     static struct task_struct *_pick_next_task_rt(struct rq *rq)</span>
<span class='curline'><a href='../S/450.html#L1703'>rq</a>               1703 sched/rt.c     	struct rt_rq *rt_rq  = &amp;rq-&gt;rt;</span>
<span class='curline'><a href='../S/450.html#L1706'>rq</a>               1706 sched/rt.c     		rt_se = pick_next_rt_entity(rq, rt_rq);</span>
<span class='curline'><a href='../S/450.html#L1714'>rq</a>               1714 sched/rt.c     static struct task_struct *pick_next_task_rt(struct rq *rq)</span>
<span class='curline'><a href='../S/450.html#L1718'>rq</a>               1718 sched/rt.c     	if (!sched_rt_runnable(rq))</span>
<span class='curline'><a href='../S/450.html#L1721'>rq</a>               1721 sched/rt.c     	p = _pick_next_task_rt(rq);</span>
<span class='curline'><a href='../S/450.html#L1722'>rq</a>               1722 sched/rt.c     	set_next_task_rt(rq, p, true);</span>
<span class='curline'><a href='../S/450.html#L1726'>rq</a>               1726 sched/rt.c     static void put_prev_task_rt(struct rq *rq, struct task_struct *p)</span>
<span class='curline'><a href='../S/450.html#L1728'>rq</a>               1728 sched/rt.c     	update_curr_rt(rq);</span>
<span class='curline'><a href='../S/450.html#L1730'>rq</a>               1730 sched/rt.c     	update_rt_rq_load_avg(rq_clock_pelt(rq), rq, 1);</span>
<span class='curline'><a href='../S/450.html#L1737'>rq</a>               1737 sched/rt.c     		enqueue_pushable_task(rq, p);</span>
<span class='curline'><a href='../S/450.html#L1745'>rq</a>               1745 sched/rt.c     static int pick_rt_task(struct rq *rq, struct task_struct *p, int cpu)</span>
<span class='curline'><a href='../S/450.html#L1747'>rq</a>               1747 sched/rt.c     	if (!task_running(rq, p) &amp;&amp;</span>
<span class='curline'><a href='../S/450.html#L1758'>rq</a>               1758 sched/rt.c     struct task_struct *pick_highest_pushable_task(struct rq *rq, int cpu)</span>
<span class='curline'><a href='../S/450.html#L1760'>rq</a>               1760 sched/rt.c     	struct plist_head *head = &amp;rq-&gt;rt.pushable_tasks;</span>
<span class='curline'><a href='../S/450.html#L1763'>rq</a>               1763 sched/rt.c     	if (!has_pushable_tasks(rq))</span>
<span class='curline'><a href='../S/450.html#L1767'>rq</a>               1767 sched/rt.c     		if (pick_rt_task(rq, p, cpu))</span>
<span class='curline'><a href='../S/450.html#L1875'>rq</a>               1875 sched/rt.c     static struct rq *find_lock_lowest_rq(struct task_struct *task, struct rq *rq)</span>
<span class='curline'><a href='../S/450.html#L1877'>rq</a>               1877 sched/rt.c     	struct rq *lowest_rq = NULL;</span>
<span class='curline'><a href='../S/450.html#L1884'>rq</a>               1884 sched/rt.c     		if ((cpu == -1) || (cpu == rq-&gt;cpu))</span>
<span class='curline'><a href='../S/450.html#L1900'>rq</a>               1900 sched/rt.c     		if (double_lock_balance(rq, lowest_rq)) {</span>
<span class='curline'><a href='../S/450.html#L1907'>rq</a>               1907 sched/rt.c     			if (unlikely(task_rq(task) != rq ||</span>
<span class='curline'><a href='../S/450.html#L1909'>rq</a>               1909 sched/rt.c     				     task_running(rq, task) ||</span>
<span class='curline'><a href='../S/450.html#L1913'>rq</a>               1913 sched/rt.c     				double_unlock_balance(rq, lowest_rq);</span>
<span class='curline'><a href='../S/450.html#L1924'>rq</a>               1924 sched/rt.c     		double_unlock_balance(rq, lowest_rq);</span>
<span class='curline'><a href='../S/450.html#L1931'>rq</a>               1931 sched/rt.c     static struct task_struct *pick_next_pushable_task(struct rq *rq)</span>
<span class='curline'><a href='../S/450.html#L1935'>rq</a>               1935 sched/rt.c     	if (!has_pushable_tasks(rq))</span>
<span class='curline'><a href='../S/450.html#L1938'>rq</a>               1938 sched/rt.c     	p = plist_first_entry(&amp;rq-&gt;rt.pushable_tasks,</span>
<span class='curline'><a href='../S/450.html#L1941'>rq</a>               1941 sched/rt.c     	BUG_ON(rq-&gt;cpu != task_cpu(p));</span>
<span class='curline'><a href='../S/450.html#L1942'>rq</a>               1942 sched/rt.c     	BUG_ON(task_current(rq, p));</span>
<span class='curline'><a href='../S/450.html#L1956'>rq</a>               1956 sched/rt.c     static int push_rt_task(struct rq *rq)</span>
<span class='curline'><a href='../S/450.html#L1959'>rq</a>               1959 sched/rt.c     	struct rq *lowest_rq;</span>
<span class='curline'><a href='../S/450.html#L1962'>rq</a>               1962 sched/rt.c     	if (!rq-&gt;rt.overloaded)</span>
<span class='curline'><a href='../S/450.html#L1965'>rq</a>               1965 sched/rt.c     	next_task = pick_next_pushable_task(rq);</span>
<span class='curline'><a href='../S/450.html#L1970'>rq</a>               1970 sched/rt.c     	if (WARN_ON(next_task == rq-&gt;curr))</span>
<span class='curline'><a href='../S/450.html#L1978'>rq</a>               1978 sched/rt.c     	if (unlikely(next_task-&gt;prio &lt; rq-&gt;curr-&gt;prio)) {</span>
<span class='curline'><a href='../S/450.html#L1979'>rq</a>               1979 sched/rt.c     		resched_curr(rq);</span>
<span class='curline'><a href='../S/450.html#L1987'>rq</a>               1987 sched/rt.c     	lowest_rq = find_lock_lowest_rq(next_task, rq);</span>
<span class='curline'><a href='../S/450.html#L1998'>rq</a>               1998 sched/rt.c     		task = pick_next_pushable_task(rq);</span>
<span class='curline'><a href='../S/450.html#L2021'>rq</a>               2021 sched/rt.c     	deactivate_task(rq, next_task, 0);</span>
<span class='curline'><a href='../S/450.html#L2028'>rq</a>               2028 sched/rt.c     	double_unlock_balance(rq, lowest_rq);</span>
<span class='curline'><a href='../S/450.html#L2036'>rq</a>               2036 sched/rt.c     static void push_rt_tasks(struct rq *rq)</span>
<span class='curline'><a href='../S/450.html#L2039'>rq</a>               2039 sched/rt.c     	while (push_rt_task(rq))</span>
<span class='curline'><a href='../S/450.html#L2143'>rq</a>               2143 sched/rt.c     static void tell_cpu_to_push(struct rq *rq)</span>
<span class='curline'><a href='../S/450.html#L2148'>rq</a>               2148 sched/rt.c     	atomic_inc(&amp;rq-&gt;rd-&gt;rto_loop_next);</span>
<span class='curline'><a href='../S/450.html#L2151'>rq</a>               2151 sched/rt.c     	if (!rto_start_trylock(&amp;rq-&gt;rd-&gt;rto_loop_start))</span>
<span class='curline'><a href='../S/450.html#L2154'>rq</a>               2154 sched/rt.c     	raw_spin_lock(&amp;rq-&gt;rd-&gt;rto_lock);</span>
<span class='curline'><a href='../S/450.html#L2162'>rq</a>               2162 sched/rt.c     	if (rq-&gt;rd-&gt;rto_cpu &lt; 0)</span>
<span class='curline'><a href='../S/450.html#L2163'>rq</a>               2163 sched/rt.c     		cpu = rto_next_cpu(rq-&gt;rd);</span>
<span class='curline'><a href='../S/450.html#L2165'>rq</a>               2165 sched/rt.c     	raw_spin_unlock(&amp;rq-&gt;rd-&gt;rto_lock);</span>
<span class='curline'><a href='../S/450.html#L2167'>rq</a>               2167 sched/rt.c     	rto_start_unlock(&amp;rq-&gt;rd-&gt;rto_loop_start);</span>
<span class='curline'><a href='../S/450.html#L2171'>rq</a>               2171 sched/rt.c     		sched_get_rd(rq-&gt;rd);</span>
<span class='curline'><a href='../S/450.html#L2172'>rq</a>               2172 sched/rt.c     		irq_work_queue_on(&amp;rq-&gt;rd-&gt;rto_push_work, cpu);</span>
<span class='curline'><a href='../S/450.html#L2181'>rq</a>               2181 sched/rt.c     	struct rq *rq;</span>
<span class='curline'><a href='../S/450.html#L2184'>rq</a>               2184 sched/rt.c     	rq = this_rq();</span>
<span class='curline'><a href='../S/450.html#L2190'>rq</a>               2190 sched/rt.c     	if (has_pushable_tasks(rq)) {</span>
<span class='curline'><a href='../S/450.html#L2191'>rq</a>               2191 sched/rt.c     		raw_spin_lock(&amp;rq-&gt;lock);</span>
<span class='curline'><a href='../S/450.html#L2192'>rq</a>               2192 sched/rt.c     		push_rt_tasks(rq);</span>
<span class='curline'><a href='../S/450.html#L2193'>rq</a>               2193 sched/rt.c     		raw_spin_unlock(&amp;rq-&gt;lock);</span>
<span class='curline'><a href='../S/450.html#L2213'>rq</a>               2213 sched/rt.c     static void pull_rt_task(struct rq *this_rq)</span>
<span class='curline'><a href='../S/450.html#L2218'>rq</a>               2218 sched/rt.c     	struct rq *src_rq;</span>
<span class='curline'><a href='../S/450.html#L2315'>rq</a>               2315 sched/rt.c     static void task_woken_rt(struct rq *rq, struct task_struct *p)</span>
<span class='curline'><a href='../S/450.html#L2317'>rq</a>               2317 sched/rt.c     	bool need_to_push = !task_running(rq, p) &amp;&amp;</span>
<span class='curline'><a href='../S/450.html#L2318'>rq</a>               2318 sched/rt.c     			    !test_tsk_need_resched(rq-&gt;curr) &amp;&amp;</span>
<span class='curline'><a href='../S/450.html#L2320'>rq</a>               2320 sched/rt.c     			    (dl_task(rq-&gt;curr) || rt_task(rq-&gt;curr)) &amp;&amp;</span>
<span class='curline'><a href='../S/450.html#L2321'>rq</a>               2321 sched/rt.c     			    (rq-&gt;curr-&gt;nr_cpus_allowed &lt; 2 ||</span>
<span class='curline'><a href='../S/450.html#L2322'>rq</a>               2322 sched/rt.c     			     rq-&gt;curr-&gt;prio &lt;= p-&gt;prio);</span>
<span class='curline'><a href='../S/450.html#L2325'>rq</a>               2325 sched/rt.c     		push_rt_tasks(rq);</span>
<span class='curline'><a href='../S/450.html#L2329'>rq</a>               2329 sched/rt.c     static void rq_online_rt(struct rq *rq)</span>
<span class='curline'><a href='../S/450.html#L2331'>rq</a>               2331 sched/rt.c     	if (rq-&gt;rt.overloaded)</span>
<span class='curline'><a href='../S/450.html#L2332'>rq</a>               2332 sched/rt.c     		rt_set_overload(rq);</span>
<span class='curline'><a href='../S/450.html#L2334'>rq</a>               2334 sched/rt.c     	__enable_runtime(rq);</span>
<span class='curline'><a href='../S/450.html#L2336'>rq</a>               2336 sched/rt.c     	cpupri_set(&amp;rq-&gt;rd-&gt;cpupri, rq-&gt;cpu, rq-&gt;rt.highest_prio.curr);</span>
<span class='curline'><a href='../S/450.html#L2340'>rq</a>               2340 sched/rt.c     static void rq_offline_rt(struct rq *rq)</span>
<span class='curline'><a href='../S/450.html#L2342'>rq</a>               2342 sched/rt.c     	if (rq-&gt;rt.overloaded)</span>
<span class='curline'><a href='../S/450.html#L2343'>rq</a>               2343 sched/rt.c     		rt_clear_overload(rq);</span>
<span class='curline'><a href='../S/450.html#L2345'>rq</a>               2345 sched/rt.c     	__disable_runtime(rq);</span>
<span class='curline'><a href='../S/450.html#L2347'>rq</a>               2347 sched/rt.c     	cpupri_set(&amp;rq-&gt;rd-&gt;cpupri, rq-&gt;cpu, CPUPRI_INVALID);</span>
<span class='curline'><a href='../S/450.html#L2354'>rq</a>               2354 sched/rt.c     static void switched_from_rt(struct rq *rq, struct task_struct *p)</span>
<span class='curline'><a href='../S/450.html#L2363'>rq</a>               2363 sched/rt.c     	if (!task_on_rq_queued(p) || rq-&gt;rt.rt_nr_running)</span>
<span class='curline'><a href='../S/450.html#L2366'>rq</a>               2366 sched/rt.c     	rt_queue_pull_task(rq);</span>
<span class='curline'><a href='../S/450.html#L2385'>rq</a>               2385 sched/rt.c     static void switched_to_rt(struct rq *rq, struct task_struct *p)</span>
<span class='curline'><a href='../S/450.html#L2394'>rq</a>               2394 sched/rt.c     	if (task_on_rq_queued(p) &amp;&amp; rq-&gt;curr != p) {</span>
<span class='curline'><a href='../S/450.html#L2396'>rq</a>               2396 sched/rt.c     		if (p-&gt;nr_cpus_allowed &gt; 1 &amp;&amp; rq-&gt;rt.overloaded)</span>
<span class='curline'><a href='../S/450.html#L2397'>rq</a>               2397 sched/rt.c     			rt_queue_push_tasks(rq);</span>
<span class='curline'><a href='../S/450.html#L2399'>rq</a>               2399 sched/rt.c     		if (p-&gt;prio &lt; rq-&gt;curr-&gt;prio &amp;&amp; cpu_online(cpu_of(rq)))</span>
<span class='curline'><a href='../S/450.html#L2400'>rq</a>               2400 sched/rt.c     			resched_curr(rq);</span>
<span class='curline'><a href='../S/450.html#L2409'>rq</a>               2409 sched/rt.c     prio_changed_rt(struct rq *rq, struct task_struct *p, int oldprio)</span>
<span class='curline'><a href='../S/450.html#L2414'>rq</a>               2414 sched/rt.c     	if (rq-&gt;curr == p) {</span>
<span class='curline'><a href='../S/450.html#L2421'>rq</a>               2421 sched/rt.c     			rt_queue_pull_task(rq);</span>
<span class='curline'><a href='../S/450.html#L2427'>rq</a>               2427 sched/rt.c     		if (p-&gt;prio &gt; rq-&gt;rt.highest_prio.curr)</span>
<span class='curline'><a href='../S/450.html#L2428'>rq</a>               2428 sched/rt.c     			resched_curr(rq);</span>
<span class='curline'><a href='../S/450.html#L2432'>rq</a>               2432 sched/rt.c     			resched_curr(rq);</span>
<span class='curline'><a href='../S/450.html#L2440'>rq</a>               2440 sched/rt.c     		if (p-&gt;prio &lt; rq-&gt;curr-&gt;prio)</span>
<span class='curline'><a href='../S/450.html#L2441'>rq</a>               2441 sched/rt.c     			resched_curr(rq);</span>
<span class='curline'><a href='../S/450.html#L2446'>rq</a>               2446 sched/rt.c     static void watchdog(struct rq *rq, struct task_struct *p)</span>
<span class='curline'><a href='../S/450.html#L2470'>rq</a>               2470 sched/rt.c     static inline void watchdog(struct rq *rq, struct task_struct *p) { }</span>
<span class='curline'><a href='../S/450.html#L2481'>rq</a>               2481 sched/rt.c     static void task_tick_rt(struct rq *rq, struct task_struct *p, int queued)</span>
<span class='curline'><a href='../S/450.html#L2485'>rq</a>               2485 sched/rt.c     	update_curr_rt(rq);</span>
<span class='curline'><a href='../S/450.html#L2486'>rq</a>               2486 sched/rt.c     	update_rt_rq_load_avg(rq_clock_pelt(rq), rq, 1);</span>
<span class='curline'><a href='../S/450.html#L2488'>rq</a>               2488 sched/rt.c     	watchdog(rq, p);</span>
<span class='curline'><a href='../S/450.html#L2508'>rq</a>               2508 sched/rt.c     			requeue_task_rt(rq, p, 0);</span>
<span class='curline'><a href='../S/450.html#L2509'>rq</a>               2509 sched/rt.c     			resched_curr(rq);</span>
<span class='curline'><a href='../S/450.html#L2515'>rq</a>               2515 sched/rt.c     static unsigned int get_rr_interval_rt(struct rq *rq, struct task_struct *task)</span>
<span class='curline'><a href='../S/447.html#L89'>rq</a>                 89 sched/sched.h  struct rq;</span>
<span class='curline'><a href='../S/447.html#L101'>rq</a>                101 sched/sched.h  extern void calc_global_load_tick(struct rq *this_rq);</span>
<span class='curline'><a href='../S/447.html#L102'>rq</a>                102 sched/sched.h  extern long calc_load_fold_active(struct rq *this_rq, long adjust);</span>
<span class='curline'><a href='../S/447.html#L104'>rq</a>                104 sched/sched.h  extern void call_trace_sched_update_nr_running(struct rq *rq, int count);</span>
<span class='curline'><a href='../S/447.html#L591'>rq</a>                591 sched/sched.h  	struct rq		*rq;	/* CPU runqueue to which this cfs_rq is attached */</span>
<span class='curline'><a href='../S/447.html#L660'>rq</a>                660 sched/sched.h  	struct rq		*rq;</span>
<span class='curline'><a href='../S/447.html#L853'>rq</a>                853 sched/sched.h  extern void rq_attach_root(struct rq *rq, struct root_domain *rd);</span>
<span class='curline'><a href='../S/447.html#L860'>rq</a>                860 sched/sched.h  extern struct task_struct *pick_highest_pushable_task(struct rq *rq, int cpu);</span>
<span class='curline'><a href='../S/447.html#L1089'>rq</a>               1089 sched/sched.h  static inline struct rq *rq_of(struct cfs_rq *cfs_rq)</span>
<span class='curline'><a href='../S/447.html#L1091'>rq</a>               1091 sched/sched.h  	return cfs_rq-&gt;rq;</span>
<span class='curline'><a href='../S/447.html#L1096'>rq</a>               1096 sched/sched.h  static inline struct rq *rq_of(struct cfs_rq *cfs_rq)</span>
<span class='curline'><a href='../S/447.html#L1098'>rq</a>               1098 sched/sched.h  	return container_of(cfs_rq, struct rq, cfs);</span>
<span class='curline'><a href='../S/447.html#L1102'>rq</a>               1102 sched/sched.h  static inline int cpu_of(struct rq *rq)</span>
<span class='curline'><a href='../S/447.html#L1105'>rq</a>               1105 sched/sched.h  	return rq-&gt;cpu;</span>
<span class='curline'><a href='../S/447.html#L1113'>rq</a>               1113 sched/sched.h  extern void __update_idle_core(struct rq *rq);</span>
<span class='curline'><a href='../S/447.html#L1115'>rq</a>               1115 sched/sched.h  static inline void update_idle_core(struct rq *rq)</span>
<span class='curline'><a href='../S/447.html#L1118'>rq</a>               1118 sched/sched.h  		__update_idle_core(rq);</span>
<span class='curline'><a href='../S/447.html#L1122'>rq</a>               1122 sched/sched.h  static inline void update_idle_core(struct rq *rq) { }</span>
<span class='curline'><a href='../S/447.html#L1125'>rq</a>               1125 sched/sched.h  DECLARE_PER_CPU_SHARED_ALIGNED(struct rq, runqueues);</span>
<span class='curline'><a href='../S/447.html#L1133'>rq</a>               1133 sched/sched.h  extern void update_rq_clock(struct rq *rq);</span>
<span class='curline'><a href='../S/447.html#L1135'>rq</a>               1135 sched/sched.h  static inline u64 __rq_clock_broken(struct rq *rq)</span>
<span class='curline'><a href='../S/447.html#L1137'>rq</a>               1137 sched/sched.h  	return READ_ONCE(rq-&gt;clock);</span>
<span class='curline'><a href='../S/447.html#L1167'>rq</a>               1167 sched/sched.h  static inline void assert_clock_updated(struct rq *rq)</span>
<span class='curline'><a href='../S/447.html#L1173'>rq</a>               1173 sched/sched.h  	SCHED_WARN_ON(rq-&gt;clock_update_flags &lt; RQCF_ACT_SKIP);</span>
<span class='curline'><a href='../S/447.html#L1176'>rq</a>               1176 sched/sched.h  static inline u64 rq_clock(struct rq *rq)</span>
<span class='curline'><a href='../S/447.html#L1178'>rq</a>               1178 sched/sched.h  	lockdep_assert_held(&amp;rq-&gt;lock);</span>
<span class='curline'><a href='../S/447.html#L1179'>rq</a>               1179 sched/sched.h  	assert_clock_updated(rq);</span>
<span class='curline'><a href='../S/447.html#L1181'>rq</a>               1181 sched/sched.h  	return rq-&gt;clock;</span>
<span class='curline'><a href='../S/447.html#L1184'>rq</a>               1184 sched/sched.h  static inline u64 rq_clock_task(struct rq *rq)</span>
<span class='curline'><a href='../S/447.html#L1186'>rq</a>               1186 sched/sched.h  	lockdep_assert_held(&amp;rq-&gt;lock);</span>
<span class='curline'><a href='../S/447.html#L1187'>rq</a>               1187 sched/sched.h  	assert_clock_updated(rq);</span>
<span class='curline'><a href='../S/447.html#L1189'>rq</a>               1189 sched/sched.h  	return rq-&gt;clock_task;</span>
<span class='curline'><a href='../S/447.html#L1205'>rq</a>               1205 sched/sched.h  static inline u64 rq_clock_thermal(struct rq *rq)</span>
<span class='curline'><a href='../S/447.html#L1207'>rq</a>               1207 sched/sched.h  	return rq_clock_task(rq) &gt;&gt; sched_thermal_decay_shift;</span>
<span class='curline'><a href='../S/447.html#L1210'>rq</a>               1210 sched/sched.h  static inline void rq_clock_skip_update(struct rq *rq)</span>
<span class='curline'><a href='../S/447.html#L1212'>rq</a>               1212 sched/sched.h  	lockdep_assert_held(&amp;rq-&gt;lock);</span>
<span class='curline'><a href='../S/447.html#L1213'>rq</a>               1213 sched/sched.h  	rq-&gt;clock_update_flags |= RQCF_REQ_SKIP;</span>
<span class='curline'><a href='../S/447.html#L1220'>rq</a>               1220 sched/sched.h  static inline void rq_clock_cancel_skipupdate(struct rq *rq)</span>
<span class='curline'><a href='../S/447.html#L1222'>rq</a>               1222 sched/sched.h  	lockdep_assert_held(&amp;rq-&gt;lock);</span>
<span class='curline'><a href='../S/447.html#L1223'>rq</a>               1223 sched/sched.h  	rq-&gt;clock_update_flags &amp;= ~RQCF_REQ_SKIP;</span>
<span class='curline'><a href='../S/447.html#L1249'>rq</a>               1249 sched/sched.h  static inline void rq_pin_lock(struct rq *rq, struct rq_flags *rf)</span>
<span class='curline'><a href='../S/447.html#L1251'>rq</a>               1251 sched/sched.h  	rf-&gt;cookie = lockdep_pin_lock(&amp;rq-&gt;lock);</span>
<span class='curline'><a href='../S/447.html#L1254'>rq</a>               1254 sched/sched.h  	rq-&gt;clock_update_flags &amp;= (RQCF_REQ_SKIP|RQCF_ACT_SKIP);</span>
<span class='curline'><a href='../S/447.html#L1259'>rq</a>               1259 sched/sched.h  static inline void rq_unpin_lock(struct rq *rq, struct rq_flags *rf)</span>
<span class='curline'><a href='../S/447.html#L1262'>rq</a>               1262 sched/sched.h  	if (rq-&gt;clock_update_flags &gt; RQCF_ACT_SKIP)</span>
<span class='curline'><a href='../S/447.html#L1266'>rq</a>               1266 sched/sched.h  	lockdep_unpin_lock(&amp;rq-&gt;lock, rf-&gt;cookie);</span>
<span class='curline'><a href='../S/447.html#L1269'>rq</a>               1269 sched/sched.h  static inline void rq_repin_lock(struct rq *rq, struct rq_flags *rf)</span>
<span class='curline'><a href='../S/447.html#L1271'>rq</a>               1271 sched/sched.h  	lockdep_repin_lock(&amp;rq-&gt;lock, rf-&gt;cookie);</span>
<span class='curline'><a href='../S/447.html#L1277'>rq</a>               1277 sched/sched.h  	rq-&gt;clock_update_flags |= rf-&gt;clock_update_flags;</span>
<span class='curline'><a href='../S/447.html#L1281'>rq</a>               1281 sched/sched.h  struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)</span>
<span class='curline'><a href='../S/447.html#L1282'>rq</a>               1282 sched/sched.h  	__acquires(rq-&gt;lock);</span>
<span class='curline'><a href='../S/447.html#L1284'>rq</a>               1284 sched/sched.h  struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)</span>
<span class='curline'><a href='../S/447.html#L1286'>rq</a>               1286 sched/sched.h  	__acquires(rq-&gt;lock);</span>
<span class='curline'><a href='../S/447.html#L1288'>rq</a>               1288 sched/sched.h  static inline void __task_rq_unlock(struct rq *rq, struct rq_flags *rf)</span>
<span class='curline'><a href='../S/447.html#L1289'>rq</a>               1289 sched/sched.h  	__releases(rq-&gt;lock)</span>
<span class='curline'><a href='../S/447.html#L1291'>rq</a>               1291 sched/sched.h  	rq_unpin_lock(rq, rf);</span>
<span class='curline'><a href='../S/447.html#L1292'>rq</a>               1292 sched/sched.h  	raw_spin_unlock(&amp;rq-&gt;lock);</span>
<span class='curline'><a href='../S/447.html#L1296'>rq</a>               1296 sched/sched.h  task_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)</span>
<span class='curline'><a href='../S/447.html#L1297'>rq</a>               1297 sched/sched.h  	__releases(rq-&gt;lock)</span>
<span class='curline'><a href='../S/447.html#L1300'>rq</a>               1300 sched/sched.h  	rq_unpin_lock(rq, rf);</span>
<span class='curline'><a href='../S/447.html#L1301'>rq</a>               1301 sched/sched.h  	raw_spin_unlock(&amp;rq-&gt;lock);</span>
<span class='curline'><a href='../S/447.html#L1306'>rq</a>               1306 sched/sched.h  rq_lock_irqsave(struct rq *rq, struct rq_flags *rf)</span>
<span class='curline'><a href='../S/447.html#L1307'>rq</a>               1307 sched/sched.h  	__acquires(rq-&gt;lock)</span>
<span class='curline'><a href='../S/447.html#L1309'>rq</a>               1309 sched/sched.h  	raw_spin_lock_irqsave(&amp;rq-&gt;lock, rf-&gt;flags);</span>
<span class='curline'><a href='../S/447.html#L1310'>rq</a>               1310 sched/sched.h  	rq_pin_lock(rq, rf);</span>
<span class='curline'><a href='../S/447.html#L1314'>rq</a>               1314 sched/sched.h  rq_lock_irq(struct rq *rq, struct rq_flags *rf)</span>
<span class='curline'><a href='../S/447.html#L1315'>rq</a>               1315 sched/sched.h  	__acquires(rq-&gt;lock)</span>
<span class='curline'><a href='../S/447.html#L1317'>rq</a>               1317 sched/sched.h  	raw_spin_lock_irq(&amp;rq-&gt;lock);</span>
<span class='curline'><a href='../S/447.html#L1318'>rq</a>               1318 sched/sched.h  	rq_pin_lock(rq, rf);</span>
<span class='curline'><a href='../S/447.html#L1322'>rq</a>               1322 sched/sched.h  rq_lock(struct rq *rq, struct rq_flags *rf)</span>
<span class='curline'><a href='../S/447.html#L1323'>rq</a>               1323 sched/sched.h  	__acquires(rq-&gt;lock)</span>
<span class='curline'><a href='../S/447.html#L1325'>rq</a>               1325 sched/sched.h  	raw_spin_lock(&amp;rq-&gt;lock);</span>
<span class='curline'><a href='../S/447.html#L1326'>rq</a>               1326 sched/sched.h  	rq_pin_lock(rq, rf);</span>
<span class='curline'><a href='../S/447.html#L1330'>rq</a>               1330 sched/sched.h  rq_relock(struct rq *rq, struct rq_flags *rf)</span>
<span class='curline'><a href='../S/447.html#L1331'>rq</a>               1331 sched/sched.h  	__acquires(rq-&gt;lock)</span>
<span class='curline'><a href='../S/447.html#L1333'>rq</a>               1333 sched/sched.h  	raw_spin_lock(&amp;rq-&gt;lock);</span>
<span class='curline'><a href='../S/447.html#L1334'>rq</a>               1334 sched/sched.h  	rq_repin_lock(rq, rf);</span>
<span class='curline'><a href='../S/447.html#L1338'>rq</a>               1338 sched/sched.h  rq_unlock_irqrestore(struct rq *rq, struct rq_flags *rf)</span>
<span class='curline'><a href='../S/447.html#L1339'>rq</a>               1339 sched/sched.h  	__releases(rq-&gt;lock)</span>
<span class='curline'><a href='../S/447.html#L1341'>rq</a>               1341 sched/sched.h  	rq_unpin_lock(rq, rf);</span>
<span class='curline'><a href='../S/447.html#L1342'>rq</a>               1342 sched/sched.h  	raw_spin_unlock_irqrestore(&amp;rq-&gt;lock, rf-&gt;flags);</span>
<span class='curline'><a href='../S/447.html#L1346'>rq</a>               1346 sched/sched.h  rq_unlock_irq(struct rq *rq, struct rq_flags *rf)</span>
<span class='curline'><a href='../S/447.html#L1347'>rq</a>               1347 sched/sched.h  	__releases(rq-&gt;lock)</span>
<span class='curline'><a href='../S/447.html#L1349'>rq</a>               1349 sched/sched.h  	rq_unpin_lock(rq, rf);</span>
<span class='curline'><a href='../S/447.html#L1350'>rq</a>               1350 sched/sched.h  	raw_spin_unlock_irq(&amp;rq-&gt;lock);</span>
<span class='curline'><a href='../S/447.html#L1354'>rq</a>               1354 sched/sched.h  rq_unlock(struct rq *rq, struct rq_flags *rf)</span>
<span class='curline'><a href='../S/447.html#L1355'>rq</a>               1355 sched/sched.h  	__releases(rq-&gt;lock)</span>
<span class='curline'><a href='../S/447.html#L1357'>rq</a>               1357 sched/sched.h  	rq_unpin_lock(rq, rf);</span>
<span class='curline'><a href='../S/447.html#L1358'>rq</a>               1358 sched/sched.h  	raw_spin_unlock(&amp;rq-&gt;lock);</span>
<span class='curline'><a href='../S/447.html#L1361'>rq</a>               1361 sched/sched.h  static inline struct rq *</span>
<span class='curline'><a href='../S/447.html#L1363'>rq</a>               1363 sched/sched.h  	__acquires(rq-&gt;lock)</span>
<span class='curline'><a href='../S/447.html#L1365'>rq</a>               1365 sched/sched.h  	struct rq *rq;</span>
<span class='curline'><a href='../S/447.html#L1368'>rq</a>               1368 sched/sched.h  	rq = this_rq();</span>
<span class='curline'><a href='../S/447.html#L1369'>rq</a>               1369 sched/sched.h  	rq_lock(rq, rf);</span>
<span class='curline'><a href='../S/447.html#L1370'>rq</a>               1370 sched/sched.h  	return rq;</span>
<span class='curline'><a href='../S/447.html#L1419'>rq</a>               1419 sched/sched.h  queue_balance_callback(struct rq *rq,</span>
<span class='curline'><a href='../S/447.html#L1421'>rq</a>               1421 sched/sched.h  		       void (*func)(struct rq *rq))</span>
<span class='curline'><a href='../S/447.html#L1423'>rq</a>               1423 sched/sched.h  	lockdep_assert_held(&amp;rq-&gt;lock);</span>
<span class='curline'><a href='../S/447.html#L1429'>rq</a>               1429 sched/sched.h  	head-&gt;next = rq-&gt;balance_callback;</span>
<span class='curline'><a href='../S/447.html#L1430'>rq</a>               1430 sched/sched.h  	rq-&gt;balance_callback = head;</span>
<span class='curline'><a href='../S/447.html#L1728'>rq</a>               1728 sched/sched.h  static inline int task_current(struct rq *rq, struct task_struct *p)</span>
<span class='curline'><a href='../S/447.html#L1730'>rq</a>               1730 sched/sched.h  	return rq-&gt;curr == p;</span>
<span class='curline'><a href='../S/447.html#L1733'>rq</a>               1733 sched/sched.h  static inline int task_running(struct rq *rq, struct task_struct *p)</span>
<span class='curline'><a href='../S/447.html#L1738'>rq</a>               1738 sched/sched.h  	return task_current(rq, p);</span>
<span class='curline'><a href='../S/447.html#L1823'>rq</a>               1823 sched/sched.h  	void (*enqueue_task) (struct rq *rq, struct task_struct *p, int flags);</span>
<span class='curline'><a href='../S/447.html#L1824'>rq</a>               1824 sched/sched.h  	void (*dequeue_task) (struct rq *rq, struct task_struct *p, int flags);</span>
<span class='curline'><a href='../S/447.html#L1825'>rq</a>               1825 sched/sched.h  	void (*yield_task)   (struct rq *rq);</span>
<span class='curline'><a href='../S/447.html#L1826'>rq</a>               1826 sched/sched.h  	bool (*yield_to_task)(struct rq *rq, struct task_struct *p);</span>
<span class='curline'><a href='../S/447.html#L1828'>rq</a>               1828 sched/sched.h  	void (*check_preempt_curr)(struct rq *rq, struct task_struct *p, int flags);</span>
<span class='curline'><a href='../S/447.html#L1830'>rq</a>               1830 sched/sched.h  	struct task_struct *(*pick_next_task)(struct rq *rq);</span>
<span class='curline'><a href='../S/447.html#L1832'>rq</a>               1832 sched/sched.h  	void (*put_prev_task)(struct rq *rq, struct task_struct *p);</span>
<span class='curline'><a href='../S/447.html#L1833'>rq</a>               1833 sched/sched.h  	void (*set_next_task)(struct rq *rq, struct task_struct *p, bool first);</span>
<span class='curline'><a href='../S/447.html#L1836'>rq</a>               1836 sched/sched.h  	int (*balance)(struct rq *rq, struct task_struct *prev, struct rq_flags *rf);</span>
<span class='curline'><a href='../S/447.html#L1840'>rq</a>               1840 sched/sched.h  	void (*task_woken)(struct rq *this_rq, struct task_struct *task);</span>
<span class='curline'><a href='../S/447.html#L1845'>rq</a>               1845 sched/sched.h  	void (*rq_online)(struct rq *rq);</span>
<span class='curline'><a href='../S/447.html#L1846'>rq</a>               1846 sched/sched.h  	void (*rq_offline)(struct rq *rq);</span>
<span class='curline'><a href='../S/447.html#L1849'>rq</a>               1849 sched/sched.h  	void (*task_tick)(struct rq *rq, struct task_struct *p, int queued);</span>
<span class='curline'><a href='../S/447.html#L1858'>rq</a>               1858 sched/sched.h  	void (*switched_from)(struct rq *this_rq, struct task_struct *task);</span>
<span class='curline'><a href='../S/447.html#L1859'>rq</a>               1859 sched/sched.h  	void (*switched_to)  (struct rq *this_rq, struct task_struct *task);</span>
<span class='curline'><a href='../S/447.html#L1860'>rq</a>               1860 sched/sched.h  	void (*prio_changed) (struct rq *this_rq, struct task_struct *task,</span>
<span class='curline'><a href='../S/447.html#L1863'>rq</a>               1863 sched/sched.h  	unsigned int (*get_rr_interval)(struct rq *rq,</span>
<span class='curline'><a href='../S/447.html#L1866'>rq</a>               1866 sched/sched.h  	void (*update_curr)(struct rq *rq);</span>
<span class='curline'><a href='../S/447.html#L1876'>rq</a>               1876 sched/sched.h  static inline void put_prev_task(struct rq *rq, struct task_struct *prev)</span>
<span class='curline'><a href='../S/447.html#L1878'>rq</a>               1878 sched/sched.h  	WARN_ON_ONCE(rq-&gt;curr != prev);</span>
<span class='curline'><a href='../S/447.html#L1879'>rq</a>               1879 sched/sched.h  	prev-&gt;sched_class-&gt;put_prev_task(rq, prev);</span>
<span class='curline'><a href='../S/447.html#L1882'>rq</a>               1882 sched/sched.h  static inline void set_next_task(struct rq *rq, struct task_struct *next)</span>
<span class='curline'><a href='../S/447.html#L1884'>rq</a>               1884 sched/sched.h  	WARN_ON_ONCE(rq-&gt;curr != next);</span>
<span class='curline'><a href='../S/447.html#L1885'>rq</a>               1885 sched/sched.h  	next-&gt;sched_class-&gt;set_next_task(rq, next, false);</span>
<span class='curline'><a href='../S/447.html#L1907'>rq</a>               1907 sched/sched.h  static inline bool sched_stop_runnable(struct rq *rq)</span>
<span class='curline'><a href='../S/447.html#L1909'>rq</a>               1909 sched/sched.h  	return rq-&gt;stop &amp;&amp; task_on_rq_queued(rq-&gt;stop);</span>
<span class='curline'><a href='../S/447.html#L1912'>rq</a>               1912 sched/sched.h  static inline bool sched_dl_runnable(struct rq *rq)</span>
<span class='curline'><a href='../S/447.html#L1914'>rq</a>               1914 sched/sched.h  	return rq-&gt;dl.dl_nr_running &gt; 0;</span>
<span class='curline'><a href='../S/447.html#L1917'>rq</a>               1917 sched/sched.h  static inline bool sched_rt_runnable(struct rq *rq)</span>
<span class='curline'><a href='../S/447.html#L1919'>rq</a>               1919 sched/sched.h  	return rq-&gt;rt.rt_queued &gt; 0;</span>
<span class='curline'><a href='../S/447.html#L1922'>rq</a>               1922 sched/sched.h  static inline bool sched_fair_runnable(struct rq *rq)</span>
<span class='curline'><a href='../S/447.html#L1924'>rq</a>               1924 sched/sched.h  	return rq-&gt;cfs.nr_running &gt; 0;</span>
<span class='curline'><a href='../S/447.html#L1927'>rq</a>               1927 sched/sched.h  extern struct task_struct *pick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf);</span>
<span class='curline'><a href='../S/447.html#L1928'>rq</a>               1928 sched/sched.h  extern struct task_struct *pick_next_task_idle(struct rq *rq);</span>
<span class='curline'><a href='../S/447.html#L1934'>rq</a>               1934 sched/sched.h  extern void trigger_load_balance(struct rq *rq);</span>
<span class='curline'><a href='../S/447.html#L1942'>rq</a>               1942 sched/sched.h  static inline void idle_set_state(struct rq *rq,</span>
<span class='curline'><a href='../S/447.html#L1945'>rq</a>               1945 sched/sched.h  	rq-&gt;idle_state = idle_state;</span>
<span class='curline'><a href='../S/447.html#L1948'>rq</a>               1948 sched/sched.h  static inline struct cpuidle_state *idle_get_state(struct rq *rq)</span>
<span class='curline'><a href='../S/447.html#L1952'>rq</a>               1952 sched/sched.h  	return rq-&gt;idle_state;</span>
<span class='curline'><a href='../S/447.html#L1955'>rq</a>               1955 sched/sched.h  static inline void idle_set_state(struct rq *rq,</span>
<span class='curline'><a href='../S/447.html#L1960'>rq</a>               1960 sched/sched.h  static inline struct cpuidle_state *idle_get_state(struct rq *rq)</span>
<span class='curline'><a href='../S/447.html#L1978'>rq</a>               1978 sched/sched.h  extern void resched_curr(struct rq *rq);</span>
<span class='curline'><a href='../S/447.html#L2000'>rq</a>               2000 sched/sched.h  extern bool sched_can_stop_tick(struct rq *rq);</span>
<span class='curline'><a href='../S/447.html#L2008'>rq</a>               2008 sched/sched.h  static inline void sched_update_tick_dependency(struct rq *rq)</span>
<span class='curline'><a href='../S/447.html#L2010'>rq</a>               2010 sched/sched.h  	int cpu = cpu_of(rq);</span>
<span class='curline'><a href='../S/447.html#L2015'>rq</a>               2015 sched/sched.h  	if (sched_can_stop_tick(rq))</span>
<span class='curline'><a href='../S/447.html#L2022'>rq</a>               2022 sched/sched.h  static inline void sched_update_tick_dependency(struct rq *rq) { }</span>
<span class='curline'><a href='../S/447.html#L2025'>rq</a>               2025 sched/sched.h  static inline void add_nr_running(struct rq *rq, unsigned count)</span>
<span class='curline'><a href='../S/447.html#L2027'>rq</a>               2027 sched/sched.h  	unsigned prev_nr = rq-&gt;nr_running;</span>
<span class='curline'><a href='../S/447.html#L2029'>rq</a>               2029 sched/sched.h  	rq-&gt;nr_running = prev_nr + count;</span>
<span class='curline'><a href='../S/447.html#L2031'>rq</a>               2031 sched/sched.h  		call_trace_sched_update_nr_running(rq, count);</span>
<span class='curline'><a href='../S/447.html#L2035'>rq</a>               2035 sched/sched.h  	if (prev_nr &lt; 2 &amp;&amp; rq-&gt;nr_running &gt;= 2) {</span>
<span class='curline'><a href='../S/447.html#L2036'>rq</a>               2036 sched/sched.h  		if (!READ_ONCE(rq-&gt;rd-&gt;overload))</span>
<span class='curline'><a href='../S/447.html#L2037'>rq</a>               2037 sched/sched.h  			WRITE_ONCE(rq-&gt;rd-&gt;overload, 1);</span>
<span class='curline'><a href='../S/447.html#L2041'>rq</a>               2041 sched/sched.h  	sched_update_tick_dependency(rq);</span>
<span class='curline'><a href='../S/447.html#L2044'>rq</a>               2044 sched/sched.h  static inline void sub_nr_running(struct rq *rq, unsigned count)</span>
<span class='curline'><a href='../S/447.html#L2046'>rq</a>               2046 sched/sched.h  	rq-&gt;nr_running -= count;</span>
<span class='curline'><a href='../S/447.html#L2048'>rq</a>               2048 sched/sched.h  		call_trace_sched_update_nr_running(rq, -count);</span>
<span class='curline'><a href='../S/447.html#L2052'>rq</a>               2052 sched/sched.h  	sched_update_tick_dependency(rq);</span>
<span class='curline'><a href='../S/447.html#L2055'>rq</a>               2055 sched/sched.h  extern void activate_task(struct rq *rq, struct task_struct *p, int flags);</span>
<span class='curline'><a href='../S/447.html#L2056'>rq</a>               2056 sched/sched.h  extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);</span>
<span class='curline'><a href='../S/447.html#L2058'>rq</a>               2058 sched/sched.h  extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);</span>
<span class='curline'><a href='../S/447.html#L2070'>rq</a>               2070 sched/sched.h  static inline int hrtick_enabled(struct rq *rq)</span>
<span class='curline'><a href='../S/447.html#L2074'>rq</a>               2074 sched/sched.h  	if (!cpu_active(cpu_of(rq)))</span>
<span class='curline'><a href='../S/447.html#L2076'>rq</a>               2076 sched/sched.h  	return hrtimer_is_hres_active(&amp;rq-&gt;hrtick_timer);</span>
<span class='curline'><a href='../S/447.html#L2079'>rq</a>               2079 sched/sched.h  void hrtick_start(struct rq *rq, u64 delay);</span>
<span class='curline'><a href='../S/447.html#L2083'>rq</a>               2083 sched/sched.h  static inline int hrtick_enabled(struct rq *rq)</span>
<span class='curline'><a href='../S/447.html#L2118'>rq</a>               2118 sched/sched.h  static inline void double_rq_lock(struct rq *rq1, struct rq *rq2);</span>
<span class='curline'><a href='../S/447.html#L2128'>rq</a>               2128 sched/sched.h  static inline int _double_lock_balance(struct rq *this_rq, struct rq *busiest)</span>
<span class='curline'><a href='../S/447.html#L2147'>rq</a>               2147 sched/sched.h  static inline int _double_lock_balance(struct rq *this_rq, struct rq *busiest)</span>
<span class='curline'><a href='../S/447.html#L2173'>rq</a>               2173 sched/sched.h  static inline int double_lock_balance(struct rq *this_rq, struct rq *busiest)</span>
<span class='curline'><a href='../S/447.html#L2184'>rq</a>               2184 sched/sched.h  static inline void double_unlock_balance(struct rq *this_rq, struct rq *busiest)</span>
<span class='curline'><a href='../S/447.html#L2224'>rq</a>               2224 sched/sched.h  static inline void double_rq_lock(struct rq *rq1, struct rq *rq2)</span>
<span class='curline'><a href='../S/447.html#L2249'>rq</a>               2249 sched/sched.h  static inline void double_rq_unlock(struct rq *rq1, struct rq *rq2)</span>
<span class='curline'><a href='../S/447.html#L2260'>rq</a>               2260 sched/sched.h  extern void set_rq_online (struct rq *rq);</span>
<span class='curline'><a href='../S/447.html#L2261'>rq</a>               2261 sched/sched.h  extern void set_rq_offline(struct rq *rq);</span>
<span class='curline'><a href='../S/447.html#L2272'>rq</a>               2272 sched/sched.h  static inline void double_rq_lock(struct rq *rq1, struct rq *rq2)</span>
<span class='curline'><a href='../S/447.html#L2288'>rq</a>               2288 sched/sched.h  static inline void double_rq_unlock(struct rq *rq1, struct rq *rq2)</span>
<span class='curline'><a href='../S/447.html#L2338'>rq</a>               2338 sched/sched.h  extern void nohz_balance_exit_idle(struct rq *rq);</span>
<span class='curline'><a href='../S/447.html#L2340'>rq</a>               2340 sched/sched.h  static inline void nohz_balance_exit_idle(struct rq *rq) { }</span>
<span class='curline'><a href='../S/447.html#L2354'>rq</a>               2354 sched/sched.h  		struct rq *rq = cpu_rq(i);</span>
<span class='curline'><a href='../S/447.html#L2356'>rq</a>               2356 sched/sched.h  		rq-&gt;dl.extra_bw += bw;</span>
<span class='curline'><a href='../S/447.html#L2425'>rq</a>               2425 sched/sched.h  static inline void cpufreq_update_util(struct rq *rq, unsigned int flags)</span>
<span class='curline'><a href='../S/447.html#L2430'>rq</a>               2430 sched/sched.h  						  cpu_of(rq)));</span>
<span class='curline'><a href='../S/447.html#L2432'>rq</a>               2432 sched/sched.h  		data-&gt;func(data, rq_clock(rq), flags);</span>
<span class='curline'><a href='../S/447.html#L2435'>rq</a>               2435 sched/sched.h  static inline void cpufreq_update_util(struct rq *rq, unsigned int flags) {}</span>
<span class='curline'><a href='../S/447.html#L2459'>rq</a>               2459 sched/sched.h  unsigned long uclamp_rq_util_with(struct rq *rq, unsigned long util,</span>
<span class='curline'><a href='../S/447.html#L2468'>rq</a>               2468 sched/sched.h  	min_util = READ_ONCE(rq-&gt;uclamp[UCLAMP_MIN].value);</span>
<span class='curline'><a href='../S/447.html#L2469'>rq</a>               2469 sched/sched.h  	max_util = READ_ONCE(rq-&gt;uclamp[UCLAMP_MAX].value);</span>
<span class='curline'><a href='../S/447.html#L2506'>rq</a>               2506 sched/sched.h  unsigned long uclamp_rq_util_with(struct rq *rq, unsigned long util,</span>
<span class='curline'><a href='../S/447.html#L2578'>rq</a>               2578 sched/sched.h  static inline unsigned long cpu_bw_dl(struct rq *rq)</span>
<span class='curline'><a href='../S/447.html#L2580'>rq</a>               2580 sched/sched.h  	return (rq-&gt;dl.running_bw * SCHED_CAPACITY_SCALE) &gt;&gt; BW_SHIFT;</span>
<span class='curline'><a href='../S/447.html#L2583'>rq</a>               2583 sched/sched.h  static inline unsigned long cpu_util_dl(struct rq *rq)</span>
<span class='curline'><a href='../S/447.html#L2585'>rq</a>               2585 sched/sched.h  	return READ_ONCE(rq-&gt;avg_dl.util_avg);</span>
<span class='curline'><a href='../S/447.html#L2588'>rq</a>               2588 sched/sched.h  static inline unsigned long cpu_util_cfs(struct rq *rq)</span>
<span class='curline'><a href='../S/447.html#L2590'>rq</a>               2590 sched/sched.h  	unsigned long util = READ_ONCE(rq-&gt;cfs.avg.util_avg);</span>
<span class='curline'><a href='../S/447.html#L2594'>rq</a>               2594 sched/sched.h  			     READ_ONCE(rq-&gt;cfs.avg.util_est.enqueued));</span>
<span class='curline'><a href='../S/447.html#L2600'>rq</a>               2600 sched/sched.h  static inline unsigned long cpu_util_rt(struct rq *rq)</span>
<span class='curline'><a href='../S/447.html#L2602'>rq</a>               2602 sched/sched.h  	return READ_ONCE(rq-&gt;avg_rt.util_avg);</span>
<span class='curline'><a href='../S/447.html#L2614'>rq</a>               2614 sched/sched.h  static inline unsigned long cpu_util_irq(struct rq *rq)</span>
<span class='curline'><a href='../S/447.html#L2616'>rq</a>               2616 sched/sched.h  	return rq-&gt;avg_irq.util_avg;</span>
<span class='curline'><a href='../S/447.html#L2629'>rq</a>               2629 sched/sched.h  static inline unsigned long cpu_util_irq(struct rq *rq)</span>
<span class='curline'><a href='../S/447.html#L2666'>rq</a>               2666 sched/sched.h  static inline void membarrier_switch_mm(struct rq *rq,</span>
<span class='curline'><a href='../S/447.html#L2676'>rq</a>               2676 sched/sched.h  	if (READ_ONCE(rq-&gt;membarrier_state) == membarrier_state)</span>
<span class='curline'><a href='../S/447.html#L2679'>rq</a>               2679 sched/sched.h  	WRITE_ONCE(rq-&gt;membarrier_state, membarrier_state);</span>
<span class='curline'><a href='../S/447.html#L2682'>rq</a>               2682 sched/sched.h  static inline void membarrier_switch_mm(struct rq *rq,</span>
<span class='curline'><a href='../S/472.html#L23'>rq</a>                 23 sched/stats.c  		struct rq *rq;</span>
<span class='curline'><a href='../S/472.html#L29'>rq</a>                 29 sched/stats.c  		rq = cpu_rq(cpu);</span>
<span class='curline'><a href='../S/472.html#L34'>rq</a>                 34 sched/stats.c  		    cpu, rq-&gt;yld_count,</span>
<span class='curline'><a href='../S/472.html#L35'>rq</a>                 35 sched/stats.c  		    rq-&gt;sched_count, rq-&gt;sched_goidle,</span>
<span class='curline'><a href='../S/472.html#L36'>rq</a>                 36 sched/stats.c  		    rq-&gt;ttwu_count, rq-&gt;ttwu_local,</span>
<span class='curline'><a href='../S/472.html#L37'>rq</a>                 37 sched/stats.c  		    rq-&gt;rq_cpu_time,</span>
<span class='curline'><a href='../S/472.html#L38'>rq</a>                 38 sched/stats.c  		    rq-&gt;rq_sched_info.run_delay, rq-&gt;rq_sched_info.pcount);</span>
<span class='curline'><a href='../S/461.html#L9'>rq</a>                  9 sched/stats.h  rq_sched_info_arrive(struct rq *rq, unsigned long long delta)</span>
<span class='curline'><a href='../S/461.html#L11'>rq</a>                 11 sched/stats.h  	if (rq) {</span>
<span class='curline'><a href='../S/461.html#L12'>rq</a>                 12 sched/stats.h  		rq-&gt;rq_sched_info.run_delay += delta;</span>
<span class='curline'><a href='../S/461.html#L13'>rq</a>                 13 sched/stats.h  		rq-&gt;rq_sched_info.pcount++;</span>
<span class='curline'><a href='../S/461.html#L21'>rq</a>                 21 sched/stats.h  rq_sched_info_depart(struct rq *rq, unsigned long long delta)</span>
<span class='curline'><a href='../S/461.html#L23'>rq</a>                 23 sched/stats.h  	if (rq)</span>
<span class='curline'><a href='../S/461.html#L24'>rq</a>                 24 sched/stats.h  		rq-&gt;rq_cpu_time += delta;</span>
<span class='curline'><a href='../S/461.html#L28'>rq</a>                 28 sched/stats.h  rq_sched_info_dequeued(struct rq *rq, unsigned long long delta)</span>
<span class='curline'><a href='../S/461.html#L30'>rq</a>                 30 sched/stats.h  	if (rq)</span>
<span class='curline'><a href='../S/461.html#L31'>rq</a>                 31 sched/stats.h  		rq-&gt;rq_sched_info.run_delay += delta;</span>
<span class='curline'><a href='../S/461.html#L44'>rq</a>                 44 sched/stats.h  static inline void rq_sched_info_arrive  (struct rq *rq, unsigned long long delta) { }</span>
<span class='curline'><a href='../S/461.html#L45'>rq</a>                 45 sched/stats.h  static inline void rq_sched_info_dequeued(struct rq *rq, unsigned long long delta) { }</span>
<span class='curline'><a href='../S/461.html#L46'>rq</a>                 46 sched/stats.h  static inline void rq_sched_info_depart  (struct rq *rq, unsigned long long delta) { }</span>
<span class='curline'><a href='../S/461.html#L122'>rq</a>                122 sched/stats.h  		struct rq *rq;</span>
<span class='curline'><a href='../S/461.html#L130'>rq</a>                130 sched/stats.h  		rq = __task_rq_lock(p, &amp;rf);</span>
<span class='curline'><a href='../S/461.html#L133'>rq</a>                133 sched/stats.h  		__task_rq_unlock(rq, &amp;rf);</span>
<span class='curline'><a href='../S/461.html#L147'>rq</a>                147 sched/stats.h  static inline void psi_task_tick(struct rq *rq)</span>
<span class='curline'><a href='../S/461.html#L152'>rq</a>                152 sched/stats.h  	if (unlikely(rq-&gt;curr-&gt;in_memstall))</span>
<span class='curline'><a href='../S/461.html#L153'>rq</a>                153 sched/stats.h  		psi_memstall_tick(rq-&gt;curr, cpu_of(rq));</span>
<span class='curline'><a href='../S/461.html#L162'>rq</a>                162 sched/stats.h  static inline void psi_task_tick(struct rq *rq) {}</span>
<span class='curline'><a href='../S/461.html#L177'>rq</a>                177 sched/stats.h  static inline void sched_info_dequeued(struct rq *rq, struct task_struct *t)</span>
<span class='curline'><a href='../S/461.html#L179'>rq</a>                179 sched/stats.h  	unsigned long long now = rq_clock(rq), delta = 0;</span>
<span class='curline'><a href='../S/461.html#L188'>rq</a>                188 sched/stats.h  	rq_sched_info_dequeued(rq, delta);</span>
<span class='curline'><a href='../S/461.html#L196'>rq</a>                196 sched/stats.h  static void sched_info_arrive(struct rq *rq, struct task_struct *t)</span>
<span class='curline'><a href='../S/461.html#L198'>rq</a>                198 sched/stats.h  	unsigned long long now = rq_clock(rq), delta = 0;</span>
<span class='curline'><a href='../S/461.html#L207'>rq</a>                207 sched/stats.h  	rq_sched_info_arrive(rq, delta);</span>
<span class='curline'><a href='../S/461.html#L215'>rq</a>                215 sched/stats.h  static inline void sched_info_queued(struct rq *rq, struct task_struct *t)</span>
<span class='curline'><a href='../S/461.html#L219'>rq</a>                219 sched/stats.h  			t-&gt;sched_info.last_queued = rq_clock(rq);</span>
<span class='curline'><a href='../S/461.html#L231'>rq</a>                231 sched/stats.h  static inline void sched_info_depart(struct rq *rq, struct task_struct *t)</span>
<span class='curline'><a href='../S/461.html#L233'>rq</a>                233 sched/stats.h  	unsigned long long delta = rq_clock(rq) - t-&gt;sched_info.last_arrival;</span>
<span class='curline'><a href='../S/461.html#L235'>rq</a>                235 sched/stats.h  	rq_sched_info_depart(rq, delta);</span>
<span class='curline'><a href='../S/461.html#L238'>rq</a>                238 sched/stats.h  		sched_info_queued(rq, t);</span>
<span class='curline'><a href='../S/461.html#L247'>rq</a>                247 sched/stats.h  __sched_info_switch(struct rq *rq, struct task_struct *prev, struct task_struct *next)</span>
<span class='curline'><a href='../S/461.html#L254'>rq</a>                254 sched/stats.h  	if (prev != rq-&gt;idle)</span>
<span class='curline'><a href='../S/461.html#L255'>rq</a>                255 sched/stats.h  		sched_info_depart(rq, prev);</span>
<span class='curline'><a href='../S/461.html#L257'>rq</a>                257 sched/stats.h  	if (next != rq-&gt;idle)</span>
<span class='curline'><a href='../S/461.html#L258'>rq</a>                258 sched/stats.h  		sched_info_arrive(rq, next);</span>
<span class='curline'><a href='../S/461.html#L262'>rq</a>                262 sched/stats.h  sched_info_switch(struct rq *rq, struct task_struct *prev, struct task_struct *next)</span>
<span class='curline'><a href='../S/461.html#L265'>rq</a>                265 sched/stats.h  		__sched_info_switch(rq, prev, next);</span>
<span class='curline'><a href='../S/461.html#L269'>rq</a>                269 sched/stats.h  # define sched_info_queued(rq, t)	do { } while (0)</span>
<span class='curline'><a href='../S/461.html#L271'>rq</a>                271 sched/stats.h  # define sched_info_dequeued(rq, t)	do { } while (0)</span>
<span class='curline'><a href='../S/461.html#L272'>rq</a>                272 sched/stats.h  # define sched_info_depart(rq, t)	do { } while (0)</span>
<span class='curline'><a href='../S/461.html#L273'>rq</a>                273 sched/stats.h  # define sched_info_arrive(rq, next)	do { } while (0)</span>
<span class='curline'><a href='../S/461.html#L274'>rq</a>                274 sched/stats.h  # define sched_info_switch(rq, t, next)	do { } while (0)</span>
<span class='curline'><a href='../S/439.html#L20'>rq</a>                 20 sched/stop_task.c balance_stop(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)</span>
<span class='curline'><a href='../S/439.html#L22'>rq</a>                 22 sched/stop_task.c 	return sched_stop_runnable(rq);</span>
<span class='curline'><a href='../S/439.html#L27'>rq</a>                 27 sched/stop_task.c check_preempt_curr_stop(struct rq *rq, struct task_struct *p, int flags)</span>
<span class='curline'><a href='../S/439.html#L32'>rq</a>                 32 sched/stop_task.c static void set_next_task_stop(struct rq *rq, struct task_struct *stop, bool first)</span>
<span class='curline'><a href='../S/439.html#L34'>rq</a>                 34 sched/stop_task.c 	stop-&gt;se.exec_start = rq_clock_task(rq);</span>
<span class='curline'><a href='../S/439.html#L37'>rq</a>                 37 sched/stop_task.c static struct task_struct *pick_next_task_stop(struct rq *rq)</span>
<span class='curline'><a href='../S/439.html#L39'>rq</a>                 39 sched/stop_task.c 	if (!sched_stop_runnable(rq))</span>
<span class='curline'><a href='../S/439.html#L42'>rq</a>                 42 sched/stop_task.c 	set_next_task_stop(rq, rq-&gt;stop, true);</span>
<span class='curline'><a href='../S/439.html#L43'>rq</a>                 43 sched/stop_task.c 	return rq-&gt;stop;</span>
<span class='curline'><a href='../S/439.html#L47'>rq</a>                 47 sched/stop_task.c enqueue_task_stop(struct rq *rq, struct task_struct *p, int flags)</span>
<span class='curline'><a href='../S/439.html#L49'>rq</a>                 49 sched/stop_task.c 	add_nr_running(rq, 1);</span>
<span class='curline'><a href='../S/439.html#L53'>rq</a>                 53 sched/stop_task.c dequeue_task_stop(struct rq *rq, struct task_struct *p, int flags)</span>
<span class='curline'><a href='../S/439.html#L55'>rq</a>                 55 sched/stop_task.c 	sub_nr_running(rq, 1);</span>
<span class='curline'><a href='../S/439.html#L58'>rq</a>                 58 sched/stop_task.c static void yield_task_stop(struct rq *rq)</span>
<span class='curline'><a href='../S/439.html#L63'>rq</a>                 63 sched/stop_task.c static void put_prev_task_stop(struct rq *rq, struct task_struct *prev)</span>
<span class='curline'><a href='../S/439.html#L65'>rq</a>                 65 sched/stop_task.c 	struct task_struct *curr = rq-&gt;curr;</span>
<span class='curline'><a href='../S/439.html#L68'>rq</a>                 68 sched/stop_task.c 	delta_exec = rq_clock_task(rq) - curr-&gt;se.exec_start;</span>
<span class='curline'><a href='../S/439.html#L78'>rq</a>                 78 sched/stop_task.c 	curr-&gt;se.exec_start = rq_clock_task(rq);</span>
<span class='curline'><a href='../S/439.html#L90'>rq</a>                 90 sched/stop_task.c static void task_tick_stop(struct rq *rq, struct task_struct *curr, int queued)</span>
<span class='curline'><a href='../S/439.html#L94'>rq</a>                 94 sched/stop_task.c static void switched_to_stop(struct rq *rq, struct task_struct *p)</span>
<span class='curline'><a href='../S/439.html#L100'>rq</a>                100 sched/stop_task.c prio_changed_stop(struct rq *rq, struct task_struct *p, int oldprio)</span>
<span class='curline'><a href='../S/439.html#L105'>rq</a>                105 sched/stop_task.c static void update_curr_stop(struct rq *rq)</span>
<span class='curline'><a href='../S/452.html#L445'>rq</a>                445 sched/topology.c void rq_attach_root(struct rq *rq, struct root_domain *rd)</span>
<span class='curline'><a href='../S/452.html#L450'>rq</a>                450 sched/topology.c 	raw_spin_lock_irqsave(&amp;rq-&gt;lock, flags);</span>
<span class='curline'><a href='../S/452.html#L452'>rq</a>                452 sched/topology.c 	if (rq-&gt;rd) {</span>
<span class='curline'><a href='../S/452.html#L453'>rq</a>                453 sched/topology.c 		old_rd = rq-&gt;rd;</span>
<span class='curline'><a href='../S/452.html#L455'>rq</a>                455 sched/topology.c 		if (cpumask_test_cpu(rq-&gt;cpu, old_rd-&gt;online))</span>
<span class='curline'><a href='../S/452.html#L456'>rq</a>                456 sched/topology.c 			set_rq_offline(rq);</span>
<span class='curline'><a href='../S/452.html#L458'>rq</a>                458 sched/topology.c 		cpumask_clear_cpu(rq-&gt;cpu, old_rd-&gt;span);</span>
<span class='curline'><a href='../S/452.html#L470'>rq</a>                470 sched/topology.c 	rq-&gt;rd = rd;</span>
<span class='curline'><a href='../S/452.html#L472'>rq</a>                472 sched/topology.c 	cpumask_set_cpu(rq-&gt;cpu, rd-&gt;span);</span>
<span class='curline'><a href='../S/452.html#L473'>rq</a>                473 sched/topology.c 	if (cpumask_test_cpu(rq-&gt;cpu, cpu_active_mask))</span>
<span class='curline'><a href='../S/452.html#L474'>rq</a>                474 sched/topology.c 		set_rq_online(rq);</span>
<span class='curline'><a href='../S/452.html#L476'>rq</a>                476 sched/topology.c 	raw_spin_unlock_irqrestore(&amp;rq-&gt;lock, flags);</span>
<span class='curline'><a href='../S/452.html#L668'>rq</a>                668 sched/topology.c 	struct rq *rq = cpu_rq(cpu);</span>
<span class='curline'><a href='../S/452.html#L703'>rq</a>                703 sched/topology.c 	rq_attach_root(rq, rd);</span>
<span class='curline'><a href='../S/452.html#L704'>rq</a>                704 sched/topology.c 	tmp = rq-&gt;sd;</span>
<span class='curline'><a href='../S/452.html#L705'>rq</a>                705 sched/topology.c 	rcu_assign_pointer(rq-&gt;sd, sd);</span>
<span class='curline'><a href='../S/452.html#L1980'>rq</a>               1980 sched/topology.c 	struct rq *rq = NULL;</span>
<span class='curline'><a href='../S/452.html#L2048'>rq</a>               2048 sched/topology.c 		rq = cpu_rq(i);</span>
<span class='curline'><a href='../S/452.html#L2052'>rq</a>               2052 sched/topology.c 		if (rq-&gt;cpu_capacity_orig &gt; READ_ONCE(d.rd-&gt;max_cpu_capacity))</span>
<span class='curline'><a href='../S/452.html#L2053'>rq</a>               2053 sched/topology.c 			WRITE_ONCE(d.rd-&gt;max_cpu_capacity, rq-&gt;cpu_capacity_orig);</span>
<span class='curline'><a href='../S/452.html#L2062'>rq</a>               2062 sched/topology.c 	if (rq &amp;&amp; sched_debug_enabled) {</span>
<span class='curline'><a href='../S/452.html#L2064'>rq</a>               2064 sched/topology.c 			cpumask_pr_args(cpu_map), rq-&gt;rd-&gt;max_cpu_capacity);</span>
<span class='curline'><a href='../S/290.html#L803'>rq</a>                803 trace/blktrace.c blk_trace_request_get_cgid(struct request_queue *q, struct request *rq)</span>
<span class='curline'><a href='../S/290.html#L805'>rq</a>                805 trace/blktrace.c 	if (!rq-&gt;bio)</span>
<span class='curline'><a href='../S/290.html#L808'>rq</a>                808 trace/blktrace.c 	return blk_trace_bio_get_cgid(q, rq-&gt;bio);</span>
<span class='curline'><a href='../S/290.html#L827'>rq</a>                827 trace/blktrace.c static void blk_add_trace_rq(struct request *rq, int error,</span>
<span class='curline'><a href='../S/290.html#L833'>rq</a>                833 trace/blktrace.c 	bt = rcu_dereference(rq-&gt;q-&gt;blk_trace);</span>
<span class='curline'><a href='../S/290.html#L839'>rq</a>                839 trace/blktrace.c 	if (blk_rq_is_passthrough(rq))</span>
<span class='curline'><a href='../S/290.html#L844'>rq</a>                844 trace/blktrace.c 	__blk_add_trace(bt, blk_rq_trace_sector(rq), nr_bytes, req_op(rq),</span>
<span class='curline'><a href='../S/290.html#L845'>rq</a>                845 trace/blktrace.c 			rq-&gt;cmd_flags, what, error, 0, NULL, cgid);</span>
<span class='curline'><a href='../S/290.html#L850'>rq</a>                850 trace/blktrace.c 				    struct request_queue *q, struct request *rq)</span>
<span class='curline'><a href='../S/290.html#L852'>rq</a>                852 trace/blktrace.c 	blk_add_trace_rq(rq, 0, blk_rq_bytes(rq), BLK_TA_INSERT,</span>
<span class='curline'><a href='../S/290.html#L853'>rq</a>                853 trace/blktrace.c 			 blk_trace_request_get_cgid(q, rq));</span>
<span class='curline'><a href='../S/290.html#L857'>rq</a>                857 trace/blktrace.c 				   struct request_queue *q, struct request *rq)</span>
<span class='curline'><a href='../S/290.html#L859'>rq</a>                859 trace/blktrace.c 	blk_add_trace_rq(rq, 0, blk_rq_bytes(rq), BLK_TA_ISSUE,</span>
<span class='curline'><a href='../S/290.html#L860'>rq</a>                860 trace/blktrace.c 			 blk_trace_request_get_cgid(q, rq));</span>
<span class='curline'><a href='../S/290.html#L864'>rq</a>                864 trace/blktrace.c 				   struct request_queue *q, struct request *rq)</span>
<span class='curline'><a href='../S/290.html#L866'>rq</a>                866 trace/blktrace.c 	blk_add_trace_rq(rq, 0, blk_rq_bytes(rq), BLK_TA_BACKMERGE,</span>
<span class='curline'><a href='../S/290.html#L867'>rq</a>                867 trace/blktrace.c 			 blk_trace_request_get_cgid(q, rq));</span>
<span class='curline'><a href='../S/290.html#L872'>rq</a>                872 trace/blktrace.c 				     struct request *rq)</span>
<span class='curline'><a href='../S/290.html#L874'>rq</a>                874 trace/blktrace.c 	blk_add_trace_rq(rq, 0, blk_rq_bytes(rq), BLK_TA_REQUEUE,</span>
<span class='curline'><a href='../S/290.html#L875'>rq</a>                875 trace/blktrace.c 			 blk_trace_request_get_cgid(q, rq));</span>
<span class='curline'><a href='../S/290.html#L878'>rq</a>                878 trace/blktrace.c static void blk_add_trace_rq_complete(void *ignore, struct request *rq,</span>
<span class='curline'><a href='../S/290.html#L881'>rq</a>                881 trace/blktrace.c 	blk_add_trace_rq(rq, error, nr_bytes, BLK_TA_COMPLETE,</span>
<span class='curline'><a href='../S/290.html#L882'>rq</a>                882 trace/blktrace.c 			 blk_trace_request_get_cgid(rq-&gt;q, rq));</span>
<span class='curline'><a href='../S/290.html#L929'>rq</a>                929 trace/blktrace.c 					struct request *rq,</span>
<span class='curline'><a href='../S/290.html#L937'>rq</a>                937 trace/blktrace.c 					 struct request *rq,</span>
<span class='curline'><a href='../S/290.html#L1092'>rq</a>               1092 trace/blktrace.c 				   struct request *rq, dev_t dev,</span>
<span class='curline'><a href='../S/290.html#L1106'>rq</a>               1106 trace/blktrace.c 	r.device_to   = cpu_to_be32(disk_devt(rq-&gt;rq_disk));</span>
<span class='curline'><a href='../S/290.html#L1109'>rq</a>               1109 trace/blktrace.c 	__blk_add_trace(bt, blk_rq_pos(rq), blk_rq_bytes(rq),</span>
<span class='curline'><a href='../S/290.html#L1110'>rq</a>               1110 trace/blktrace.c 			rq_data_dir(rq), 0, BLK_TA_REMAP, 0,</span>
<span class='curline'><a href='../S/290.html#L1111'>rq</a>               1111 trace/blktrace.c 			sizeof(r), &amp;r, blk_trace_request_get_cgid(q, rq));</span>
<span class='curline'><a href='../S/290.html#L1127'>rq</a>               1127 trace/blktrace.c 			 struct request *rq,</span>
<span class='curline'><a href='../S/290.html#L1139'>rq</a>               1139 trace/blktrace.c 	__blk_add_trace(bt, blk_rq_trace_sector(rq), blk_rq_bytes(rq), 0, 0,</span>
<span class='curline'><a href='../S/290.html#L1141'>rq</a>               1141 trace/blktrace.c 				blk_trace_request_get_cgid(q, rq));</span>
</pre>
</body>
</html>
